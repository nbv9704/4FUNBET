=== D:\Downloads\cado4fun\client\src\app\admin\pvp\health\page.js ===

// client/src/app/admin/pvp/health/page.js
'use client'

import { useEffect, useMemo, useState } from 'react'
import useApi from '@/hooks/useApi'
import Link from 'next/link'

export default function AdminPvpHealthPage() {
  const api = useApi()
  const [data, setData] = useState(null)
  const [loading, setLoading] = useState(false)
  const [error, setError] = useState('')
  const [autoRefresh, setAutoRefresh] = useState(true)

  async function load() {
    try {
      setLoading(true)
      setError('')
      const res = await api.get('/admin/pvp/health')
      setData(res)
    } catch (e) {
      setError(e?.message || 'Failed to load health')
      setData(null)
    } finally {
      setLoading(false)
    }
  }

  useEffect(() => {
    load()
  }, []) // init

  // Auto refresh m·ªói 5s
  useEffect(() => {
    if (!autoRefresh) return
    const id = setInterval(() => load(), 5000)
    return () => clearInterval(id)
  }, [autoRefresh])

  const lastSweepAtText = useMemo(() => {
    const ts = data?.cron?.lastSweepAt
    const iso = data?.cron?.lastSweepIso
    if (!ts) return '-'
    try {
      const d = iso ? new Date(iso) : new Date(ts)
      const agoSec = Math.max(0, Math.round((Date.now() - d.getTime())/1000))
      return `${d.toLocaleString()} (${agoSec}s ago)`
    } catch {
      return String(ts)
    }
  }, [data?.cron?.lastSweepAt, data?.cron?.lastSweepIso])

  const nextSweepAtText = useMemo(() => {
    const ts = data?.cron?.nextSweepAt
    const iso = data?.cron?.nextSweepIso
    if (!ts) return '-'
    try {
      const d = iso ? new Date(iso) : new Date(ts)
      const inSec = Math.max(0, Math.round((d.getTime() - Date.now())/1000))
      return `${d.toLocaleString()} (in ${inSec}s)`
    } catch {
      return String(ts)
    }
  }, [data?.cron?.nextSweepAt, data?.cron?.nextSweepIso])

  const serverNowText = useMemo(() => {
    const ts = data?.serverNow
    const iso = data?.serverNowIso
    if (!ts) return '-'
    try { return (iso ? new Date(iso) : new Date(ts)).toLocaleString() } catch { return String(ts) }
  }, [data?.serverNow, data?.serverNowIso])

  return (
    <div className="p-4 max-w-4xl mx-auto">
      <div className="flex items-center justify-between">
        <div>
          <h1 className="text-2xl font-semibold">PvP Health</h1>
          <div className="text-sm opacity-70">Admin only</div>
        </div>
        <div className="flex items-center gap-2">
          <button
            onClick={load}
            className="px-3 py-2 rounded border shadow text-sm"
            disabled={loading}
            title="Refresh now"
          >
            {loading ? 'Refreshing‚Ä¶' : 'Refresh'}
          </button>
          <label className="text-sm flex items-center gap-2">
            <input
              type="checkbox"
              checked={autoRefresh}
              onChange={e => setAutoRefresh(e.target.checked)}
            />
            Auto refresh (5s)
          </label>
          <Link href="/" className="text-sm underline">Back</Link>
        </div>
      </div>

      {error && <div className="mt-4 text-sm text-red-500">{error}</div>}

      {!error && (
        <div className="mt-4 grid md:grid-cols-2 gap-4">
          {/* Summary */}
          <div className="border rounded-2xl p-4">
            <div className="text-lg font-semibold mb-2">Summary</div>
            <div className="text-sm space-y-1">
              <div>Server now: <b>{serverNowText}</b></div>
              <div>Cron sweep interval: <b>{(data?.cron?.sweepIntervalMs ?? 0) / 1000}s</b></div>
              <div>Last sweep at: <b>{lastSweepAtText}</b></div>
              <div>Next sweep at: <b>{nextSweepAtText}</b></div>
              <div>Uptime: <b>{(data?.uptimeSec ?? 0)}s</b></div>
            </div>
          </div>

          {/* Counts by status */}
          <div className="border rounded-2xl p-4">
            <div className="text-lg font-semibold mb-2">Rooms by status</div>
            {data?.counts ? (
              <ul className="text-sm space-y-1">
                {Object.entries(data.counts).map(([k,v]) => (
                  <li key={k} className="flex justify-between">
                    <span className="capitalize">{k}</span>
                    <b>{v}</b>
                  </li>
                ))}
              </ul>
            ) : <div className="text-sm opacity-70">No data</div>}
          </div>

          {/* Stale queues */}
          <div className="border rounded-2xl p-4 md:col-span-2">
            <div className="text-lg font-semibold mb-2">Stale Pending</div>
            {data?.stale ? (
              <div className="grid sm:grid-cols-2 gap-3 text-sm">
                <div className="rounded-xl border p-3">
                  <div className="opacity-70">Coinflip (revealAt passed)</div>
                  <div className="text-2xl font-bold">{data.stale.coinflip}</div>
                </div>
                <div className="rounded-xl border p-3">
                  <div className="opacity-70">Dice (advanceAt passed)</div>
                  <div className="text-2xl font-bold">{data.stale.dice}</div>
                </div>
              </div>
            ) : <div className="text-sm opacity-70">No data</div>}
          </div>

          {/* Raw JSON */}
          <div className="border rounded-2xl p-4 md:col-span-2">
            <div className="text-lg font-semibold mb-2">Raw payload</div>
            <pre className="text-xs bg-black/5 dark:bg-white/10 rounded p-3 overflow-auto">
{JSON.stringify(data, null, 2)}
            </pre>
          </div>
        </div>
      )}
    </div>
  )
}




=== D:\Downloads\cado4fun\client\src\app\api\pvp\[...path]\route.js ===




=== D:\Downloads\cado4fun\client\src\app\game\battle\[gameId]\page.js ===




=== D:\Downloads\cado4fun\client\src\app\game\battle\room\[roomId]\page.js ===




=== D:\Downloads\cado4fun\client\src\app\game\battle\page.js ===

// client/src/app/game/battle/page.js
"use client";

import RequireAuth from '@/components/RequireAuth'
import { GAMES } from "@/data/games";
import Link from "next/link";
import GameCard from "@/components/GameCard";

const HAS_THUMB = new Set(["coinflip", "dice", "blackjackdice"]);

function BattleSelectPage() {
  const battleGames = GAMES.filter((g) => g.supports.includes("battle"));
  const sorted = [...battleGames].sort((a, b) => {
    const aHas = HAS_THUMB.has(a.id) ? 1 : 0;
    const bHas = HAS_THUMB.has(b.id) ? 1 : 0;
    if (bHas !== aHas) return bHas - aHas;
    return a.name.localeCompare(b.name);
  });

  return (
    <div className="p-4 max-w-6xl mx-auto">
      <div className="flex items-center justify-between mb-4">
        <h1 className="text-2xl font-semibold">Battle ‚Äî Select a game</h1>
        <Link href="/game" className="text-sm underline">
          Back
        </Link>
      </div>

      {/* ƒê·ªìng b·ªô l∆∞·ªõi v√† card v·ªõi Solo */}
      <div className="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 xl:grid-cols-5 gap-5 items-stretch">
        {sorted.map((g) => (
          <Link
            key={g.id}
            href={`/game/battle/${g.id}`}
            className="block rounded-2xl focus:outline-none focus:ring-2 focus:ring-offset-2"
          >
            <GameCard mode={g.id} fluid />
          </Link>
        ))}
      </div>
    </div>
  );
}
export default RequireAuth(BattleSelectPage)



=== D:\Downloads\cado4fun\client\src\app\game\blackjackdice\page.js ===

// client/src/app/game/blackjackdice/page.js
'use client'

import { useEffect, useState } from 'react'
import useApi from '../../../hooks/useApi'
import { useUser } from '../../../context/UserContext'
import Loading from '../../../components/Loading'
import { toast } from 'react-hot-toast'

export default function BlackjackDicePage() {
  const [betAmount, setBetAmount] = useState(1)
  const [state, setState] = useState(null)
  const [isActive, setIsActive] = useState(false)
  const [loading, setLoading] = useState(false)
  const [hasPendingGame, setHasPendingGame] = useState(false)
  const { post } = useApi()
  const { updateBalance } = useUser()
  
  useEffect(() => {
    const checkGame = async () => {
      try {
        const data = await post('/game/blackjackdice/check')
        if (data.active) {
          setHasPendingGame(true)
          setState(data.state)
        }
      } catch (err) {
        console.error(err)
      }
    }
    checkGame()
  }, [])

  const handleStart = async (e) => {
    e.preventDefault()
    setLoading(true)
    try {
      const data = await post('/game/blackjackdice/start', { betAmount })
      setState({
        playerDice: data.playerDice,
        playerSum: data.playerSum,
        dealerVisible: data.dealerVisible,
        dealerDice: null,
        dealerSum: null,
        outcome: null,
        payout: null,
        balance: data.balance,
      })
      updateBalance(data.balance)
      setIsActive(true)
      setHasPendingGame(false)
    } catch (err) {
      toast.error(err.message)
    } finally {
      setLoading(false)
    }
  }

  const handleResume = async () => {
    try {
      const data = await post('/game/blackjackdice/resume')
      setState({
        playerDice: data.playerDice,
        playerSum: data.playerSum,
        dealerVisible: data.dealerVisible,
        dealerDice: null,
        dealerSum: null,
        outcome: null,
        payout: null,
        balance: data.balance,
      })
      updateBalance(data.balance)
      setIsActive(true)
      setHasPendingGame(false)
    } catch (err) {
      toast.error(err.message)
    }
  }

  const handleAbandon = async () => {
    try {
      await post('/game/blackjackdice/abandon')
      toast('Game abandoned')
      setHasPendingGame(false)
      setState(null)
    } catch (err) {
      toast.error(err.message)
    }
  }

  const handleHit = async () => {
    setLoading(true)
    try {
      const data = await post('/game/blackjackdice/hit')
      if (data.outcome) {
        setState({
          ...state,
          playerDice: data.playerDice,
          playerSum: data.playerSum,
          dealerDice: data.dealerDice,
          dealerSum: data.dealerSum,
          outcome: data.outcome,
          payout: data.payout,
          balance: data.balance,
        })
        updateBalance(data.balance)
        setIsActive(false)
        if (data.outcome === 'win') toast.success(`üéâ You win! Payout: ${data.payout}`)
        else if (data.outcome === 'lose') toast.error('üò¢ You lose.')
        else if (data.outcome === 'tie') toast(`üòê It's a tie. Refund: ${data.payout}`, { icon: '‚ÑπÔ∏è' })
      } else {
        setState({
          ...state,
          playerDice: data.playerDice,
          playerSum: data.playerSum,
          dealerVisible: data.dealerVisible,
          balance: data.balance,
        })
        updateBalance(data.balance)
      }
    } catch (err) {
      toast.error(err.message)
    } finally {
      setLoading(false)
    }
  }

  const handleStand = async () => {
    setLoading(true)
    try {
      const data = await post('/game/blackjackdice/stand')
      setState({
        ...state,
        playerDice: data.playerDice,
        playerSum: data.playerSum,
        dealerDice: data.dealerDice,
        dealerSum: data.dealerSum,
        outcome: data.outcome,
        payout: data.payout,
        balance: data.balance,
      })
      updateBalance(data.balance)
      setIsActive(false)
      if (data.outcome === 'win') toast.success(`üéâ You win! Payout: ${data.payout}`)
      else if (data.outcome === 'lose') toast.error('üò¢ You lose.')
      else if (data.outcome === 'tie') toast(`üòê It's a tie. Refund: ${data.payout}`, { icon: '‚ÑπÔ∏è' })
    } catch (err) {
      toast.error(err.message)
    } finally {
      setLoading(false)
    }
  }

  const dealerToShow = !isActive && state?.dealerDice
    ? state.dealerDice
    : state?.dealerVisible || []

  if (loading) return <Loading text="ƒêang t·∫£i Blackjack Dice‚Ä¶" />

  return (
    <div className="p-8">
      <h1 className="text-3xl font-bold mb-6">Blackjack Dice</h1>

      {!isActive && !hasPendingGame && (
        <form onSubmit={handleStart} className="space-y-4 mb-6">
          <div>
            <label className="mr-2 font-medium">Bet Amount:</label>
            <input
              type="number"
              min="1"
              value={betAmount}
              onChange={(e) => setBetAmount(+e.target.value)}
              className="border rounded px-2 py-1 w-24"
            />
          </div>
          <button type="submit" className="px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700">
            Start Game
          </button>
        </form>
      )}

      {!isActive && hasPendingGame && (
        <div className="flex space-x-4 mb-6">
          <button onClick={handleResume} className="px-4 py-2 bg-green-600 text-white rounded hover:bg-green-700">
            Continue Game
          </button>
          <button onClick={handleAbandon} className="px-4 py-2 bg-red-600 text-white rounded hover:bg-red-700">
            Abandon Game
          </button>
        </div>
      )}

      {state && (
        <div className="space-y-6">
          <div>
            <h2 className="font-semibold">Your Dice (Sum: {state.playerSum})</h2>
            <div className="flex space-x-2 mt-2">
              {state.playerDice.map((d, i) => (
                <div key={i} className="w-12 h-12 flex items-center justify-center border rounded">
                  {d}
                </div>
              ))}
            </div>
          </div>

          <div>
            <h2 className="font-semibold">
              Dealer Dice
              {!isActive && state.dealerSum != null && ` (Sum: ${state.dealerSum})`}
            </h2>
            <div className="flex space-x-2 mt-2">
              {dealerToShow.map((d, i) => (
                <div
                  key={i}
                  className="w-12 h-12 flex items-center justify-center border rounded bg-gray-100 text-gray-900"
                >
                  {d === null ? '?' : d}
                </div>
              ))}
            </div>
          </div>

          {isActive && (
            <div className="flex space-x-4">
              <button onClick={handleHit} className="px-4 py-2 bg-green-600 text-white rounded hover:bg-green-700">
                Hit
              </button>
              <button onClick={handleStand} className="px-4 py-2 bg-yellow-600 text-white rounded hover:bg-yellow-700">
                Stand
              </button>
            </div>
          )}

          <p className="mt-4">Balance: {state.balance}</p>
        </div>
      )}
    </div>
  )
}




=== D:\Downloads\cado4fun\client\src\app\game\coinflip\page.js ===

// client/src/app/game/coinflip/page.js
'use client'

import { useState } from 'react'
import useApi from '../../../hooks/useApi'
import { useUser } from '../../../context/UserContext'
import { toast } from 'react-hot-toast'

export default function CoinflipPage() {
  const [betAmount, setBetAmount] = useState(1)
  const [side, setSide] = useState('heads')
  const [result, setResult] = useState(null)
  const [isFlipping, setIsFlipping] = useState(false)

  const { post } = useApi()
  const { updateBalance } = useUser()

  const handleFlip = async (e) => {
    e.preventDefault()
    if (betAmount <= 0) {
      toast.error('Bet must be > 0')
      return
    }
    setIsFlipping(true)
    setResult(null)

    try {
      // Kh√¥ng g·ª≠i clientSeed ‚Äî server v·∫´n ch·∫°y fair RNG v·ªõi seed/nonce c·ªßa n√≥
      const data = await post('/game/coinflip', { betAmount, side })

      setTimeout(() => {
        setResult({
          result: data.result,
          win: data.win,
          payout: data.payout,   // ‚úÖ tin server
          balance: data.balance,
        })
        updateBalance(data.balance)
        setIsFlipping(false)

        if (data.win) {
          toast.success(`üéâ You win! The coin showed ${data.result}`)
        } else {
          toast.error(`üò¢ You lose. The coin showed ${data.result}`)
        }
      }, 1500)
    } catch (err) {
      toast.error(err.message || 'Flip failed')
      setIsFlipping(false)
    }
  }

  return (
    <div className="p-8 max-w-xl mx-auto">
      <h1 className="text-3xl font-bold mb-6">Coinflip</h1>

      {/* Bet form */}
      <form onSubmit={handleFlip} className="space-y-4 mb-6">
        <div className="flex items-center gap-2">
          <label className="w-36 font-medium">Bet Amount:</label>
          <input
            type="number"
            min="1"
            value={betAmount}
            onChange={(e) => setBetAmount(+e.target.value)}
            className="border rounded px-2 py-1 w-32"
          />
        </div>

        <div className="flex items-center gap-4">
          <span className="w-36 font-medium">Choose Side:</span>
          <label className="flex items-center gap-1">
            <input
              type="radio"
              name="side"
              value="heads"
              checked={side === 'heads'}
              onChange={() => setSide('heads')}
            />
            Heads
          </label>
          <label className="flex items-center gap-1">
            <input
              type="radio"
              name="side"
              value="tails"
              checked={side === 'tails'}
              onChange={() => setSide('tails')}
            />
            Tails
          </label>
        </div>

        <button
          type="submit"
          className="px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700 disabled:opacity-60"
          disabled={isFlipping}
        >
          {isFlipping ? 'Flipping...' : 'Flip Coin'}
        </button>
      </form>

      {/* Coin Animation + Result */}
      <div className="mt-6 flex flex-col items-center">
        <div
          className={`w-24 h-24 rounded-full border-4 flex items-center justify-center text-xl font-bold
                      ${isFlipping ? 'animate-flip' : ''}`}
        >
          {isFlipping ? '' : result?.result?.toUpperCase() || '?'}
        </div>

        {result && !isFlipping && (
          <div className="mt-4 w-full text-center space-y-1">
            <p className="text-lg">{result.win ? '‚úÖ You WON' : '‚ùå You LOST'}</p>
            <p>Payout: <b>{result.payout}</b></p>
            <p>Balance: <b>{result.balance}</b></p>
          </div>
        )}
      </div>
    </div>
  )
}




=== D:\Downloads\cado4fun\client\src\app\game\dice\page.js ===

// client/src/app/game/dice/page.js
'use client'

import { useState } from 'react'
import useApi from '../../../hooks/useApi'
import { useUser } from '../../../context/UserContext'
import { toast } from 'react-hot-toast'

const ALLOWED_SIDES = [4, 6, 8, 10, 12, 20]

export default function DicePage() {
  const [betAmount, setBetAmount] = useState(1)
  const [sides, setSides] = useState(6)
  const [guess, setGuess] = useState(1)
  const [result, setResult] = useState(null)
  const [isRolling, setIsRolling] = useState(false)
  const { post } = useApi()
  const { updateBalance } = useUser()

  const handleRoll = async (e) => {
    e.preventDefault()
    if (betAmount <= 0) return toast.error('Bet must be > 0')
    if (guess < 1 || guess > sides) return toast.error(`Guess must be 1..${sides}`)

    setIsRolling(true)
    setResult(null)

    try {
      const data = await post('/game/dice', { betAmount, sides, guess })
      setTimeout(() => {
        setResult({
          result: data.result,
          win: data.win,
          payout: data.payout,
          balance: data.balance,
          sides: data.sides,
        })
        updateBalance(data.balance)
        setIsRolling(false)
        data.win
          ? toast.success(`üéâ You win! Rolled ${data.result} on d${data.sides}`)
          : toast.error(`üò¢ You lose. Rolled ${data.result} on d${data.sides}`)
      }, 1500)
    } catch (err) {
      toast.error(err.message || 'Roll failed')
      setIsRolling(false)
    }
  }

  return (
    <div className="p-8">
      <h1 className="text-3xl font-bold mb-6">Dice Game</h1>

      <form onSubmit={handleRoll} className="space-y-4 mb-6">
        <div>
          <label className="mr-2 font-medium">Bet Amount:</label>
          <input type="number" min="1" value={betAmount}
            onChange={(e) => setBetAmount(+e.target.value)}
            className="border rounded px-2 py-1 w-24"/>
        </div>

        <div>
          <label className="mr-2 font-medium">Dice Type:</label>
          <select value={sides}
            onChange={(e) => {
              const s = +e.target.value
              setSides(s)
              if (guess > s) setGuess(1)
            }}
            className="border rounded px-2 py-1">
            {ALLOWED_SIDES.map((s) => <option key={s} value={s}>d{s}</option>)}
          </select>
        </div>

        <div>
          <label className="mr-2 font-medium">Your Guess:</label>
          <input type="number" min="1" max={sides} value={guess}
            onChange={(e) => setGuess(+e.target.value)}
            className="border rounded px-2 py-1 w-24"/>
          <span className="ml-2 text-sm text-gray-500">(1 - {sides})</span>
        </div>

        <button type="submit" className="px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700"
          disabled={isRolling}>{isRolling ? 'Rolling...' : 'Roll Dice'}</button>
      </form>

      <div className="mt-6 flex flex-col items-center">
        <div
          className={`w-24 h-24 bg-gray-800 text-white rounded-lg border-4 flex items-center justify-center text-3xl font-bold
                      ${isRolling ? 'animate-dice-roll-3d' : ''}`}
          style={{ perspective: '800px' }}
        >
          {isRolling ? '' : result?.result ?? '?'}
        </div>
        {result && !isRolling && (
          <div className="mt-4 text-center space-y-2">
            <p className="text-lg">Payout: {result.payout}</p>
            <p className="font-semibold">Balance: {result.balance}</p>
          </div>
        )}
      </div>
    </div>
  )
}




=== D:\Downloads\cado4fun\client\src\app\game\higherlower\page.js ===

// client/src/app/game/higherlower/page.js
'use client'

import RequireAuth from '@/components/RequireAuth'
import { useState, useEffect } from 'react'
import useApi from '@/hooks/useApi'
import { useUser } from '@/context/UserContext'
import { toast } from 'react-hot-toast'

function HigherLowerPage() {
  const { post } = useApi()
  const { updateBalance } = useUser()

  const [betAmount, setBetAmount] = useState(1)
  const [currentNumber, setCurrentNumber] = useState(10)
  const [nextNumber, setNextNumber] = useState(null)
  const [streak, setStreak] = useState(0)
  const [history, setHistory] = useState([])
  const [guessing, setGuessing] = useState(false)
  const [showResult, setShowResult] = useState(false)

  const handleGuess = async (guess) => {
    if (betAmount <= 0) {
      toast.error('Bet must be > 0')
      return
    }

    setGuessing(true)
    setShowResult(false)

    try {
      const data = await post('/game/higherlower', { betAmount, guess })

      // Animate number reveal
      setTimeout(() => {
        setNextNumber(data.result)
        setShowResult(true)
        updateBalance(data.balance)

        if (data.tie) {
          toast(`ü§ù It's a tie! Both were ${data.initial}`, { icon: '‚ÑπÔ∏è' })
          setStreak(0)
          setHistory(prev => [...prev, { from: data.initial, to: data.result, guess, outcome: 'tie' }].slice(-10))
        } else if (data.win) {
          toast.success(`üéâ Correct! ${data.initial} ‚Üí ${data.result}`)
          setStreak(data.streak)
          setHistory(prev => [...prev, { from: data.initial, to: data.result, guess, outcome: 'win' }].slice(-10))
        } else {
          toast.error(`üò¢ Wrong! ${data.initial} ‚Üí ${data.result}`)
          setStreak(0)
          setHistory(prev => [...prev, { from: data.initial, to: data.result, guess, outcome: 'lose' }].slice(-10))
        }

        // Prepare for next round
        setTimeout(() => {
          setCurrentNumber(data.result)
          setNextNumber(null)
          setShowResult(false)
          setGuessing(false)
        }, 2000)
      }, 1500)
    } catch (err) {
      setGuessing(false)
      setShowResult(false)
      // Error toast handled by useApi
    }
  }

  return (
    <div className="p-8 max-w-2xl mx-auto">
      <h1 className="text-3xl font-bold mb-6">Higher or Lower</h1>

      {/* Streak Display */}
      {streak > 0 && (
        <div className="mb-4 p-4 rounded-xl border-2 border-yellow-400 bg-yellow-50 dark:bg-yellow-900/20 text-center">
          <div className="text-2xl font-bold text-yellow-600 dark:text-yellow-400">
            üî• {streak} WIN STREAK! üî•
          </div>
          <div className="text-sm opacity-80 mt-1">
            Current multiplier: {0.5 + streak * 0.5}x
          </div>
        </div>
      )}

      {/* Game Board */}
      <div className="bg-gradient-to-br from-blue-500 to-purple-600 rounded-3xl p-8 shadow-2xl mb-6">
        {/* Current Number */}
        <div className="bg-white dark:bg-gray-900 rounded-2xl p-8 mb-6 text-center">
          <div className="text-sm opacity-70 mb-2">Current Number</div>
          <div className="text-8xl font-bold text-transparent bg-clip-text bg-gradient-to-r from-blue-600 to-purple-600">
            {currentNumber}
          </div>
        </div>

        {/* Next Number (when revealed) */}
        {showResult && nextNumber !== null && (
          <div className="bg-white dark:bg-gray-900 rounded-2xl p-8 mb-6 text-center animate-pulse">
            <div className="text-sm opacity-70 mb-2">Next Number</div>
            <div className="text-8xl font-bold text-transparent bg-clip-text bg-gradient-to-r from-green-600 to-blue-600">
              {nextNumber}
            </div>
          </div>
        )}

        {/* Bet Amount */}
        <div className="bg-white/20 backdrop-blur rounded-xl p-4 mb-6">
          <label className="block mb-2 font-medium text-white text-sm">Bet Amount:</label>
          <input
            type="number"
            min="1"
            value={betAmount}
            onChange={(e) => setBetAmount(+e.target.value)}
            className="w-full border rounded-xl px-4 py-2 bg-white dark:bg-gray-800 text-gray-900 dark:text-white"
            disabled={guessing}
          />
        </div>

        {/* Guess Buttons */}
        <div className="grid grid-cols-2 gap-4">
          <button
            onClick={() => handleGuess('lower')}
            disabled={guessing}
            className="px-8 py-6 bg-gradient-to-br from-red-500 to-red-700 text-white rounded-2xl font-bold text-2xl hover:from-red-600 hover:to-red-800 disabled:opacity-60 disabled:cursor-not-allowed transition-all shadow-lg"
          >
            ‚¨áÔ∏è LOWER
          </button>
          <button
            onClick={() => handleGuess('higher')}
            disabled={guessing}
            className="px-8 py-6 bg-gradient-to-br from-green-500 to-green-700 text-white rounded-2xl font-bold text-2xl hover:from-green-600 hover:to-green-800 disabled:opacity-60 disabled:cursor-not-allowed transition-all shadow-lg"
          >
            ‚¨ÜÔ∏è HIGHER
          </button>
        </div>

        {guessing && (
          <div className="mt-4 text-center text-white text-lg font-semibold animate-pulse">
            Revealing...
          </div>
        )}
      </div>

      {/* History */}
      {history.length > 0 && (
        <div className="rounded-2xl border p-4">
          <h2 className="text-lg font-semibold mb-3">Recent History</h2>
          <div className="space-y-2">
            {[...history].reverse().map((h, i) => (
              <div
                key={i}
                className={`flex items-center justify-between p-3 rounded-xl border ${
                  h.outcome === 'win'
                    ? 'bg-green-50 dark:bg-green-900/20 border-green-300'
                    : h.outcome === 'lose'
                    ? 'bg-red-50 dark:bg-red-900/20 border-red-300'
                    : 'bg-gray-50 dark:bg-gray-800 border-gray-300'
                }`}
              >
                <div className="flex items-center gap-3">
                  <span className="text-2xl font-bold">{h.from}</span>
                  <span className="text-sm opacity-70">
                    {h.guess === 'higher' ? '‚¨ÜÔ∏è' : '‚¨áÔ∏è'}
                  </span>
                  <span className="text-2xl font-bold">{h.to}</span>
                </div>
                <div className="text-lg font-semibold">
                  {h.outcome === 'win' ? '‚úÖ' : h.outcome === 'lose' ? '‚ùå' : 'ü§ù'}
                </div>
              </div>
            ))}
          </div>
        </div>
      )}

      {/* Rules */}
      <div className="mt-6 rounded-2xl border p-4 text-sm opacity-80">
        <h3 className="font-semibold mb-2">How to Play:</h3>
        <ul className="space-y-1 list-disc list-inside">
          <li>Numbers range from 1 to 20</li>
          <li>Guess if the next number will be HIGHER or LOWER</li>
          <li>Build a win streak for bonus multipliers (+0.5x per win)</li>
          <li>Ties reset your streak but refund your bet</li>
          <li>Maximum multiplier increases with your streak!</li>
        </ul>
      </div>
    </div>
  )
}

export default RequireAuth(HigherLowerPage)



=== D:\Downloads\cado4fun\client\src\app\game\roulette\page.js ===

// client/src/app/game/roulette/page.js
'use client'

import RequireAuth from '@/components/RequireAuth'
import { useState } from 'react'
import useApi from '@/hooks/useApi'
import { useUser } from '@/context/UserContext'
import { toast } from 'react-hot-toast'

// S·ªë tr√™n b√°nh xe (European style: 0-36)
const WHEEL_NUMBERS = [
  0, 32, 15, 19, 4, 21, 2, 25, 17, 34, 6, 27, 13, 36, 11, 30, 8, 23, 10,
  5, 24, 16, 33, 1, 20, 14, 31, 9, 22, 18, 29, 7, 28, 12, 35, 3, 26
]

// M√†u s·∫Øc (0 = green, odd = red, even = black)
const getColor = (num) => {
  if (num === 0) return 'green'
  return num % 2 === 0 ? 'black' : 'red'
}

// Ranges cho betting
const RANGES = ['1-9', '10-18', '19-27', '28-36']

function RoulettePage() {
  const { post } = useApi()
  const { updateBalance } = useUser()

  const [betAmount, setBetAmount] = useState(5)
  const [betType, setBetType] = useState('color') // 'zero' | 'range' | 'color' | 'number'
  const [betValue, setBetValue] = useState('red') // red/black | range | number
  
  const [spinning, setSpinning] = useState(false)
  const [result, setResult] = useState(null)
  const [spinDegrees, setSpinDegrees] = useState(0)

  const handleSpin = async (e) => {
    e.preventDefault()
    
    if (betAmount <= 0) {
      toast.error('Bet must be > 0')
      return
    }

    // Validate betValue
    if (betType === 'range' && !RANGES.includes(betValue)) {
      toast.error('Invalid range')
      return
    }
    if (betType === 'color' && !['red', 'black'].includes(betValue)) {
      toast.error('Invalid color')
      return
    }
    if (betType === 'number') {
      const num = parseInt(betValue)
      if (isNaN(num) || num < 0 || num > 36) {
        toast.error('Number must be 0-36')
        return
      }
    }

    setSpinning(true)
    setResult(null)

    try {
      const data = await post('/game/roulette', {
        betAmount,
        betType,
        betValue: betType === 'number' ? parseInt(betValue) : betValue
      })

      // Animation: spin wheel
      const resultNum = data.result?.number
      const idx = WHEEL_NUMBERS.indexOf(resultNum)
      const segmentDeg = 360 / WHEEL_NUMBERS.length
      const targetDeg = idx * segmentDeg
      
      // Spin 5 full rotations + target position
      const finalDeg = 360 * 5 + targetDeg
      setSpinDegrees(finalDeg)

      setTimeout(() => {
        setResult(data.result)
        updateBalance(data.balance)
        setSpinning(false)

        if (data.win) {
          toast.success(`üéâ You win! ${data.result.number} (${data.result.color})`)
        } else {
          toast.error(`üò¢ You lose. ${data.result.number} (${data.result.color})`)
        }
      }, 3000) // Match animation duration
    } catch (err) {
      setSpinning(false)
      // Error toast handled by useApi
    }
  }

  return (
    <div className="p-8 max-w-4xl mx-auto">
      <h1 className="text-3xl font-bold mb-6">Roulette</h1>

      {/* Wheel */}
      <div className="flex justify-center mb-8">
        <div className="relative w-64 h-64">
          {/* Wheel SVG */}
          <svg
            viewBox="0 0 200 200"
            className={`w-full h-full ${spinning ? 'animate-wheel-spin' : ''}`}
            style={{
              transform: `rotate(${spinDegrees}deg)`,
              transition: spinning ? 'transform 3s cubic-bezier(0.17, 0.67, 0.12, 0.99)' : 'none'
            }}
          >
            {WHEEL_NUMBERS.map((num, idx) => {
              const angle = (idx * 360) / WHEEL_NUMBERS.length
              const color = getColor(num)
              const fillColor = color === 'green' ? '#10b981' : color === 'red' ? '#ef4444' : '#1f2937'
              
              return (
                <g key={idx} transform={`rotate(${angle} 100 100)`}>
                  <path
                    d="M 100 100 L 100 10 A 90 90 0 0 1 109.7 10.5 Z"
                    fill={fillColor}
                    stroke="white"
                    strokeWidth="0.5"
                  />
                  <text
                    x="100"
                    y="25"
                    textAnchor="middle"
                    fill="white"
                    fontSize="8"
                    fontWeight="bold"
                  >
                    {num}
                  </text>
                </g>
              )
            })}
            {/* Center circle */}
            <circle cx="100" cy="100" r="20" fill="#fbbf24" stroke="white" strokeWidth="2" />
          </svg>

          {/* Pointer */}
          <div className="absolute top-0 left-1/2 -translate-x-1/2 -translate-y-2">
            <div className="w-0 h-0 border-l-8 border-r-8 border-t-12 border-l-transparent border-r-transparent border-t-yellow-400" />
          </div>
        </div>
      </div>

      {/* Result */}
      {result && !spinning && (
        <div className="text-center mb-6 p-4 rounded-xl border-2 border-yellow-400 bg-yellow-50 dark:bg-yellow-900/20">
          <div className="text-2xl font-bold">
            Result: <span className={`${result.color === 'red' ? 'text-red-500' : result.color === 'black' ? 'text-gray-900 dark:text-white' : 'text-green-500'}`}>
              {result.number} ({result.color.toUpperCase()})
            </span>
          </div>
          <div className="text-lg mt-2">Payout: {result.payout}</div>
        </div>
      )}

      {/* Betting Form */}
      <form onSubmit={handleSpin} className="space-y-6 max-w-2xl mx-auto">
        {/* Bet Amount */}
        <div>
          <label className="block mb-2 font-medium">Bet Amount:</label>
          <input
            type="number"
            min="5"
            value={betAmount}
            onChange={(e) => setBetAmount(+e.target.value)}
            className="w-full border rounded-xl px-4 py-2 bg-white dark:bg-gray-800"
            disabled={spinning}
          />
        </div>

        {/* Bet Type */}
        <div>
          <label className="block mb-2 font-medium">Bet Type:</label>
          <div className="grid grid-cols-2 md:grid-cols-4 gap-2">
            <button
              type="button"
              onClick={() => { setBetType('zero'); setBetValue('0') }}
              className={`px-4 py-2 rounded-xl border-2 ${betType === 'zero' ? 'border-green-500 bg-green-50 dark:bg-green-900/20' : 'border-gray-300'}`}
              disabled={spinning}
            >
              Zero (16x)
            </button>
            <button
              type="button"
              onClick={() => { setBetType('color'); setBetValue('red') }}
              className={`px-4 py-2 rounded-xl border-2 ${betType === 'color' ? 'border-red-500 bg-red-50 dark:bg-red-900/20' : 'border-gray-300'}`}
              disabled={spinning}
            >
              Color (2x)
            </button>
            <button
              type="button"
              onClick={() => { setBetType('range'); setBetValue('1-9') }}
              className={`px-4 py-2 rounded-xl border-2 ${betType === 'range' ? 'border-blue-500 bg-blue-50 dark:bg-blue-900/20' : 'border-gray-300'}`}
              disabled={spinning}
            >
              Range (4x)
            </button>
            <button
              type="button"
              onClick={() => { setBetType('number'); setBetValue('7') }}
              className={`px-4 py-2 rounded-xl border-2 ${betType === 'number' ? 'border-purple-500 bg-purple-50 dark:bg-purple-900/20' : 'border-gray-300'}`}
              disabled={spinning}
            >
              Number (36x)
            </button>
          </div>
        </div>

        {/* Bet Value Selection */}
        <div>
          <label className="block mb-2 font-medium">Select Your Bet:</label>
          
          {betType === 'color' && (
            <div className="flex gap-2">
              <button
                type="button"
                onClick={() => setBetValue('red')}
                className={`flex-1 px-4 py-3 rounded-xl border-2 ${betValue === 'red' ? 'border-red-500 bg-red-500 text-white' : 'border-red-300 bg-red-50 dark:bg-red-900/20 text-red-600'}`}
                disabled={spinning}
              >
                RED
              </button>
              <button
                type="button"
                onClick={() => setBetValue('black')}
                className={`flex-1 px-4 py-3 rounded-xl border-2 ${betValue === 'black' ? 'border-gray-900 bg-gray-900 text-white' : 'border-gray-400 bg-gray-100 dark:bg-gray-800 text-gray-900 dark:text-white'}`}
                disabled={spinning}
              >
                BLACK
              </button>
            </div>
          )}

          {betType === 'range' && (
            <div className="grid grid-cols-2 md:grid-cols-4 gap-2">
              {RANGES.map(r => (
                <button
                  key={r}
                  type="button"
                  onClick={() => setBetValue(r)}
                  className={`px-4 py-3 rounded-xl border-2 ${betValue === r ? 'border-blue-500 bg-blue-500 text-white' : 'border-gray-300'}`}
                  disabled={spinning}
                >
                  {r}
                </button>
              ))}
            </div>
          )}

          {betType === 'number' && (
            <div>
              <input
                type="number"
                min="0"
                max="36"
                value={betValue}
                onChange={(e) => setBetValue(e.target.value)}
                className="w-full border rounded-xl px-4 py-2 bg-white dark:bg-gray-800"
                placeholder="Enter number (0-36)"
                disabled={spinning}
              />
              <div className="grid grid-cols-6 gap-1 mt-2">
                {[...Array(37)].map((_, i) => (
                  <button
                    key={i}
                    type="button"
                    onClick={() => setBetValue(String(i))}
                    className={`p-2 rounded border text-sm ${
                      betValue === String(i) 
                        ? 'border-purple-500 bg-purple-500 text-white' 
                        : getColor(i) === 'red' 
                          ? 'bg-red-100 dark:bg-red-900/20 border-red-300' 
                          : getColor(i) === 'black'
                            ? 'bg-gray-100 dark:bg-gray-800 border-gray-400'
                            : 'bg-green-100 dark:bg-green-900/20 border-green-300'
                    }`}
                    disabled={spinning}
                  >
                    {i}
                  </button>
                ))}
              </div>
            </div>
          )}

          {betType === 'zero' && (
            <div className="text-center p-4 rounded-xl bg-green-100 dark:bg-green-900/20 border-2 border-green-500">
              <div className="text-2xl font-bold text-green-600 dark:text-green-400">0 (GREEN)</div>
              <div className="text-sm opacity-70 mt-1">16x multiplier</div>
            </div>
          )}
        </div>

        {/* Spin Button */}
        <button
          type="submit"
          className="w-full px-6 py-3 bg-gradient-to-r from-yellow-400 to-yellow-600 text-gray-900 rounded-xl font-bold text-lg hover:from-yellow-500 hover:to-yellow-700 disabled:opacity-60 disabled:cursor-not-allowed transition-all"
          disabled={spinning}
        >
          {spinning ? 'Spinning...' : 'SPIN'}
        </button>
      </form>
    </div>
  )
}

export default RequireAuth(RoulettePage)



=== D:\Downloads\cado4fun\client\src\app\game\slots\page.js ===

// client/src/app/game/slots/page.js
'use client'

import RequireAuth from '@/components/RequireAuth'
import { useState } from 'react'
import useApi from '@/hooks/useApi'
import { useUser } from '@/context/UserContext'
import { toast } from 'react-hot-toast'

// 9 symbols v·ªõi emoji
const SYMBOLS = [
  { name: 'cherry', emoji: 'üçí', multiplier: 1.25 },
  { name: 'lemon', emoji: 'üçã', multiplier: 1.5 },
  { name: 'watermelon', emoji: 'üçâ', multiplier: 2 },
  { name: 'heart', emoji: '‚ù§Ô∏è', multiplier: 3 },
  { name: 'bell', emoji: 'üîî', multiplier: 4 },
  { name: 'diamond', emoji: 'üíé', multiplier: 5 },
  { name: 'seven', emoji: '7Ô∏è‚É£', multiplier: 8 },
  { name: 'horseshoe', emoji: 'üê¥', multiplier: 10 },
  { name: 'money', emoji: 'üí∞', multiplier: 20 }
]

function SlotsPage() {
  const { post } = useApi()
  const { updateBalance } = useUser()

  const [betAmount, setBetAmount] = useState(1)
  const [spinning, setSpinning] = useState(false)
  const [grid, setGrid] = useState([
    [SYMBOLS[0], SYMBOLS[1], SYMBOLS[2]],
    [SYMBOLS[3], SYMBOLS[4], SYMBOLS[5]],
    [SYMBOLS[6], SYMBOLS[7], SYMBOLS[8]]
  ])
  const [result, setResult] = useState(null)

  const handleSpin = async (e) => {
    e.preventDefault()

    if (betAmount <= 0) {
      toast.error('Bet must be > 0')
      return
    }

    setSpinning(true)
    setResult(null)

    try {
      const data = await post('/game/slots', { betAmount })

      // Animate spinning
      setTimeout(() => {
        // Parse emoji grid t·ª´ server response
        const serverGrid = data.grid || []
        const parsedGrid = serverGrid.map(row =>
          row.map(emoji => SYMBOLS.find(s => s.emoji === emoji) || SYMBOLS[0])
        )

        setGrid(parsedGrid)
        setResult(data)
        updateBalance(data.balance)
        setSpinning(false)

        if (data.win) {
          toast.success(`üéâ You win! ${data.totalMultiplier}x - Payout: ${data.payout}`)
        } else {
          toast.error('üò¢ No winning lines this time')
        }
      }, 2000) // Match animation duration
    } catch (err) {
      setSpinning(false)
      // Error toast handled by useApi
    }
  }

  return (
    <div className="p-8 max-w-2xl mx-auto">
      <h1 className="text-3xl font-bold mb-6">Slots</h1>

      {/* Slots Machine */}
      <div className="bg-gradient-to-b from-yellow-400 to-yellow-600 rounded-3xl p-6 shadow-2xl mb-6">
        {/* Display */}
        <div className="bg-gray-900 rounded-2xl p-4 mb-4">
          <div className="grid grid-cols-3 gap-2">
            {grid.map((row, r) =>
              row.map((symbol, c) => (
                <div
                  key={`${r}-${c}`}
                  className={`bg-white dark:bg-gray-800 rounded-xl h-24 flex items-center justify-center text-5xl ${
                    spinning ? 'animate-reel-spin' : ''
                  }`}
                  style={{
                    animationDelay: `${c * 0.1}s`
                  }}
                >
                  {spinning ? '‚ùì' : symbol.emoji}
                </div>
              ))
            )}
          </div>
        </div>

        {/* Result Display */}
        {result && !spinning && (
          <div className="bg-gray-900 rounded-xl p-4 text-white text-center mb-4">
            <div className="text-2xl font-bold">
              {result.win ? 'üéä WIN!' : 'Try Again'}
            </div>
            {result.win && (
              <>
                <div className="text-lg mt-2">Multiplier: {result.totalMultiplier}x</div>
                <div className="text-xl font-bold text-yellow-400">Payout: {result.payout}</div>
                {result.winningLines && result.winningLines.length > 0 && (
                  <div className="text-sm opacity-80 mt-2">
                    {result.winningLines.length} winning line{result.winningLines.length > 1 ? 's' : ''}
                  </div>
                )}
              </>
            )}
          </div>
        )}

        {/* Bet Controls */}
        <form onSubmit={handleSpin} className="space-y-3">
          <div className="bg-gray-900 rounded-xl p-3">
            <label className="block mb-2 font-medium text-white text-sm">Bet Amount:</label>
            <input
              type="number"
              min="1"
              value={betAmount}
              onChange={(e) => setBetAmount(+e.target.value)}
              className="w-full border rounded-xl px-4 py-2 bg-gray-800 text-white"
              disabled={spinning}
            />
          </div>

          <button
            type="submit"
            className="w-full px-6 py-4 bg-gradient-to-r from-red-500 to-pink-600 text-white rounded-2xl font-bold text-xl hover:from-red-600 hover:to-pink-700 disabled:opacity-60 disabled:cursor-not-allowed transition-all shadow-lg"
            disabled={spinning}
          >
            {spinning ? 'üé∞ SPINNING...' : 'üé∞ SPIN'}
          </button>
        </form>
      </div>

      {/* Paytable */}
      <div className="rounded-2xl border p-4">
        <h2 className="text-lg font-semibold mb-3">Paytable (3-of-a-kind)</h2>
        <div className="grid grid-cols-2 md:grid-cols-3 gap-2 text-sm">
          {SYMBOLS.map(s => (
            <div key={s.name} className="flex items-center justify-between p-2 rounded border">
              <span className="text-2xl">{s.emoji}</span>
              <span className="font-semibold">{s.multiplier}x</span>
            </div>
          ))}
        </div>
        <div className="mt-3 text-xs opacity-70">
          <div>Win lines: 3 rows + 3 columns + 2 diagonals = 8 total</div>
          <div>Multiple lines multiply your payout!</div>
        </div>
      </div>
    </div>
  )
}

export default RequireAuth(SlotsPage)



=== D:\Downloads\cado4fun\client\src\app\game\solo\page.js ===

// client/src/app/game/solo/page.js
"use client";

import RequireAuth from '@/components/RequireAuth'
import Link from "next/link";
import { GAMES } from "@/data/games";
import GameCard from "@/components/GameCard";

const HAS_THUMB = new Set(["coinflip", "dice", "blackjackdice"]);

function SoloGamesPage() {
  const soloGames = GAMES.filter((g) => g.supports.includes("solo"));
  // ∆Øu ti√™n card c√≥ thumbnail tr∆∞·ªõc cho g·ªçn m·∫Øt
  const sorted = [...soloGames].sort((a, b) => {
    const aHas = HAS_THUMB.has(a.id) ? 1 : 0;
    const bHas = HAS_THUMB.has(b.id) ? 1 : 0;
    if (bHas !== aHas) return bHas - aHas;
    return a.name.localeCompare(b.name);
  });

  return (
    <div className="p-4 max-w-6xl mx-auto">
      <div className="flex items-center justify-between mb-4">
        <h1 className="text-2xl font-semibold">Solo ‚Äî Select a game</h1>
        <Link href="/game" className="text-sm underline">
          Back
        </Link>
      </div>

      {/* L∆∞·ªõi ƒë·ªìng b·ªô v·ªõi Battle: nhi·ªÅu c·ªôt h∆°n ƒë·ªÉ tr√°nh kho·∫£ng tr·ªëng l·ªõn */}
      <div className="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 xl:grid-cols-5 gap-5 items-stretch">
        {sorted.map((g) => (
          <Link
            key={g.id}
            href={`/game/${g.id}`}
            className="block rounded-2xl focus:outline-none focus:ring-2 focus:ring-offset-2"
          >
            <GameCard mode={g.id} fluid />
          </Link>
        ))}
      </div>
    </div>
  );
}
export default RequireAuth(SoloGamesPage)



=== D:\Downloads\cado4fun\client\src\app\game\page.js ===

// client/src/app/game/page.js
'use client'

import { useMemo, useState } from 'react'
import Link from 'next/link'
import { GAMES } from '@/data/games'
import GameCard from '@/components/GameCard'
import GameFilterBar from '@/components/GameFilterBar'
import GameDetailModal from '@/components/GameDetailModal'

export default function GameHubPage() {
  const [filter, setFilter] = useState({
    type: 'all',         // 'all' | 'solo' | 'battle'
    sort: 'name_asc',    // 'name_asc'|'name_desc'|'stake_asc'|'stake_desc'
    q: '',
  })
  const [activeGame, setActiveGame] = useState(null)

  const filtered = useMemo(() => {
    let list = [...GAMES]

    // type filter
    if (filter.type !== 'all') {
      list = list.filter(g => g.supports?.includes(filter.type))
    }

    // search
    if (filter.q?.trim()) {
      const s = filter.q.trim().toLowerCase()
      list = list.filter(g =>
        g.name.toLowerCase().includes(s) || g.id.toLowerCase().includes(s)
      )
    }

    // sort
    switch (filter.sort) {
      case 'name_desc':
        list.sort((a,b) => b.name.localeCompare(a.name)); break
      case 'stake_asc':
        list.sort((a,b) => (a.minBet ?? 0) - (b.minBet ?? 0)); break
      case 'stake_desc':
        list.sort((a,b) => (b.minBet ?? 0) - (a.minBet ?? 0)); break
      default:
        list.sort((a,b) => a.name.localeCompare(b.name)); break
    }

    // Keep ‚Äúwith thumbnails first‚Äù feel (coinflip/dice/blackjackdice)
    const HAS_THUMB = new Set(['coinflip','dice','blackjackdice'])
    list.sort((a,b) => (HAS_THUMB.has(b.id) - HAS_THUMB.has(a.id)))

    return list
  }, [filter])

  return (
    <div className="p-4 max-w-6xl mx-auto">
      <div className="flex items-center justify-between mb-2">
        <h1 className="text-2xl font-semibold">Game</h1>
        <div className="flex gap-3">
          <Link href="/game/solo" className="px-4 py-2 rounded-2xl border shadow">Solo</Link>
          <Link href="/game/battle" className="px-4 py-2 rounded-2xl border shadow">Battle</Link>
        </div>
      </div>

      <p className="opacity-70 mb-4">
        Browse all games below. Use filters to find what you want ‚Äî click a card to preview.
      </p>

      <GameFilterBar onChange={setFilter} initial={filter} />

      <div className="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 xl:grid-cols-5 gap-5 items-stretch">
        {filtered.map((g) => (
          <button
            key={g.id}
            onClick={() => setActiveGame(g)}
            className="text-left rounded-2xl focus:outline-none focus:ring-2 focus:ring-offset-2"
            aria-label={`Preview ${g.name}`}
          >
            <GameCard mode={g.id} fluid />
          </button>
        ))}
      </div>

      <GameDetailModal
        open={!!activeGame}
        onOpenChange={(v) => !v && setActiveGame(null)}
        game={activeGame}
        // preferredType={filter.type === 'battle' ? 'battle' : 'solo'}
        // (Gi·ªØ m·∫∑c ƒë·ªãnh 'solo'; n·∫øu mu·ªën thay ƒë·ªïi ƒë∆∞·ªùng ƒëi khi ƒëang l·ªçc 'battle' th√¨ m·ªü d√≤ng tr√™n.)
      />
    </div>
  )
}




=== D:\Downloads\cado4fun\client\src\app\history\page.js ===

// client/src/app/history/page.js
'use client'

import RequireAuth from '@/components/RequireAuth'
import { useState, useEffect } from 'react'
import useApi from '../../hooks/useApi'
import { useUser } from '../../context/UserContext'
import Loading from '../../components/Loading'

function HistoryPage() {
  const { user } = useUser()
  const { get } = useApi()

  const [history, setHistory] = useState([])
  const [total, setTotal]     = useState(0)
  const [page, setPage]       = useState(1)
  const [loading, setLoading] = useState(true)
  const [error, setError]     = useState('')
  const limit = 10

  useEffect(() => {
    if (!user) {
      setLoading(false)
      return
    }
    setLoading(true)
    get(`/user/${user.id}/history?page=${page}&limit=${limit}`)
      .then(res => {
        setHistory(res.history || [])
        setTotal(res.total || 0)
        setError('')
      })
      .catch(err => {
        setError(err.response?.data?.error || err.message)
        setHistory([])
        setTotal(0)
      })
      .finally(() => setLoading(false))
  // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [user, page])

  if (!user) {
    return (
      <div className="p-8 max-w-md mx-auto text-center">
        <span className="text-gray-900 dark:text-gray-100">
          Vui l√≤ng ƒëƒÉng nh·∫≠p ƒë·ªÉ xem l·ªãch s·ª≠ ch∆°i.
        </span>
      </div>
    )
  }

  if (loading) {
    return <Loading text="ƒêang t·∫£i l·ªãch s·ª≠‚Ä¶" />
  }

  if (error) {
    return (
      <div className="p-8 max-w-md mx-auto text-center">
        <span className="text-red-500">{error}</span>
      </div>
    )
  }

  if (history.length === 0) {
    return (
      <div className="p-8 max-w-md mx-auto text-center">
        <span className="text-gray-900 dark:text-gray-100">
          Ch∆∞a c√≥ l·ªãch s·ª≠ ch∆°i n√†o.
        </span>
      </div>
    )
  }

  const totalPages = Math.ceil(total / limit)

  return (
    <div className="p-8 max-w-4xl mx-auto">
      <h1 className="text-2xl font-bold mb-4 text-gray-900 dark:text-gray-100">
        Game History
      </h1>
      <table className="min-w-full shadow rounded overflow-hidden">
        <thead>
          <tr className="bg-gray-100 dark:bg-gray-700">
            <th className="px-4 py-2 text-gray-900 dark:text-gray-100">Game Played</th>
            <th className="px-4 py-2 text-gray-900 dark:text-gray-100">Bet Amount</th>
            <th className="px-4 py-2 text-gray-900 dark:text-gray-100">Status</th>
            <th className="px-4 py-2 text-gray-900 dark:text-gray-100">Payout</th>
            <th className="px-4 py-2 text-gray-900 dark:text-gray-100">When</th>
          </tr>
        </thead>
        <tbody>
          {history.map(item => (
            <tr key={item._id} className="border-t border-gray-200 dark:border-gray-600">
              <td className="px-4 py-2 text-gray-900 dark:text-gray-100">{item.game}</td>
              <td className="px-4 py-2 text-gray-900 dark:text-gray-100">{item.betAmount}</td>
              <td className="px-4 py-2 text-gray-900 dark:text-gray-100">
                {item.outcome === 'win' ? 'Won'
                  : item.outcome === 'lose' ? 'Lost'
                  : 'Tie'}
              </td>
              <td className="px-4 py-2 text-gray-900 dark:text-gray-100">{item.payout}</td>
              <td className="px-4 py-2 text-gray-900 dark:text-gray-100">
                {new Date(item.createdAt).toLocaleString()}
              </td>
            </tr>
          ))}
        </tbody>
      </table>
      {/* Pagination */}
      <div className="mt-4 flex justify-center space-x-2">
        <button
          onClick={() => setPage(prev => Math.max(prev - 1, 1))}
          disabled={page === 1}
          className="px-4 py-2 rounded disabled:opacity-50
                     bg-gray-300 dark:bg-gray-600 hover:bg-gray-400 dark:hover:bg-gray-500
                     text-gray-900 dark:text-gray-100"
        >
          Prev
        </button>
        <span className="px-4 py-2 text-gray-900 dark:text-gray-100">
          Page {page} / {totalPages}
        </span>
        <button
          onClick={() => setPage(prev => Math.min(prev + 1, totalPages))}
          disabled={page >= totalPages}
          className="px-4 py-2 rounded disabled:opacity-50
                     bg-gray-300 dark:bg-gray-600 hover:bg-gray-400 dark:hover:bg-gray-500
                     text-gray-900 dark:text-gray-100"
        >
          Next
        </button>
      </div>
    </div>
  )
}
export default RequireAuth(HistoryPage)



=== D:\Downloads\cado4fun\client\src\app\login\page.js ===

// client/src/app/login/page.js
'use client'

import { useEffect, useRef, useState } from 'react'
import { useRouter, useSearchParams } from 'next/navigation'
import useApi from '../../hooks/useApi'
import { useUser } from '../../context/UserContext'
import Loading from '../../components/Loading'
import { toast } from 'react-hot-toast'

const REDIRECT_FLAG = 'auth:redirected'

export default function LoginPage() {
  const router = useRouter()
  const searchParams = useSearchParams()
  const nextPath = searchParams?.get('next') || '/'
  const { post } = useApi()
  const { fetchUser, user } = useUser()

  const [usernameOrEmail, setUsernameOrEmail] = useState('')
  const [password, setPassword] = useState('')

  const [authBusy, setAuthBusy] = useState(false)
  const [countingDown, setCountingDown] = useState(false)

  const redirectingRef = useRef(false)
  const intervalRef = useRef(null)

  useEffect(() => {
    try { sessionStorage.removeItem(REDIRECT_FLAG) } catch {}
  }, [])

  useEffect(() => {
    if (authBusy || countingDown) return

    let token = null
    try { token = localStorage.getItem('token') } catch {}
    if (!token) return

    if (user && !redirectingRef.current) {
      redirectingRef.current = true
      router.replace(nextPath)
      return
    }

    if (!user && !redirectingRef.current) {
      (async () => {
        try {
          await fetchUser()
          if (!authBusy && !countingDown && !redirectingRef.current && localStorage.getItem('token')) {
            redirectingRef.current = true
            router.replace(nextPath)
          }
        } catch {}
      })()
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [user, nextPath, authBusy, countingDown])

  useEffect(() => {
    return () => {
      if (intervalRef.current) clearInterval(intervalRef.current)
    }
  }, [])

  const handleSubmit = async (e) => {
    e.preventDefault()
    if (authBusy || countingDown) return

    setAuthBusy(true)
    try {
      const { token } = await post('/auth/login', { usernameOrEmail, password })
      if (typeof window !== 'undefined') {
        localStorage.setItem('token', token)
      }

      setAuthBusy(false)
      setCountingDown(true)

      let counter = 3
      const toastId = 'login-redirect'
      toast.success(`ƒêƒÉng nh·∫≠p th√†nh c√¥ng. Chuy·ªÉn h∆∞·ªõng sau ${counter}s‚Ä¶`, { id: toastId })

      intervalRef.current = setInterval(async () => {
        counter -= 1
        if (counter > 0) {
          toast.success(`ƒêƒÉng nh·∫≠p th√†nh c√¥ng. Chuy·ªÉn h∆∞·ªõng sau ${counter}s‚Ä¶`, { id: toastId })
        } else {
          clearInterval(intervalRef.current)
          intervalRef.current = null
          setCountingDown(false)

          // üîë N·∫†P USER TR∆Ø·ªöC KHI CHUY·ªÇN TRANG ‚Üí Navbar c·∫≠p nh·∫≠t ngay, kh√¥ng c·∫ßn refresh
          try { await fetchUser() } catch {}

          redirectingRef.current = true
          router.replace(nextPath || '/')
        }
      }, 1000)
    } catch (err) {
      toast.error(err?.message || 'Login failed')
      setAuthBusy(false)
      setCountingDown(false)
    }
  }

  if (authBusy) return <Loading text="ƒêang ƒëƒÉng nh·∫≠p‚Ä¶" />

  return (
    <div className="p-8 max-w-md mx-auto">
      <h1 className="text-2xl font-bold mb-4">Login</h1>

      <form onSubmit={handleSubmit} className="space-y-4">
        <div>
          <label className="block mb-1">Username or Email</label>
          <input
            type="text"
            value={usernameOrEmail}
            onChange={(e) => setUsernameOrEmail(e.target.value)}
            className="w-full border rounded px-2 py-1"
            required
            disabled={countingDown}
          />
        </div>

        <div>
          <label className="block mb-1">Password</label>
          <input
            type="password"
            value={password}
            onChange={(e) => setPassword(e.target.value)}
            className="w-full border rounded px-2 py-1"
            required
            disabled={countingDown}
          />
        </div>

        <button
          type="submit"
          className="w-full bg-blue-600 text-white px-4 py-2 rounded hover:bg-blue-700 disabled:opacity-60"
          disabled={authBusy || countingDown}
        >
          {authBusy ? 'Loading...' : (countingDown ? 'ƒêang ƒë·∫øm ng∆∞·ª£c‚Ä¶' : 'Login')}
        </button>
      </form>
    </div>
  )
}




=== D:\Downloads\cado4fun\client\src\app\notifications\page.js ===

// client/src/app/notifications/page.js
'use client'

import RequireAuth from '@/components/RequireAuth'
import { useState, useEffect } from 'react'
import { useUser } from '../../context/UserContext'
import useApi from '../../hooks/useApi'
import Loading from '../../components/Loading'

const TYPE_LABELS = {
  all: 'All',
  deposit: 'Deposits',
  withdraw: 'Withdrawals',
  transfer_sent: 'Transfer Sent',
  transfer_received: 'Receipt',
}

function NotificationsPage() {
  const { user } = useUser()
  const { get, patch } = useApi()
  const [notifications, setNotifications] = useState([])
  const [loading, setLoading] = useState(false)
  const [filter, setFilter]   = useState('all')
  const [page, setPage]       = useState(1)
  const pageSize = 10

  // ch·ªâ ph·ª• thu·ªôc v√†o user
  useEffect(() => {
    if (!user) return
    setLoading(true)
    get(`/notification?limit=100`)
      .then(res => setNotifications(res.notifications || []))
      .catch(() => setNotifications([]))
      .finally(() => setLoading(false))
  }, [user])

  const markAsRead = async id => {
    await patch(`/notification/${id}/read`)
    setNotifications(ns => ns.map(n => n._id === id ? { ...n, read: true } : n))
  }

  const filtered = notifications.filter(n =>
    filter === 'all' ? true : n.type === filter
  )
  const totalPages = Math.ceil(filtered.length / pageSize)
  const start = (page - 1) * pageSize
  const pageItems = filtered.slice(start, start + pageSize)

  if (!user) return <p className="p-8">Please log in to view notifications.</p>
  if (loading) return <Loading text="Loading notifications‚Ä¶" />

  return (
    <div className="p-8 max-w-2xl mx-auto space-y-6">
      <h1 className="text-3xl font-bold">Notifications</h1>

      {/* Filter */}
      <div className="flex space-x-4">
        {Object.entries(TYPE_LABELS).map(([key, label]) => (
          <button
            key={key}
            onClick={() => { setFilter(key); setPage(1) }}
            className={`px-3 py-1 rounded ${
              filter === key
                ? 'bg-blue-600 text-white'
                : 'bg-gray-200 dark:bg-gray-700 text-gray-800 dark:text-gray-200'
            }`}
          >
            {label}
          </button>
        ))}
      </div>

      {/* List */}
      <ul className="space-y-4">
        {pageItems.length === 0 ? (
          <li className="text-gray-500">No notifications</li>
        ) : (
          pageItems.map(n => (
            <li
              key={n._id}
              className={`p-4 border rounded ${
                n.read
                  ? 'bg-gray-100 dark:bg-gray-700'
                  : 'bg-white dark:bg-gray-800 font-semibold'
              }`}
              onClick={() => markAsRead(n._id)}
            >
              <div className="text-sm text-gray-500">{new Date(n.createdAt).toLocaleString()}</div>
              <div>{n.message}</div>
            </li>
          ))
        )}
      </ul>

      {/* Pagination */}
      {totalPages > 1 && (
        <div className="flex justify-center items-center space-x-4">
          <button
            onClick={() => setPage(p => Math.max(p - 1, 1))}
            disabled={page === 1}
            className="px-3 py-1 border rounded disabled:opacity-50"
          >
            Prev
          </button>
          <span>Page {page} of {totalPages}</span>
          <button
            onClick={() => setPage(p => Math.min(p + 1, totalPages))}
            disabled={page === totalPages}
            className="px-3 py-1 border rounded disabled:opacity-50"
          >
            Next
          </button>
        </div>
      )}
    </div>
  )
}
export default RequireAuth(NotificationsPage)



=== D:\Downloads\cado4fun\client\src\app\profile\page.js ===

// client/src/app/profile/page.js
'use client'

import RequireAuth from '@/components/RequireAuth'
import { useUser } from '../../context/UserContext'
import Loading from '../../components/Loading'
import Link from 'next/link'
import { toast } from 'react-hot-toast'

function ProfilePage() {
  const { user } = useUser()

  if (!user) return <Loading text="ƒêang t·∫£i Profile‚Ä¶" />

  const copyId = () => {
    navigator.clipboard.writeText(user.id)
      .then(() => toast.success('ID ƒë√£ copy th√†nh c√¥ng!'))
  }

  return (
    <div className="p-8 max-w-3xl mx-auto space-y-6">
      {/* Title */}
      <h1 className="text-2xl font-bold text-center">Profile</h1>

      {/* ID (readonly + copy) */}
      <div className="flex justify-center items-center space-x-2 mb-6">
        <input
          type="text"
          value={user.id}
          readOnly
          className="w-64 border rounded px-2 py-1 text-center bg-gray-100 text-gray-900 dark:text-gray-900"
        />
        <button
          onClick={copyId}
          className="px-3 py-1 bg-blue-500 text-white rounded hover:bg-blue-600"
        >
          Copy
        </button>
      </div>

      {/* Avatar + User Info */}
      <div className="flex items-start space-x-8">
        {/* Avatar + Settings Button */}
        <div className="flex flex-col items-center">
          <img
            src={user.avatar || '/default-avatar.png'}
            alt="Avatar"
            className="w-48 h-48 rounded-lg object-cover border-2 border-gray-300 shadow-md"
          />

          {/* Account Settings Button */}
          <Link
            href="/settings"
            className="mt-4 w-48 text-center bg-blue-600 text-white px-4 py-2 rounded hover:bg-blue-700"
          >
            Account Settings
          </Link>
        </div>

        {/* About Info */}
        <div className="self-center bg-gray-100 dark:bg-gray-800 p-4 rounded-lg shadow-md w-full max-w-md">
          <h2 className="text-lg font-semibold mb-3">About</h2>
          <p className="text-base"><strong>Username:</strong> {user.username}</p>
          <p className="text-base"><strong>Email:</strong> {user.email}</p>
          <p className="text-base">
            <strong>Date of Birth:</strong>{' '}
            {user.dateOfBirth
              ? new Date(user.dateOfBirth).toLocaleDateString()
              : 'NN/NN/NNNN'}
          </p>
        </div>
      </div>
    </div>
  )
}
export default RequireAuth(ProfilePage)



=== D:\Downloads\cado4fun\client\src\app\register\page.js ===

// client/src/app/register/page.js
'use client'

import { useState } from 'react'
import useApi from '../../hooks/useApi'
import Loading from '../../components/Loading' // Import Loading
import { toast } from 'react-hot-toast' // Th√™m toast

export default function RegisterPage() {
  const { post } = useApi()
  const [username, setUsername] = useState('')
  const [email, setEmail]       = useState('')
  const [password, setPassword] = useState('')
  const [loading, setLoading]   = useState(false) // Th√™m loading cho submit

  const handleSubmit = async (e) => {
    e.preventDefault()
    setLoading(true)
    try {
      await post('/auth/register', { username, email, password })
      toast.success('ƒê√£ ƒëƒÉng k√Ω th√†nh c√¥ng, h√£y quay v·ªÅ ƒëƒÉng nh·∫≠p ƒë·ªÉ ti·∫øp t·ª•c.')
    } catch (err) {
      toast.error(err.message)
    } finally {
      setLoading(false)
    }
  }

  if (loading) return <Loading text="ƒêang ƒëƒÉng k√Ω‚Ä¶" />

  return (
    <div className="p-8 max-w-md mx-auto">
      <h1 className="text-2xl font-bold mb-4">Register</h1>

      <form onSubmit={handleSubmit} className="space-y-4 mt-2">
        <div>
          <label className="block mb-1">Username</label>
          <input
            type="text"
            value={username}
            onChange={(e) => setUsername(e.target.value)}
            className="w-full border rounded px-2 py-1"
            required
          />
        </div>

        <div>
          <label className="block mb-1">Email</label>
          <input
            type="email"
            value={email}
            onChange={(e) => setEmail(e.target.value)}
            className="w-full border rounded px-2 py-1"
            required
          />
        </div>

        <div>
          <label className="block mb-1">Password</label>
          <input
            type="password"
            value={password}
            onChange={(e) => setPassword(e.target.value)}
            className="w-full border rounded px-2 py-1"
            required
          />
        </div>

        <button
          type="submit"
          className="w-full bg-blue-600 text-white px-4 py-2 rounded hover:bg-blue-700"
          disabled={loading}
        >
          {loading ? 'Loading...' : 'Register'}
        </button>
      </form>
    </div>
  )
}



=== D:\Downloads\cado4fun\client\src\app\rewards\page.js ===

// client/src/app/rewards/page.js
'use client'

import RequireAuth from '@/components/RequireAuth'
import { useState, useEffect } from 'react'
import useApi from '../../hooks/useApi'
import { useUser } from '../../context/UserContext'
import Loading from '../../components/Loading'
import { toast } from 'react-hot-toast'

const COOLDOWN_MS = {
  hourly: 3600 * 1000,
  daily:  24   * 3600 * 1000,
  weekly: 7    * 24   * 3600 * 1000
}
const AMOUNTS = { hourly:10, daily:100, weekly:1000 }

function formatTime(seconds) {
  if (seconds <= 0) return '0s';
  const days    = Math.floor(seconds / 86400)
  const hours   = Math.floor((seconds % 86400) / 3600)
  const minutes = Math.floor((seconds % 3600) / 60)
  const secs    = seconds % 60
  let result = ''
  if (days)    result += `${days}d`
  if (hours)   result += `${hours}h`
  if (minutes) result += `${minutes}m`
  if (secs || !result) result += `${secs}s`
  return result
}

function RewardsPage() {
  const { user, updateBalance } = useUser()
  const { get, post }          = useApi()   // ch·ªâ l·∫•y get v√† post

  const [status, setStatus]     = useState({ hourly:0, daily:0, weekly:0 })
  const [remaining, setRemaining] = useState({ hourly:0, daily:0, weekly:0 })
  const [loading, setLoading]   = useState(true)
  const [fetchError, setFetchError] = useState('')

  // 1Ô∏è‚É£ Fetch status ch·ªâ khi user thay ƒë·ªïi
  useEffect(() => {
    if (!user) {
      setLoading(false)
      return
    }
    setLoading(true)
    get('/rewards')
      .then(data => {
        setStatus({
          hourly:  data.hourly  ? new Date(data.hourly).getTime()  : 0,
          daily:   data.daily   ? new Date(data.daily).getTime()   : 0,
          weekly:  data.weekly  ? new Date(data.weekly).getTime()  : 0
        })
        setFetchError('')
      })
      .catch(err => {
        console.error('Fetch rewards error:', err)
        setFetchError(err.message || 'Failed to fetch')
        // kh√¥ng toast ·ªü ƒë√¢y ƒë·ªÉ tr√°nh spam toast li√™n t·ª•c
      })
      .finally(() => setLoading(false))
  // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [user])

  // 2Ô∏è‚É£ Countdown
  useEffect(() => {
    const update = () => {
      const now = Date.now()
      setRemaining({
        hourly: Math.max(0, Math.ceil((COOLDOWN_MS.hourly - (now - status.hourly)) / 1000)),
        daily:  Math.max(0, Math.ceil((COOLDOWN_MS.daily  - (now - status.daily))  / 1000)),
        weekly: Math.max(0, Math.ceil((COOLDOWN_MS.weekly - (now - status.weekly)) / 1000))
      })
    }
    update()
    const iv = setInterval(update, 1000)
    return () => clearInterval(iv)
  }, [status])

  // 3Ô∏è‚É£ Collect reward
  const handleCollect = (type) => {
    post(`/rewards/${type}`)
      .then(data => {
        const now = Date.now()
        setStatus(prev => ({ ...prev, [type]: now }))
        updateBalance(data.balance)
        toast.success(`+${AMOUNTS[type]} ƒë√£ ƒë∆∞·ª£c nh·∫≠n!`)
      })
      .catch(err => {
        const d = err.response?.data
        if (d?.nextAvailable) {
          const next = new Date(d.nextAvailable).getTime()
          const lastCollect = next - COOLDOWN_MS[type]
          setStatus(prev => ({ ...prev, [type]: lastCollect }))
        }
        toast.error(d?.error || err.message)
      })
  }

  if (!user) return <Loading text="Vui l√≤ng ƒëƒÉng nh·∫≠p ƒë·ªÉ xem Rewards." />
  if (loading) return <Loading text="ƒêang t·∫£i Rewards‚Ä¶" />

  return (
    <div className="p-8 max-w-4xl mx-auto">
      <h1 className="text-2xl font-bold mb-4">Rewards</h1>
      {fetchError && (
        <p className="mb-4 text-center text-red-600">
          {fetchError}. S·ª≠ d·ª•ng tr·∫°ng th√°i t·∫°m th·ªùi.
        </p>
      )}
      <div className="grid grid-cols-3 gap-4">
        {['hourly','daily','weekly'].map(type => {
          const ready = remaining[type] === 0 && !loading && !fetchError
          return (
            <div key={type} className="p-4 border rounded shadow text-center">
              <h2 className="capitalize text-xl">{type}</h2>
              <p className="mt-2">Amount: {AMOUNTS[type]}</p>
              <button
                onClick={() => handleCollect(type)}
                disabled={!ready}
                className={`mt-4 px-4 py-2 rounded ${
                  ready
                    ? 'bg-blue-500 text-white hover:bg-blue-600'
                    : 'bg-gray-300 text-gray-600 cursor-not-allowed'
                }`}
              >
                {ready ? 'Collect' : `Wait ${formatTime(remaining[type])}`}
              </button>
            </div>
          )
        })}
      </div>
    </div>
  )
}
export default RequireAuth(RewardsPage)



=== D:\Downloads\cado4fun\client\src\app\settings\page.js ===

// client/src/app/settings/page.js
'use client'

import RequireAuth from '@/components/RequireAuth'
import { useState, useEffect } from 'react'
import useApi from '../../hooks/useApi'
import { useUser } from '../../context/UserContext'
import Loading from '../../components/Loading'
import { toast } from 'react-hot-toast'

function SettingsPage() {
  const { user, fetchUser, logout } = useUser()
  const { patch, post } = useApi()

  const [username, setUsername] = useState('')
  const [email, setEmail] = useState('')
  const [avatar, setAvatar] = useState('')
  const [dateOfBirth, setDateOfBirth] = useState('')
  const [currentPassword, setCurrentPassword] = useState('')
  const [oldPassword, setOldPassword] = useState('')
  const [newPassword, setNewPassword] = useState('')
  const [confirmNewPassword, setConfirmNewPassword] = useState('')
  const [loading, setLoading] = useState(false)

  useEffect(() => {
    if (user) {
      setUsername(user.username)
      setEmail(user.email)
      setAvatar(user.avatar || '')
      setDateOfBirth(user.dateOfBirth ? user.dateOfBirth.split('T')[0] : '')
    }
  }, [user])

  const handleProfileSubmit = async (e) => {
    e.preventDefault()
    setLoading(true)
    if (!currentPassword) {
      toast.error('Vui l√≤ng nh·∫≠p m·∫≠t kh·∫©u hi·ªán t·∫°i')
      setLoading(false)
      return
    }
    try {
      await patch('/user/me', { username, email, avatar, dateOfBirth, currentPassword })
      await fetchUser()
      toast.success('C·∫≠p nh·∫≠t th√¥ng tin c√° nh√¢n th√†nh c√¥ng!')
      setCurrentPassword('')
    } catch (err) {
      toast.error(err.message)
    } finally {
      setLoading(false)
    }
  }

  const handlePasswordSubmit = async (e) => {
    e.preventDefault()
    setLoading(true)
    if (newPassword !== confirmNewPassword) {
      toast.error('M·∫≠t kh·∫©u m·ªõi kh√¥ng kh·ªõp')
      setLoading(false)
      return
    }
    try {
      await post('/user/me/password', { oldPassword, newPassword })
      toast.success('ƒê·ªïi m·∫≠t kh·∫©u th√†nh c√¥ng!')
      setOldPassword('')
      setNewPassword('')
      setConfirmNewPassword('')
    } catch (err) {
      toast.error(err.message)
    } finally {
      setLoading(false)
    }
  }

  if (!user) return <Loading text="ƒêang t·∫£i Settings‚Ä¶" />
  if (loading) return <Loading text="ƒêang x·ª≠ l√Ω‚Ä¶" />

  return (
    <div className="p-8 max-w-lg mx-auto space-y-8">
      <h1 className="text-2xl font-bold">Settings</h1>

      {/* Personal Info */}
      <h2 className="text-xl font-bold">Personal Info</h2>
      <form onSubmit={handleProfileSubmit} className="space-y-4">
        <div>
          <label className="block mb-1 font-medium">Username</label>
          <input
            type="text"
            value={username}
            onChange={e => setUsername(e.target.value)}
            className="w-full border rounded px-2 py-1"
            required
          />
        </div>
        <div>
          <label className="block mb-1 font-medium">Email</label>
          <input
            type="email"
            value={email}
            onChange={e => setEmail(e.target.value)}
            className="w-full border rounded px-2 py-1"
            required
          />
        </div>
        <div>
          <label className="block mb-1 font-medium">Avatar URL</label>
          <input
            type="text"
            value={avatar}
            onChange={e => setAvatar(e.target.value)}
            className="w-full border rounded px-2 py-1"
          />
        </div>
        <div>
          <label className="block mb-1 font-medium">Date of Birth</label>
          <input
            type="date"
            value={dateOfBirth}
            onChange={e => setDateOfBirth(e.target.value)}
            className="w-full border rounded px-2 py-1"
          />
        </div>
        <div>
          <label className="block mb-1 font-medium">Current Password</label>
          <input
            type="password"
            value={currentPassword}
            onChange={e => setCurrentPassword(e.target.value)}
            className="w-full border rounded px-2 py-1"
            required
          />
        </div>
        <button
          type="submit"
          className="bg-blue-600 text-white px-4 py-2 rounded hover:bg-blue-700"
        >
          Save Changes
        </button>
      </form>

      {/* Change Password */}
      <h2 className="text-xl font-bold">Change Password</h2>
      <form onSubmit={handlePasswordSubmit} className="space-y-4">
        <div>
          <label className="block mb-1 font-medium">Old Password</label>
          <input
            type="password"
            value={oldPassword}
            onChange={e => setOldPassword(e.target.value)}
            className="w-full border rounded px-2 py-1"
            required
          />
        </div>
        <div>
          <label className="block mb-1 font-medium">New Password</label>
          <input
            type="password"
            value={newPassword}
            onChange={e => setNewPassword(e.target.value)}
            className="w-full border rounded px-2 py-1"
            required
          />
        </div>
        <div>
          <label className="block mb-1 font-medium">Confirm New Password</label>
          <input
            type="password"
            value={confirmNewPassword}
            onChange={e => setConfirmNewPassword(e.target.value)}
            className="w-full border rounded px-2 py-1"
            required
          />
        </div>
        <button
          type="submit"
          className="bg-blue-600 text-white px-4 py-2 rounded hover:bg-blue-700"
        >
          Save Password
        </button>
      </form>

      <button
        onClick={logout}
        className="mt-8 inline-block bg-red-500 text-white px-4 py-2 rounded hover:bg-red-600"
      >
        Logout
      </button>
    </div>
  )
}
export default RequireAuth(SettingsPage)



=== D:\Downloads\cado4fun\client\src\app\wallet\page.js ===

// client/src/app/wallet/page.js
'use client'

import RequireAuth from '@/components/RequireAuth'
import { useState, useEffect } from 'react'
import useApi from '../../hooks/useApi'
import { useUser } from '../../context/UserContext'
import Loading from '../../components/Loading'
import { toast } from 'react-hot-toast'

function RewardsPage() {
  const { user, balance, bank, updateBalance, updateBank } = useUser()
  const { post, get } = useApi()

  const [activeTab, setActiveTab]           = useState('account')
  const [toId, setToId]                     = useState('')
  const [transferAmt, setTransferAmt]       = useState(0)
  const [depositAmt, setDepositAmt]         = useState(0)
  const [withdrawAmt, setWithdrawAmt]       = useState(0)
  const [loading, setLoading]               = useState(false)
  const [transactions, setTransactions]     = useState([])
  const [historyLoading, setHistoryLoading] = useState(false)
  const [page, setPage]                     = useState(1)
  const pageSize                             = 5

  // fetch & enrich transactions when user clicks Transaction tab
  useEffect(() => {
    if (activeTab !== 'transaction') return

    setHistoryLoading(true)
    get(`/wallet/${user.id}/transactions`)
      .then(async res => {
        let txs = res.transactions
        txs = await Promise.all(txs.map(async tx => {
          if (tx.type === 'transfer') {
            if (tx.toUserId) {
              const to = await get(`/user/${tx.toUserId}`)
              return { ...tx, toUsername: to.username }
            }
            if (tx.fromUserId) {
              const from = await get(`/user/${tx.fromUserId}`)
              return { ...tx, fromUsername: from.username }
            }
          }
          return tx
        }))
        setTransactions(txs)
      })
      .catch(err => toast.error(err.message))
      .finally(() => setHistoryLoading(false))
  }, [activeTab])

  // reset to first page whenever transactions update
  useEffect(() => {
    setPage(1)
  }, [transactions])

  if (!user)   return <Loading text="Vui l√≤ng ƒëƒÉng nh·∫≠p ƒë·ªÉ xem Wallet." />
  if (loading) return <Loading text="ƒêang t·∫£i Wallet‚Ä¶" />

  const handleTransfer = async e => {
    e.preventDefault()
    setLoading(true)
    if (!toId.trim() || transferAmt <= 0) {
      toast.error('ID v√† s·ªë ti·ªÅn ph·∫£i h·ª£p l·ªá (>0).')
      setLoading(false)
      return
    }
    try {
      const target = await get(`/user/${toId}`)
      if (!window.confirm(`Chuy·ªÉn ${transferAmt} cho ${target.username}?`)) {
        setLoading(false)
        return
      }
      const res = await post(`/wallet/${user.id}/transfer`, {
        toUserId: toId, amount: transferAmt
      })
      updateBalance(res.fromBalance)
      toast.success(`You transferred ${transferAmt} to ${target.username}`)
      setToId(''); setTransferAmt(0)
    } catch (err) {
      toast.error(err.message)
    } finally {
      setLoading(false)
    }
  }

  const handleDeposit = async e => {
    e.preventDefault()
    setLoading(true)
    if (depositAmt <= 0) {
      toast.error('S·ªë ti·ªÅn ph·∫£i > 0.')
      setLoading(false)
      return
    }
    try {
      const res = await post(`/wallet/${user.id}/bank/deposit`, { amount: depositAmt })
      updateBalance(res.balance); updateBank(res.bank)
      toast.success(`You deposited ${depositAmt} from Account to Bank`)
      setDepositAmt(0)
    } catch (err) {
      toast.error(err.message)
    } finally {
      setLoading(false)
    }
  }

  const handleWithdraw = async e => {
    e.preventDefault()
    setLoading(true)
    if (withdrawAmt <= 0) {
      toast.error('S·ªë ti·ªÅn ph·∫£i > 0.')
      setLoading(false)
      return
    }
    try {
      const res = await post(`/wallet/${user.id}/bank/withdraw`, { amount: withdrawAmt })
      updateBalance(res.balance); updateBank(res.bank)
      toast.success(`You withdrew ${withdrawAmt} from Bank to Account`)
      setWithdrawAmt(0)
    } catch (err) {
      toast.error(err.message)
    } finally {
      setLoading(false)
    }
  }

  // determine transactions to display on current page
  const startIdx = (page - 1) * pageSize
  const pagedTxs = transactions.slice(startIdx, startIdx + pageSize)
  const totalPages = Math.ceil(transactions.length / pageSize)

  return (
    <div className="p-8 max-w-md mx-auto">
      <h1 className="text-3xl font-bold mb-2">Wallet</h1>
      <p className="text-center text-base mb-6">Your Balance: {balance}</p>

      {/* Tab Navigation */}
      <div className="grid grid-cols-3 border-b border-gray-600 mb-6">
        <div className="flex justify-start">
          <button
            onClick={() => setActiveTab('account')}
            className={`px-4 py-2 -mb-px ${activeTab==='account'?'border-b-2 border-blue-500 font-semibold':''}`}
          >
            Account
          </button>
        </div>
        <div className="flex justify-center">
          <button
            onClick={() => setActiveTab('transaction')}
            className={`px-4 py-2 -mb-px ${activeTab==='transaction'?'border-b-2 border-blue-500 font-semibold':''}`}
          >
            Transaction
          </button>
        </div>
        <div className="flex justify-end">
          <button
            onClick={() => setActiveTab('bank')}
            className={`px-4 py-2 -mb-px ${activeTab==='bank'?'border-b-2 border-blue-500 font-semibold':''}`}
          >
            Bank
          </button>
        </div>
      </div>

      {/* Account Tab */}
      {activeTab==='account' && (
        <section className="space-y-4">
          <h2 className="text-xl font-semibold">Transfer</h2>
          <form onSubmit={handleTransfer} className="flex flex-col space-y-2">
            <input
              type="text"
              placeholder="User ID to transfer"
              value={toId}
              onChange={e=>setToId(e.target.value)}
              className="border rounded px-2 py-1"
              required
            />
            <input
              type="number"
              min="1"
              placeholder="Amount"
              value={transferAmt}
              onChange={e=>setTransferAmt(+e.target.value)}
              className="border rounded px-2 py-1"
              required
            />
            <button
              type="submit"
              className="bg-blue-600 text-white px-4 py-2 rounded hover:bg-blue-700"
              disabled={loading}
            >
              {loading?'Loading...':'Confirm'}
            </button>
          </form>
        </section>
      )}

      {/* Bank Tab */}
      {activeTab==='bank' && (
        <section className="space-y-6">
          <h2 className="text-xl font-semibold">Bank Balance: {bank}</h2>
          <div className="space-y-4">
            <div>
              <h3 className="text-lg font-medium">Deposit</h3>
              <form onSubmit={handleDeposit} className="flex items-center space-x-2 mt-1">
                <input
                  type="number"
                  min="1"
                  placeholder="Amount to deposit"
                  value={depositAmt}
                  onChange={e=>setDepositAmt(+e.target.value)}
                  className="border rounded px-2 py-1 flex-1"
                  required
                />
                <button
                  type="submit"
                  className="bg-green-600 text-white px-4 py-2 rounded hover:bg-green-700"
                  disabled={loading}
                >
                  {loading?'Loading...':'Confirm'}
                </button>
              </form>
            </div>
            <div>
              <h3 className="text-lg font-medium">Withdraw</h3>
              <form onSubmit={handleWithdraw} className="flex items-center space-x-2 mt-1">
                <input
                  type="number"
                  min="1"
                  placeholder="Amount to withdraw"
                  value={withdrawAmt}
                  onChange={e=>setWithdrawAmt(+e.target.value)}
                  className="border rounded px-2 py-1 flex-1"
                  required
                />
                <button
                  type="submit"
                  className="bg-yellow-600 text-white px-4 py-2 rounded hover:bg-yellow-700"
                  disabled={loading}
                >
                  {loading?'Loading...':'Confirm'}
                </button>
              </form>
            </div>
          </div>
        </section>
      )}

      {/* Transaction Tab */}
      {activeTab==='transaction' && (
        <section className="space-y-4">
          <h2 className="text-xl font-semibold">Transaction</h2>
          {historyLoading ? (
            <Loading text="Loading transactions‚Ä¶" />
          ) : (
            <>
              <ul className="space-y-2">
                {pagedTxs.length > 0 ? pagedTxs.map(tx => {
                  let msg = ''
                  if (tx.type === 'deposit') {
                    msg = `You deposited ${tx.amount} from Account to Bank`
                  } else if (tx.type === 'withdraw') {
                    msg = `You withdrew ${tx.amount} from Bank to Account`
                  } else if (tx.type === 'transfer') {
                    if (tx.toUsername) msg = `You transferred ${tx.amount} to ${tx.toUsername}`
                    else if (tx.fromUsername) msg = `You received ${tx.amount} from ${tx.fromUsername}`
                  }
                  return (
                    <li key={tx._id || tx.id} className="flex flex-col">
                      <span className="text-sm text-gray-500">
                        {new Date(tx.createdAt).toLocaleString()}
                      </span>
                      <span>{msg}</span>
                    </li>
                  )
                }) : (
                  <p className="text-center text-gray-500">No transactions found.</p>
                )}
              </ul>
              {/* Pagination controls */}
              <div className="flex justify-center items-center space-x-4 mt-4">
                <button
                  onClick={() => setPage(p => Math.max(p-1, 1))}
                  disabled={page === 1}
                  className="px-3 py-1 border rounded hover:bg-gray-100 disabled:opacity-50"
                >
                  Prev
                </button>
                <span>Page {page} / {totalPages}</span>
                <button
                  onClick={() => setPage(p => Math.min(p+1, totalPages))}
                  disabled={page === totalPages}
                  className="px-3 py-1 border rounded hover:bg-gray-100 disabled:opacity-50"
                >
                  Next
                </button>
              </div>
            </>
          )}
        </section>
      )}
    </div>
  )
}
export default RequireAuth(RewardsPage)




=== D:\Downloads\cado4fun\client\src\app\layout.js ===

// app/layout.js
import '../styles/globals.css'
import Layout from '../components/Layout'
import ClientProviders from './providers'
import { Toaster } from 'react-hot-toast'

export const metadata = {
  title: '4funBET - Nh√† c√°i ƒë·∫øn t·ª´ n·ª• c∆∞·ªùi',
  description: 'Fun card games with friends',
}

export default function RootLayout({ children }) {
  return (
    <html lang="en" suppressHydrationWarning>
      <body className="bg-white dark:bg-gray-900 text-gray-100 transition-colors duration-300">
        <ClientProviders>
          <Layout>{children}</Layout>
          <Toaster
            position="top-right"
            toastOptions={{
              // ƒë√∫ng 1.5 gi√¢y nh∆∞ y√™u c·∫ßu
              duration: 1500,
              // d√πng animation m·∫∑c ƒë·ªãnh c·ªßa react-hot-toast
            }}
          />
        </ClientProviders>
      </body>
    </html>
  )
}




=== D:\Downloads\cado4fun\client\src\app\page.js ===

// client/src/app/page.js
export default function HomePage() {
  return (
    <div className="flex items-center justify-center h-[80vh]">
      <h1 className="text-5xl font-bold">Dogshit</h1>
    </div>
  )
}




=== D:\Downloads\cado4fun\client\src\app\providers.jsx ===

// client/src/app/providers.jsx
'use client'

import { ThemeProvider } from 'next-themes'
import { UserProvider } from '../context/UserContext'

export default function ClientProviders({ children }) {
  return (
    <ThemeProvider attribute="class" defaultTheme="light" enableSystem={true}>
      <UserProvider>{children}</UserProvider>
    </ThemeProvider>
  )
}




=== D:\Downloads\cado4fun\client\src\components\battle\coinflip\CoinflipBattlePanel.jsx ===

// client/src/components/battle/coinflip/CoinflipBattlePanel.jsx
'use client';
import React from 'react';
import ServerCountdown from '../../ServerCountdown';

export default function CoinflipBattlePanel({ room, me }) {
  const md = room?.metadata || {};
  // Schema m·ªõi t·ª´ BE:
  // - md.serverSeedHash
  // - md.serverSeedReveal (khi finished)
  // - md.pendingCoin = { revealAt, winnerUserId, result }
  // - md.flipResult (sau khi finish)
  const seedHash   = md.serverSeedHash || null;
  const seedReveal = md.serverSeedReveal || null;

  const pending  = md.pendingCoin || null;
  const revealAt = pending?.revealAt || null;

  // Winner ∆∞u ti√™n room.winnerUserId; n·∫øu ch∆∞a c√≥ th√¨ d√πng c√°i n·∫±m trong pending
  const winnerId =
    (room?.winnerUserId ? String(room.winnerUserId) : (pending?.winnerUserId || null)) || null;

  // Result ∆∞u ti√™n t·ª´ md.flipResult; n·∫øu BE ch∆∞a set, c·ªë g·∫Øng suy ra d·ª±a v√†o side c·ªßa winner
  const resultFromMeta = room?.status === 'finished' ? (md.flipResult || null) : null;

  const myId = me?.id ? String(me.id) : null;
  const isMe = (uid) => uid && myId && String(uid) === myId;

  const nameOf = (uid) => {
    const p = room?.players?.find((x) => String(x.userId) === String(uid));
    return p?.user?.username || String(uid || '').slice(-6);
  };

  // Suy ra m·∫∑t th·∫Øng t·ª´ winner n·∫øu thi·∫øu flipResult (d·ª±a tr√™n side ng∆∞·ªùi th·∫Øng)
  const deriveFaceFromWinner = () => {
    if (!winnerId) return null;
    const p = room?.players?.find((x) => String(x.userId) === String(winnerId));
    return p?.side || null;
  };

  const resultUpper =
    (resultFromMeta || deriveFaceFromWinner() || '-').toString().toUpperCase();

  const mySide = (() => {
    // coinflip hi·ªán t·∫°i: side l∆∞u ngay tr√™n player
    const p = room?.players?.find((x) => String(x.userId) === myId);
    return p?.side || null;
  })();

  // Payout (pot) cho coinflip = betAmount * s·ªë ng∆∞·ªùi ch∆°i (th·ª±c t·∫ø l√† 2)
  const pot = Number(room?.betAmount || 0) * (room?.players?.length || 0);

  return (
    <div className="mt-4 p-4 rounded-xl border">
      <div className="flex items-center justify-between mb-2">
        <div className="text-sm">
          Game: <b>Coinflip</b>
        </div>
        {seedHash ? (
          <div className="text-xs opacity-70 truncate">Seed Hash: {seedHash}</div>
        ) : null}
      </div>

      <div className="text-sm mb-2">
        {mySide ? (
          <>
            Your side: <b className="uppercase">{mySide}</b>
          </>
        ) : (
          'Sides will be assigned on join'
        )}
      </div>

      {room?.status === 'waiting' && (
        <div className="text-sm opacity-80">
          Waiting for everyone to Ready. Owner can Start when ready.
        </div>
      )}

      {room?.status === 'active' && pending && (
        <div className="text-sm opacity-80 flex items-center gap-2">
          Flipping... reveal in{' '}
          <ServerCountdown
            serverNow={room.serverNow}
            target={revealAt}
            className="font-semibold"
          />
        </div>
      )}

      {room?.status === 'finished' && (
        <div className="mt-2 space-y-2">
          <div className="text-lg">
            Result: <b className="uppercase">{resultUpper}</b>
          </div>
          {winnerId && (
            <div className="text-sm">
              Winner: <b>{isMe(winnerId) ? 'You' : nameOf(winnerId)}</b>
            </div>
          )}
          <div className="text-sm">Payout: {pot}</div>

          {seedReveal && (
            <div className="text-xs opacity-70 break-all">Seed Reveal: {seedReveal}</div>
          )}
        </div>
      )}
    </div>
  );
}




=== D:\Downloads\cado4fun\client\src\components\ConfirmDialog.jsx ===

// client/src/components/ConfirmDialog.jsx
'use client';
import { useEffect, useRef, useCallback, useId } from 'react';
import { createPortal } from 'react-dom';

export default function ConfirmDialog({
  open,
  title = 'Confirm',
  description,
  confirmText = 'Confirm',
  cancelText = 'Cancel',
  onConfirm,
  onCancel,
  onOpenChange,        // (nextOpen:boolean) => void
  loading = false,
  variant,             // 'danger' | undefined
}) {
  const backdropRef = useRef(null);
  const panelRef = useRef(null);
  const lastActiveRef = useRef(null);

  // IDs cho a11y
  const titleId = useId();
  const descId  = useId();

  // Ghi nh·ªõ ph·∫ßn t·ª≠ hi·ªán t·∫°i ƒë·ªÉ tr·∫£ focus khi ƒë√≥ng
  useEffect(() => {
    if (open) {
      lastActiveRef.current = document.activeElement instanceof HTMLElement
        ? document.activeElement
        : null;
    } else {
      // tr·∫£ focus v·ªÅ opener khi ƒë√≥ng
      lastActiveRef.current?.focus?.();
      lastActiveRef.current = null;
    }
  }, [open]);

  // Kho√° scroll n·ªÅn khi m·ªü
  useEffect(() => {
    if (!open) return;
    const prev = document.body.style.overflow;
    document.body.style.overflow = 'hidden';
    return () => { document.body.style.overflow = prev; };
  }, [open]);

  // Focus ph·∫ßn t·ª≠ ƒë·∫ßu ti√™n khi m·ªü
  useEffect(() => {
    if (!open) return;
    const t = setTimeout(() => {
      // ∆∞u ti√™n n√∫t confirm, sau ƒë√≥ t·ªõi n√∫t cancel
      const focusables = backdropRef.current?.querySelectorAll(
        'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'
      );
      if (focusables && focusables.length > 0) {
        (focusables[0] instanceof HTMLElement) && focusables[0].focus();
      } else {
        panelRef.current?.focus?.();
      }
    }, 0);
    return () => clearTimeout(t);
  }, [open]);

  // Trap focus + Esc
  const onKeyDown = useCallback((e) => {
    if (!open) return;

    if (e.key === 'Escape') {
      if (loading) return; // khi loading kh√¥ng cho ƒë√≥ng
      onCancel?.();
      onOpenChange?.(false);
      return;
    }

    if (e.key === 'Tab') {
      const list = backdropRef.current?.querySelectorAll(
        'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'
      );
      const nodes = list ? Array.from(list) : [];
      if (!nodes.length) return;

      const first = nodes[0];
      const last = nodes[nodes.length - 1];

      // N·∫øu ƒëang ·ªü ngo√†i panel (hi·∫øm), ƒë·∫©y v√†o panel
      if (!backdropRef.current?.contains(document.activeElement)) {
        e.preventDefault();
        (first instanceof HTMLElement) && first.focus();
        return;
      }

      if (e.shiftKey) {
        if (document.activeElement === first) {
          e.preventDefault();
          (last instanceof HTMLElement) && last.focus();
        }
      } else {
        if (document.activeElement === last) {
          e.preventDefault();
          (first instanceof HTMLElement) && first.focus();
        }
      }
    }
  }, [open, loading, onCancel, onOpenChange]);

  if (!open) return null;

  return createPortal(
    <div
      ref={backdropRef}
      className="fixed inset-0 z-50 bg-black/50 flex items-center justify-center p-4"
      role="dialog"
      aria-modal="true"
      aria-labelledby={title ? titleId : undefined}
      aria-describedby={description ? descId : undefined}
      aria-busy={loading ? 'true' : 'false'}
      onKeyDown={onKeyDown}
      onMouseDown={(e) => {
        if (e.target === e.currentTarget) {
          if (loading) return; // ch·∫∑n ƒë√≥ng khi loading
          onCancel?.();
          onOpenChange?.(false);
        }
      }}
    >
      <div
        ref={panelRef}
        className="bg-white dark:bg-gray-900 dark:text-white w-full max-w-sm rounded-2xl p-4 shadow-lg outline-none"
        tabIndex={-1}
        onMouseDown={(e) => e.stopPropagation()}
      >
        <div className="text-lg font-semibold mb-2" id={titleId}>{title}</div>
        {description && (
          <div className="text-sm opacity-80 mb-4" id={descId}>
            {description}
          </div>
        )}

        <div className="flex justify-end gap-2">
          <button
            type="button"
            className="px-3 py-2 rounded-xl border"
            onClick={() => { onCancel?.(); onOpenChange?.(false); }}
            disabled={loading}
          >
            {cancelText}
          </button>
          <button
            type="button"
            className={`px-3 py-2 rounded-xl border shadow disabled:opacity-50 ${
              variant === 'danger' ? 'border-red-500 text-red-600' : ''
            }`}
            onClick={onConfirm}
            disabled={loading}
          >
            {loading ? '...' : confirmText}
          </button>
        </div>
      </div>
    </div>,
    document.body
  );
}




=== D:\Downloads\cado4fun\client\src\components\DisabledHint.jsx ===

// client/src/components/DisabledHint.jsx
'use client';

import React from 'react';

/**
 * Wrap 1 n√∫t b·ªã disabled ƒë·ªÉ hi·ªÉn th·ªã l√Ω do (hover/focus).
 * D√πng thu·ªôc t√≠nh `title` ƒë·ªÉ nh·∫π nh√†ng, kh√¥ng c·∫ßn lib tooltip.
 *
 * Props:
 * - disabled: boolean
 * - reason?: string
 * - children: React element (v√≠ d·ª•: <button disabled>...</button>)
 */
export default function DisabledHint({ disabled, reason, children }) {
  if (!disabled) return children;

  // Gi·ªØ nguy√™n giao di·ªán child, ch·ªâ b·ªçc th√™m title ƒë·ªÉ hi·ªán tooltip
  return (
    <span title={reason || 'Unavailable'} style={{ display: 'inline-block' }}>
      {children}
    </span>
  );
}




=== D:\Downloads\cado4fun\client\src\components\GameCard.jsx ===

// client/src/components/GameCard.jsx
'use client'

import { useTheme } from 'next-themes'
import { useEffect, useState, useMemo } from 'react'
import { GAMES } from '@/data/games'

/**
 * Props:
 * - mode: string (required) - game id (e.g. "coinflip")
 * - fluid?: boolean ‚Äî if true the card flexes to parent width
 */
export default function GameCard({ mode, fluid = false }) {
  const { theme } = useTheme()
  const [mounted, setMounted] = useState(false)
  const [imgLoaded, setImgLoaded] = useState(false)
  const [imgError, setImgError] = useState(false)

  useEffect(() => setMounted(true), [])

  const game = useMemo(() => GAMES.find(g => g.id === mode), [mode])
  const title = game?.name ?? mode
  const isComingSoon = game?.status === 'coming_soon'

  // Skeleton during SSR/CSR mismatch
  if (!mounted) {
    return (
      <div
        className={`${fluid ? 'w-full' : 'w-56'} rounded-2xl border-2 bg-white dark:bg-gray-900 animate-pulse`}
        style={{ height: 256 }}
        aria-label="Loading game card"
      />
    )
  }

  const isDark = theme === 'dark'
  const borderClr = isDark ? 'border-gray-700' : 'border-gray-900'
  const textClr = isDark ? 'text-white' : 'text-black'
  const sectionBorder = isDark ? 'border-gray-700' : 'border-gray-300'
  const cardBg = isDark ? 'bg-gray-900' : 'bg-white'
  const src = `/cards/${mode}.png`

  const cardW = fluid ? 'w-full' : 'w-56'
  const imageH = 'h-40'
  const labelH = 'h-10 md:h-16'
  const labelText = 'line-clamp-1 leading-none'

  return (
    <div
      className={[
        cardW,
        'rounded-2xl shadow-md hover:shadow-xl transition-all duration-300',
        'overflow-hidden border-2',
        cardBg,
        borderClr,
        isComingSoon ? 'opacity-90' : '',
      ].join(' ')}
      aria-label={`${title} card`}
    >
      <div className={`${imageH} relative`}>
        {/* Loading overlay */}
        {!imgLoaded && !imgError && (
          <div className="absolute inset-0 animate-pulse bg-black/10 dark:bg-white/10" />
        )}

        {imgError ? (
          <div className="absolute inset-0 flex items-center justify-center bg-gray-200 dark:bg-gray-800 text-sm">
            No image
          </div>
        ) : (
          <img
            src={src}
            alt={`${title} preview`}
            loading="lazy"
            onLoad={() => setImgLoaded(true)}
            onError={() => setImgError(true)}
            className="w-full h-full object-cover rounded-t-2xl"
            draggable={false}
          />
        )}

        {/* Coming Soon badge */}
        {isComingSoon && (
          <div className="absolute top-2 right-2">
            <span className="rounded-full px-2 py-1 text-[11px] font-semibold bg-yellow-400 text-black shadow">
              Coming Soon
            </span>
          </div>
        )}
      </div>

      <div className={`border-t-2 ${sectionBorder}`}>
        <div
          className={[
            labelH,
            'flex items-center justify-center font-semibold capitalize transition-colors duration-300',
            textClr,
            'text-lg px-3 text-center',
            labelText,
          ].join(' ')}
        >
          {title}
        </div>
      </div>
    </div>
  )
}



=== D:\Downloads\cado4fun\client\src\components\GameDetailModal.jsx ===

// client/src/components/GameDetailModal.jsx
'use client'

import { useEffect } from 'react'
import Link from 'next/link'

/**
 * Props:
 * - open: boolean
 * - onOpenChange: (boolean) => void
 * - game: { id, name, description, minBet, supports, status }
 * - preferredType?: 'solo'|'battle'  // ƒë·ªÉ quy·∫øt ƒë·ªãnh Play ƒëi t·ªõi ƒë√¢u n·∫øu support c·∫£ hai
 */
export default function GameDetailModal({ open, onOpenChange, game, preferredType = 'solo' }) {
  useEffect(() => {
    if (!open) return
    const onKey = (e) => { if (e.key === 'Escape') onOpenChange?.(false) }
    document.addEventListener('keydown', onKey)
    document.body.style.overflow = 'hidden'
    return () => {
      document.removeEventListener('keydown', onKey)
      document.body.style.overflow = ''
    }
  }, [open, onOpenChange])

  if (!open || !game) return null

  const playable =
    game.status === 'live' &&
    (game.supports?.includes(preferredType) || game.supports?.length > 0)

  const href = preferredType === 'battle'
    ? `/game/battle/${game.id}`
    : `/game/${game.id}`

  return (
    <div className="fixed inset-0 z-[60]">
      {/* overlay */}
      <button
        aria-label="Close"
        className="absolute inset-0 bg-black/50"
        onClick={() => onOpenChange?.(false)}
      />
      {/* dialog */}
      <div
        role="dialog"
        aria-modal="true"
        className="absolute left-1/2 top-1/2 w-[92vw] max-w-lg -translate-x-1/2 -translate-y-1/2 rounded-2xl border bg-white dark:bg-gray-900 shadow-2xl"
      >
        {/* header */}
        <div className="flex items-center justify-between p-4 border-b">
          <h2 className="text-xl font-semibold">{game.name}</h2>
          {game.status === 'coming_soon' && (
            <span className="text-[12px] px-2 py-1 rounded-full bg-yellow-400 text-black font-semibold">
              Coming Soon
            </span>
          )}
        </div>

        {/* body */}
        <div className="p-4 space-y-3">
          <div className="rounded-xl overflow-hidden border">
            <img
              src={`/cards/${game.id}.png`}
              alt={`${game.name} cover`}
              className="w-full h-48 object-cover"
              draggable={false}
            />
          </div>

          {game.description && (
            <p className="text-sm opacity-80">{game.description}</p>
          )}

          <div className="text-sm">
            <div><b>Min stake:</b> {game.minBet}</div>
            <div><b>Supports:</b> {game.supports?.join(', ')}</div>
          </div>
        </div>

        {/* footer */}
        <div className="p-4 border-t flex items-center justify-end gap-2">
          <button
            className="px-4 py-2 rounded-xl border"
            onClick={() => onOpenChange?.(false)}
          >
            Close
          </button>

          {playable ? (
            <Link
              href={href}
              className="px-4 py-2 rounded-xl border shadow font-semibold"
              onClick={() => onOpenChange?.(false)}
            >
              Play
            </Link>
          ) : (
            <button
              className="px-4 py-2 rounded-xl border shadow font-semibold opacity-60 cursor-not-allowed"
              disabled
              title="This mode is not available yet"
            >
              Not Available
            </button>
          )}
        </div>
      </div>
    </div>
  )
}




=== D:\Downloads\cado4fun\client\src\components\GameFilterBar.jsx ===

// client/src/components/GameFilterBar.jsx
'use client'

import { useEffect, useMemo, useState } from 'react'

/**
 * Props:
 * - onChange: (state) => void
 * - initial?: { type: 'all'|'solo'|'battle', sort: 'name_asc'|'name_desc'|'stake_asc'|'stake_desc', q: string }
 */
export default function GameFilterBar({ onChange, initial }) {
  const [type, setType] = useState(initial?.type ?? 'all')
  const [sort, setSort] = useState(initial?.sort ?? 'name_asc')
  const [q, setQ] = useState(initial?.q ?? '')

  useEffect(() => {
    onChange?.({ type, sort, q })
  }, [type, sort, q, onChange])

  const types = useMemo(
    () => [
      { value: 'all', label: 'All types' },
      { value: 'solo', label: 'Solo' },
      { value: 'battle', label: 'Battle' },
    ],
    []
  )

  const sorts = useMemo(
    () => [
      { value: 'name_asc', label: 'Name ‚Üë' },
      { value: 'name_desc', label: 'Name ‚Üì' },
      { value: 'stake_asc', label: 'Min Stake ‚Üë' },
      { value: 'stake_desc', label: 'Min Stake ‚Üì' },
    ],
    []
  )

  return (
    <div className="flex flex-col md:flex-row gap-3 md:items-center md:justify-between mb-4">
      <div className="flex gap-2">
        <select
          value={type}
          onChange={(e) => setType(e.target.value)}
          className="px-3 py-2 rounded-xl border bg-white dark:bg-gray-900"
          aria-label="Filter by type"
        >
          {types.map(t => <option key={t.value} value={t.value}>{t.label}</option>)}
        </select>

        <select
          value={sort}
          onChange={(e) => setSort(e.target.value)}
          className="px-3 py-2 rounded-xl border bg-white dark:bg-gray-900"
          aria-label="Sort"
        >
          {sorts.map(s => <option key={s.value} value={s.value}>{s.label}</option>)}
        </select>
      </div>

      <div className="flex-1 md:max-w-sm">
        <input
          value={q}
          onChange={(e) => setQ(e.target.value)}
          placeholder="Search by name‚Ä¶"
          className="w-full px-3 py-2 rounded-xl border bg-white dark:bg-gray-900"
          aria-label="Search games"
        />
      </div>
    </div>
  )
}




=== D:\Downloads\cado4fun\client\src\components\GameModeCarousel.jsx ===

// client/src/components/GameModeCarousel.jsx
'use client'

import { useState, useEffect, useRef, useCallback } from 'react'
import Link from 'next/link'
import GameCard from './GameCard'
import { useTheme } from 'next-themes'
import { useUser } from '../context/UserContext'
import { toast } from 'react-hot-toast'

// M·∫∑c ƒë·ªãnh v·∫´n l√† 3 game hi·ªán c√≥; c√≥ th·ªÉ truy·ªÅn prop `modes` ƒë·ªÉ custom.
const DEFAULT_MODES = ['coinflip', 'blackjackdice', 'dice']

export default function GameModeCarousel({
  modes = DEFAULT_MODES,
  hrefBase = '/game', // ‚ûï cho ph√©p Battle ƒë·ªïi base path sang /game/battle
}) {
  const { theme, resolvedTheme } = useTheme()
  const { user } = useUser()

  const [mounted, setMounted] = useState(false)
  useEffect(() => setMounted(true), [])

  // ---- measure container width (responsive) ----
  const wrapperRef = useRef(null)
  const [containerWidth, setContainerWidth] = useState(560)

  useEffect(() => {
    if (!wrapperRef.current) return
    const ro = new ResizeObserver((entries) => {
      const rect = entries[0]?.contentRect
      if (rect?.width) setContainerWidth(rect.width)
    })
    ro.observe(wrapperRef.current)
    return () => ro.disconnect()
  }, [])

  // ---- layout constants ----
  const cardWidth = 240
  const gap = 16
  const visible = Math.max(1, Math.floor(containerWidth / (cardWidth + gap)))
  const maxStart = Math.max(0, modes.length - visible)

  const [start, setStart] = useState(0)
  useEffect(() => {
    // n·∫øu resize l√†m visible tƒÉng, ƒë·∫£m b·∫£o start v·∫´n h·ª£p l·ªá
    setStart((s) => Math.min(s, maxStart))
  }, [maxStart])

  const prev = useCallback(() => setStart((s) => Math.max(0, s - 1)), [])
  const next = useCallback(() => setStart((s) => Math.min(maxStart, s + 1)), [maxStart])

  // ---- a11y / keyboard ----
  const onKeyDown = (e) => {
    if (e.key === 'ArrowLeft') {
      e.preventDefault()
      prev()
    } else if (e.key === 'ArrowRight') {
      e.preventDefault()
      next()
    }
  }

  // ---- swipe (mobile) ----
  const touchRef = useRef({ x: 0, y: 0 })
  const onTouchStart = (e) => {
    const t = e.touches?.[0]
    if (!t) return
    touchRef.current = { x: t.clientX, y: t.clientY }
  }
  const onTouchEnd = (e) => {
    const t = e.changedTouches?.[0]
    if (!t) return
    const dx = t.clientX - touchRef.current.x
    // threshold 40px
    if (Math.abs(dx) > 40) {
      if (dx < 0) next()
      else prev()
    }
  }

  // ---- guard SSR theme mismatch ----
  const isDark = mounted ? (theme ?? resolvedTheme) === 'dark' : false

  // ---- login gate ----
  const handleClick = (e) => {
    if (!user) {
      e.preventDefault()
      toast.error('B·∫°n c·∫ßn ph·∫£i ƒëƒÉng nh·∫≠p ƒë·ªÉ b·∫Øt ƒë·∫ßu ch∆°i.')
    }
  }

  const btnBase =
    'absolute top-1/2 -translate-y-1/2 p-2 rounded-full border shadow disabled:opacity-30 focus:outline-none focus:ring-2 focus:ring-offset-2'
  const buttonStyle = isDark
    ? `${btnBase} bg-black border-gray-700 text-white`
    : `${btnBase} bg-white border-black text-black`

  return (
    <div className="relative mx-auto w-full max-w-[720px]">
      {/* Prev */}
      <button
        type="button"
        onClick={prev}
        disabled={start === 0}
        className={`${buttonStyle} left-0`}
        aria-label="Previous games"
      >
        ‚Äπ
      </button>

      {/* Track container */}
      <div
        ref={wrapperRef}
        className="overflow-hidden mx-10"
        role="region"
        aria-label="Game carousel"
        tabIndex={0}
        onKeyDown={onKeyDown}
        onTouchStart={onTouchStart}
        onTouchEnd={onTouchEnd}
      >
        <div
          className="flex space-x-4 transition-transform duration-300 will-change-transform"
          style={{
            transform: `translateX(-${start * (cardWidth + gap)}px)`,
            padding: '0 40px', // h√© card 2 b√™n
            width: 'max-content',
          }}
        >
          {modes.map((mode) => (
            <Link
              key={mode}
              href={`${hrefBase}/${mode}`} // üîÅ d√πng base path truy·ªÅn v√†o
              onClick={handleClick}
              className="block flex-shrink-0"
              aria-label={`Open ${mode}`}
              style={{ width: cardWidth }}
            >
              <GameCard mode={mode} />
            </Link>
          ))}
        </div>
      </div>

      {/* Next */}
      <button
        type="button"
        onClick={next}
        disabled={start >= maxStart}
        className={`${buttonStyle} right-0`}
        aria-label="Next games"
      >
        ‚Ä∫
      </button>

      {/* Dots (optional small indicator) */}
      <div className="mt-3 flex items-center justify-center gap-2">
        {Array.from({ length: maxStart + 1 }).map((_, i) => (
          <button
            key={i}
            type="button"
            onClick={() => setStart(i)}
            aria-label={`Go to position ${i + 1}`}
            className={`h-2 w-2 rounded-full ${
              i === start ? 'bg-blue-500' : 'bg-gray-400 dark:bg-gray-600'
            }`}
          />
        ))}
      </div>
    </div>
  )
}




=== D:\Downloads\cado4fun\client\src\components\Layout.jsx ===

// client/src/components/Layout.jsx
import Navbar from './Navbar'

export default function Layout({ children }) {
  return (
    <>
      <Navbar />
      <main className="container mx-auto px-4 py-6">
        {children}
      </main>
      {/* sau n√†y n·∫øu c·∫ßn footer, add ·ªü ƒë√¢y */}
    </>
  )
}




=== D:\Downloads\cado4fun\client\src\components\Loading.jsx ===

// client/src/components/Loading.jsx
'use client'

export default function Loading({ text = 'ƒêang t·∫£i‚Ä¶' }) {
  return (
    <div className="p-8 text-center">
      <span>{text}</span>  // B·ªè suppressHydrationWarning
    </div>
  )
}



=== D:\Downloads\cado4fun\client\src\components\Navbar.jsx ===

// client/src/components/Navbar.jsx
'use client'

import Link from 'next/link'
import { useUser } from '../context/UserContext'
import { useState, useEffect, useRef, useCallback } from 'react'
import { Sun, Moon, Menu, X } from 'lucide-react'
import NotificationBell from './NotificationBell'
import { useTheme } from 'next-themes'

export default function Navbar() {
  const { user, balance, bank, logout } = useUser()

  // ===== THEME (next-themes) =====
  const { theme, setTheme, resolvedTheme } = useTheme()
  const [mounted, setMounted] = useState(false)
  useEffect(() => setMounted(true), [])

  const toggleTheme = () => setTheme((prev) => (prev === 'dark' ? 'light' : 'dark'))

  // ===== HAMBURGER =====
  const [hamburgerOpen, setHamburgerOpen] = useState(false)
  const panelRef = useRef(null)

  const toggleHamburger = useCallback(() => setHamburgerOpen((p) => !p), [])
  const closeHamburger = useCallback(() => setHamburgerOpen(false), [])

  // Lock scroll when panel open
  useEffect(() => {
    if (!hamburgerOpen) return
    const prev = document.body.style.overflow
    document.body.style.overflow = 'hidden'
    return () => {
      document.body.style.overflow = prev
    }
  }, [hamburgerOpen])

  // Focus first element in panel when opened
  useEffect(() => {
    if (!hamburgerOpen) return
    const t = setTimeout(() => {
      const focusables = panelRef.current?.querySelectorAll(
        'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'
      )
      focusables?.[0]?.focus()
    }, 0)
    return () => clearTimeout(t)
  }, [hamburgerOpen])

  // Trap focus + ESC to close
  useEffect(() => {
    if (!hamburgerOpen) return

    const onKeyDown = (e) => {
      if (!hamburgerOpen) return
      if (e.key === 'Escape') {
        e.preventDefault()
        closeHamburger()
      } else if (e.key === 'Tab') {
        const list = panelRef.current?.querySelectorAll(
          'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'
        )
        if (!list || list.length === 0) return
        const first = list[0]
        const last = list[list.length - 1]
        if (e.shiftKey && document.activeElement === first) {
          e.preventDefault()
          last.focus()
        } else if (!e.shiftKey && document.activeElement === last) {
          e.preventDefault()
          first.focus()
        }
      }
    }

    document.addEventListener('keydown', onKeyDown)
    return () => document.removeEventListener('keydown', onKeyDown)
  }, [hamburgerOpen, closeHamburger])

  const isAdmin = user?.role === 'admin' || user?.role === 'jadmin'

  const glowWhite = 'transition-all duration-200'
  const glowRed = 'transition-all duration-200 text-red-500 hover:text-red-400'

  // Format numbers safely
  const fmt = (n) => (typeof n === 'number' ? n.toLocaleString(undefined) : n)

  // ‚úÖ FIX: Better theme handling to prevent flicker
  const isDark = mounted ? (theme ?? resolvedTheme) === 'dark' : false

  return (
    <nav className="flex items-center p-4 bg-gray-800 text-white justify-between relative">
      {/* Left side */}
      <div className="flex items-center space-x-6">
        <Link href="/" className={`group flex items-center text-lg font-bold ${glowWhite}`}>
          <span className="group-hover:text-white group-hover:drop-shadow-[0_0_6px_rgba(255,255,255,0.8)]">
            4FUNBET
          </span>
        </Link>

        <Link href="/game" className="group flex items-center">
          <span className="group-hover:text-white group-hover:drop-shadow-[0_0_6px_rgba(255,255,255,0.8)]">
            Game
          </span>
        </Link>

        <Link href="/rewards" className="group flex items-center">
          <span className="group-hover:text-white group-hover:drop-shadow-[0_0_6px_rgba(255,255,255,0.8)]">
            Rewards
          </span>
        </Link>

        {/* ‚úÖ FIX: Stable placeholder prevents layout shift */}
        <div className="w-10 h-10 flex items-center justify-center">
          {mounted ? (
            <button
              onClick={toggleTheme}
              className="p-2 rounded bg-gray-200 dark:bg-gray-700 hover:bg-gray-300 dark:hover:bg-gray-600 transition-colors"
              aria-label="Toggle Dark Mode"
              type="button"
            >
              {isDark ? (
                <Sun className="w-5 h-5 text-yellow-400" />
              ) : (
                <Moon className="w-5 h-5 text-gray-800" />
              )}
            </button>
          ) : (
            <div className="p-2 w-9 h-9 rounded bg-gray-200 dark:bg-gray-700" />
          )}
        </div>
      </div>

      {/* Right side */}
      <div className="flex items-center space-x-4">
        {user ? (
          <>
            {/* Notification Bell */}
            <NotificationBell />

            {/* Wallet */}
            <Link href="/wallet" className="group flex flex-col items-end">
              <span 
                className="text-sm group-hover:text-white group-hover:drop-shadow-[0_0_6px_rgba(255,255,255,0.8)]"
                suppressHydrationWarning
              >
                Wallet: {fmt(balance)}
              </span>
              <span 
                className="text-xs text-gray-400 group-hover:text-white group-hover:drop-shadow-[0_0_6px_rgba(255,255,255,0.8)]"
                suppressHydrationWarning
              >
                Bank: {fmt(bank)}
              </span>
            </Link>

            {/* Hamburger */}
            <button
              onClick={toggleHamburger}
              className="group p-2"
              aria-haspopup="dialog"
              aria-expanded={hamburgerOpen}
              aria-controls="nav-hamburger-panel"
              type="button"
            >
              {hamburgerOpen ? (
                <X className="w-6 h-6 group-hover:text-white group-hover:drop-shadow-[0_0_6px_rgba(255,255,255,0.8)]" />
              ) : (
                <Menu className="w-6 h-6 group-hover:text-white group-hover:drop-shadow-[0_0_6px_rgba(255,255,255,0.8)]" />
              )}
            </button>
          </>
        ) : (
          <>
            <Link href="/login" className="hover:underline">
              Login
            </Link>
            <Link href="/register" className="hover:underline">
              Register
            </Link>
          </>
        )}
      </div>

      {/* Overlay */}
      {user && hamburgerOpen && (
        <button
          className="fixed inset-0 bg-black bg-opacity-50 z-40"
          onClick={closeHamburger}
          aria-label="Close menu overlay"
          type="button"
        />
      )}

      {/* Hamburger Menu Panel */}
      {user && (
        <aside
          id="nav-hamburger-panel"
          ref={panelRef}
          role="dialog"
          aria-modal="true"
          aria-label="User menu"
          className={`fixed top-0 right-0 h-full w-64 bg-gray-900 text-white z-50 shadow-lg p-6 outline-none 
            ${hamburgerOpen ? 'animate-slide-in' : 'pointer-events-none animate-slide-out'}`}
        >
          <div className="flex items-center justify-between mb-4">
            <div className="flex items-center space-x-3">
              <img
                src={user.avatar || '/default-avatar.png'}
                alt="Avatar"
                className="w-10 h-10 rounded-full border border-gray-700 object-cover"
              />
              <span className="font-semibold">{user.username}</span>
            </div>
            <button onClick={closeHamburger} aria-label="Close menu" type="button">
              <X className="w-5 h-5 text-gray-400 hover:text-white transition" />
            </button>
          </div>

          <hr className="border-gray-700 mb-4" />

          {/* Profile */}
          <Link href="/profile" className="group flex items-center space-x-2 py-2" onClick={closeHamburger}>
            <img
              src="/symbols/profile.png"
              alt=""
              className="w-5 h-5 group-hover:drop-shadow-[0_0_6px_rgba(255,255,255,0.8)]"
            />
            <span className="group-hover:text-white">Profile</span>
          </Link>

          {/* History */}
          <Link href="/history" className="group flex items-center space-x-2 py-2" onClick={closeHamburger}>
            <img
              src="/symbols/history.png"
              alt=""
              className="w-5 h-5 group-hover:drop-shadow-[0_0_6px_rgba(255,255,255,0.8)]"
            />
            <span className="group-hover:text-white">History</span>
          </Link>

          <hr className="border-gray-700 my-2" />

          {/* Settings */}
          <Link href="/settings" className="group flex items-center space-x-2 py-2" onClick={closeHamburger}>
            <img
              src="/symbols/settings.png"
              alt=""
              className="w-5 h-5 group-hover:drop-shadow-[0_0_6px_rgba(255,255,255,0.8)]"
            />
            <span className="group-hover:text-white">Settings</span>
          </Link>

          {/* Admin Health (only admin/jadmin) */}
          {isAdmin && (
            <>
              <hr className="border-gray-700 my-2" />
              <Link
                href="/admin/pvp/health"
                className="group flex items-center space-x-2 py-2"
                onClick={closeHamburger}
              >
                <span className="w-5 h-5 inline-flex items-center justify-center rounded bg-gray-800 text-xs">
                  H
                </span>
                <span className="group-hover:text-white">Admin Health</span>
              </Link>
            </>
          )}

          <hr className="border-gray-700 my-2" />

          {/* Logout */}
          <button
            onClick={() => {
              logout()
              closeHamburger()
            }}
            className="group flex items-center space-x-2 py-2 w-full text-left"
            type="button"
          >
            <img
              src="/symbols/logout.png"
              alt=""
              className="w-5 h-5 group-hover:drop-shadow-[0_0_6px_rgba(255,0,0,0.6)]"
            />
            <span className={glowRed}>Sign out</span>
          </button>
        </aside>
      )}
    </nav>
  )
}



=== D:\Downloads\cado4fun\client\src\components\NotificationBell.jsx ===

// client/src/components/NotificationBell.jsx
'use client';

import { useEffect, useState, useRef, useCallback, useMemo } from 'react';
import { Bell } from 'lucide-react';
import useApi from '../hooks/useApi';
import useSocket from '../hooks/useSocket';
import { useUser } from '../context/UserContext';
import { useRouter } from 'next/navigation';

function dedupeById(list) {
  const seen = new Set();
  const out = [];
  for (const n of list) {
    const id = n?._id || n?.id;
    if (!id || !seen.has(id)) {
      if (id) seen.add(id);
      out.push(n);
    }
  }
  return out;
}

export default function NotificationBell() {
  const router = useRouter();
  const { user } = useUser();
  const { get, patch, post } = useApi();

  const [notifications, setNotifications] = useState([]);
  const [dropdownOpen, setDropdownOpen]   = useState(false);
  const [isRefreshing, setIsRefreshing]   = useState(false);

  const bellRef = useRef(null);
  const mountedRef = useRef(false);
  const inflightRef = useRef(false);

  // üîí C·ªë ƒë·ªãnh c√°c h√†m API ƒë·ªÉ tr√°nh ƒë·ªïi identity m·ªói render
  const getRef = useRef(get);
  const patchRef = useRef(patch);
  const postRef = useRef(post);
  useEffect(() => { getRef.current = get; }, [get]);
  useEffect(() => { patchRef.current = patch; }, [patch]);
  useEffect(() => { postRef.current = post; }, [post]);

  // Guard mounted
  useEffect(() => {
    mountedRef.current = true;
    return () => { mountedRef.current = false; };
  }, []);

  const fetchNotifications = useCallback(async () => {
    if (!user) return;
    if (inflightRef.current) return; // ch·∫∑n spam/loop
    inflightRef.current = true;
    try {
      setIsRefreshing(true);
      const res = await getRef.current(`/notification?limit=100&ts=${Date.now()}`);
      const serverList = Array.isArray(res.notifications) ? res.notifications : [];
      setNotifications(prev => dedupeById([...serverList, ...prev]));
    } catch {
      // gi·ªØ nguy√™n danh s√°ch c≈© n·∫øu l·ªói
    } finally {
      inflightRef.current = false;
      if (mountedRef.current) setIsRefreshing(false);
    }
  }, [user]);

  // Initial fetch khi user thay ƒë·ªïi (‚ö†Ô∏è ch·ªâ ph·ª• thu·ªôc user ƒë·ªÉ tr√°nh loop)
  useEffect(() => {
    if (user) fetchNotifications();
    else setNotifications([]);
  }, [user, fetchNotifications]);

  // Prefetch trang /notifications khi m·ªü dropdown ‚Üí ƒëi·ªÅu h∆∞·ªõng m∆∞·ª£t h∆°n
  useEffect(() => {
    if (dropdownOpen) router.prefetch('/notifications');
  }, [dropdownOpen, router]);

  // Real-time incoming notifications (dedupe)
  useSocket(user?.id, notif => {
    if (!notif) return;
    setNotifications(prev => dedupeById([notif, ...prev]));
  });

  // Close dropdown on outside click
  useEffect(() => {
    function onClick(e) {
      if (!dropdownOpen) return;
      if (bellRef.current && !bellRef.current.contains(e.target)) {
        setDropdownOpen(false);
      }
    }
    document.addEventListener('mousedown', onClick);
    return () => document.removeEventListener('mousedown', onClick);
  }, [dropdownOpen]);

  // Close with Escape
  useEffect(() => {
    function onKey(e) {
      if (!dropdownOpen) return;
      if (e.key === 'Escape') setDropdownOpen(false);
    }
    document.addEventListener('keydown', onKey);
    return () => document.removeEventListener('keydown', onKey);
  }, [dropdownOpen]);

  const markAsRead = useCallback(async (id) => {
    try {
      await patchRef.current(`/notification/${id}/read`);
      setNotifications(ns => ns.map(n => (n._id === id ? { ...n, read: true } : n)));
    } catch {
      // no-op
    }
  }, []);

  const onItemClick = useCallback(async (n) => {
    if (!n) return;

    // Mark read (best-effort)
    await markAsRead(n._id);

    // Extract roomId & path from metadata/link
    const roomId = n?.metadata?.roomId || (typeof n?.link === 'string' ? n.link.split('/').pop() : undefined);
    const path = n?.metadata?.path || n?.link || (roomId ? `/game/battle/room/${roomId}` : null);

    if (roomId) {
      try {
        // Auto-join before redirect (ignore errors like "already in room")
        await postRef.current(`/pvp/${roomId}/join`, {});
      } catch {}
    }

    if (path) {
      router.push(path);
      setDropdownOpen(false);
    }
  }, [markAsRead, router]);

  const unreadCount = useMemo(
    () => notifications.reduce((acc, n) => (n?.read ? acc : acc + 1), 0),
    [notifications]
  );
  const unreadBadge = unreadCount > 99 ? '99+' : unreadCount || null;
  const recent7 = useMemo(() => notifications.slice(0, 7), [notifications]);

  return (
    <div className="relative" ref={bellRef}>
      <button
        onClick={() => setDropdownOpen(o => !o)}
        aria-label="Notifications"
        aria-expanded={dropdownOpen}
        aria-haspopup="menu"
        className="group p-2 rounded bg-gray-200 dark:bg-gray-700 hover:bg-gray-300 dark:hover:bg-gray-600 transition-colors relative"
      >
        <Bell className="w-6 h-6 group-hover:drop-shadow-[0_0_6px_rgba(255,255,255,0.8)]" />
        {unreadBadge && (
          <span
            aria-label={`${unreadCount} unread notifications`}
            className="absolute -top-1 -right-1 bg-red-500 text-xs text-white rounded-full px-1 min-w-[18px] text-center"
          >
            {unreadBadge}
          </span>
        )}
      </button>

      {dropdownOpen && (
        <div
          role="menu"
          aria-label="Notifications menu"
          className="absolute right-0 mt-2 w-80 bg-white dark:bg-gray-800 text-gray-900 dark:text-gray-100 shadow-lg rounded p-3 z-50"
        >
          <h3 className="font-bold mb-2">Notifications</h3>
          <ul className="max-h-64 overflow-y-auto">
            {recent7.length === 0 ? (
              <li className="text-gray-500">No notifications</li>
            ) : (
              recent7.map(n => (
                <li
                  key={n._id || n.id}
                  onClick={() => onItemClick(n)}
                  className={`py-2 border-b flex flex-col cursor-pointer ${
                    n.read ? 'text-gray-500' : 'text-gray-900 font-semibold'
                  }`}
                  title={n?.metadata?.path || ''}
                  role="menuitem"
                  tabIndex={0}
                  onKeyDown={(e) => {
                    if (e.key === 'Enter' || e.key === ' ') {
                      e.preventDefault();
                      onItemClick(n);
                    }
                  }}
                >
                  <span>{n.message}</span>
                  <span className="text-xs">{new Date(n.createdAt).toLocaleString()}</span>
                </li>
              ))
            )}
          </ul>
          <div className="pt-2 flex items-center justify-between gap-2">
            <button
              onClick={fetchNotifications}
              disabled={isRefreshing}
              className="text-sm px-2 py-1 rounded border border-gray-300 dark:border-gray-600 hover:bg-gray-100 dark:hover:bg-gray-700 disabled:opacity-60"
            >
              {isRefreshing ? 'Refreshing...' : 'Refresh'}
            </button>
            <button
              onClick={() => { setDropdownOpen(false); router.push('/notifications'); }}
              className="text-sm px-2 py-1 rounded border border-gray-300 dark:border-gray-600 hover:bg-gray-100 dark:hover:bg-gray-700"
            >
              View All
            </button>
          </div>
        </div>
      )}
    </div>
  );
}




=== D:\Downloads\cado4fun\client\src\components\PromptDialog.jsx ===

// client/src/components/PromptDialog.jsx
'use client';
import { useEffect, useRef, useState, useCallback } from 'react';
import { createPortal } from 'react-dom';

export default function PromptDialog({
  open,
  title = 'Input',
  description,
  placeholder = '',
  initialValue = '',
  confirmText = 'OK',
  cancelText = 'Cancel',
  required = false,
  validate,                 // (value) => string | null
  onConfirm,
  onCancel,
  onOpenChange,             // NEW: (nextOpen:boolean)=>void
  loading = false,
}) {
  const [value, setValue] = useState(initialValue || '');
  const [error, setError] = useState('');
  const backdropRef = useRef(null);
  const inputRef = useRef(null);

  // Auto-reset + th√¥ng b√°o state ra ngo√†i
  useEffect(() => {
    if (open) {
      setValue(initialValue || '');
      setError('');
      setTimeout(() => inputRef.current?.focus(), 0);
    }
    onOpenChange?.(!!open);
  }, [open, initialValue, onOpenChange]);

  // Kho√° scroll n·ªÅn
  useEffect(() => {
    if (!open) return;
    const prev = document.body.style.overflow;
    document.body.style.overflow = 'hidden';
    return () => { document.body.style.overflow = prev; };
  }, [open]);

  const computeError = useCallback((v) => {
    if (required && !v) return 'Vui l√≤ng nh·∫≠p _id tr∆∞·ªõc.';
    if (validate) {
      const msg = validate(v);
      if (msg) return msg;
    }
    return '';
  }, [required, validate]);

  const trySubmit = useCallback(() => {
    const msg = computeError(value);
    if (msg) { setError(msg); return; }
    onConfirm?.(value);
  }, [computeError, onConfirm, value]);

  // Trap focus + Esc + Enter
  const onKeyDown = useCallback((e) => {
    if (!open) return;
    if (e.key === 'Escape') {
      onCancel?.();
      onOpenChange?.(false);
    }
    if (e.key === 'Enter') {
      e.preventDefault();
      if (!computeError(value) && !loading) trySubmit();
    }
    if (e.key === 'Tab') {
      const list = backdropRef.current?.querySelectorAll(
        'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'
      );
      if (!list?.length) return;
      const first = list[0];
      const last = list[list.length - 1];
      if (e.shiftKey && document.activeElement === first) {
        e.preventDefault(); last.focus();
      } else if (!e.shiftKey && document.activeElement === last) {
        e.preventDefault(); first.focus();
      }
    }
  }, [open, computeError, trySubmit, value, loading, onCancel, onOpenChange]);

  if (!open) return null;

  return createPortal(
    <div
      ref={backdropRef}
      className="fixed inset-0 z-50 bg-black/50 flex items-center justify-center p-4"
      role="dialog"
      aria-modal="true"
      aria-label={title}
      onKeyDown={onKeyDown}
      onMouseDown={(e) => {
        if (e.target === e.currentTarget) {
          onCancel?.();
          onOpenChange?.(false);
        }
      }}
    >
      <div
        className="bg-white dark:bg-gray-900 dark:text-white w-full max-w-md rounded-2xl p-4 shadow-lg outline-none"
        onMouseDown={(e) => e.stopPropagation()}
      >
        <div className="text-lg font-semibold mb-1">{title}</div>
        {description && <div className="text-sm opacity-80 mb-3">{description}</div>}

        <input
          ref={inputRef}
          autoFocus
          disabled={loading}
          className="w-full border rounded-xl px-3 py-2 mb-2 bg-transparent disabled:opacity-60"
          placeholder={placeholder}
          value={value}
          onChange={(e) => {
            const v = e.target.value;
            setValue(v);
            setError(computeError(v));
          }}
        />

        {error && <div className="text-xs text-red-500 mb-2">{error}</div>}

        <div className="flex justify-end gap-2">
          <button
            type="button"
            className="px-3 py-2 rounded-xl border"
            onClick={() => { onCancel?.(); onOpenChange?.(false); }}
            disabled={loading}
          >
            {cancelText}
          </button>
          <button
            type="button"
            className="px-3 py-2 rounded-xl border shadow disabled:opacity-50"
            onClick={trySubmit}
            disabled={loading || !!computeError(value)}
          >
            {loading ? '...' : confirmText}
          </button>
        </div>
      </div>
    </div>,
    document.body
  );
}




=== D:\Downloads\cado4fun\client\src\components\RequireAuth.jsx ===

// client/src/components/RequireAuth.jsx
'use client'

import { useEffect, useState } from 'react'
import { usePathname, useRouter } from 'next/navigation'
import Loading from '@/components/Loading'
import { useUser } from '@/context/UserContext'

/**
 * B·∫£o v·ªá trang y√™u c·∫ßu ƒëƒÉng nh·∫≠p.
 *
 * Lu·ªìng m·ªõi (ch·ªëng hydration mismatch & loop):
 * - Kh√¥ng ƒë·ªçc localStorage trong render.
 * - Sau khi mount: ƒë·ªçc token ‚Üí n·∫øu kh√¥ng c√≥, redirect /login?next=...
 * - N·∫øu c√≥ token: g·ªçi fetchUser; xong th√¨:
 *    + c√≥ user -> render
 *    + kh√¥ng c√≥ -> redirect /login
 */
export default function RequireAuth(Component) {
  return function GuardedPage(props) {
    const router = useRouter()
    const pathname = usePathname()
    const { user, fetchUser } = useUser()

    // Tr·∫°ng th√°i ki·ªÉm tra ƒë√£ xong ch∆∞a
    const [checked, setChecked] = useState(false)
    // K·∫øt qu·∫£ ki·ªÉm tra token (null: ch∆∞a bi·∫øt; true/false: ƒë√£ bi·∫øt)
    const [hasToken, setHasToken] = useState(null)

    useEffect(() => {
      // Ch·ªâ ch·∫°y ·ªü client
      let cancelled = false

      const run = async () => {
        // 1) ƒê·ªçc token sau mount
        let token = null
        try {
          token = localStorage.getItem('token')
        } catch {
          token = null
        }
        if (cancelled) return

        const tokenExists = !!token
        setHasToken(tokenExists)

        // 2) N·∫øu KH√îNG c√≥ token ‚Üí redirect login (+ next)
        if (!tokenExists) {
          const next = encodeURIComponent(pathname || '/')
          router.replace(`/login?next=${next}`)
          setChecked(true)
          return
        }

        // 3) C√≥ token ‚Üí ƒë·∫£m b·∫£o fetch user m·ªôt l·∫ßn
        try {
          if (!user) {
            await fetchUser()
          }
        } finally {
          if (!cancelled) setChecked(true)
        }
      }

      run()
      return () => { cancelled = true }
    }, [pathname, router, fetchUser, user])

    // Ch∆∞a ki·ªÉm tra xong: d√πng 1 text duy nh·∫•t ƒë·ªÉ tr√°nh mismatch
    if (!checked || hasToken === null) {
      return <Loading text="ƒêang x√°c th·ª±c phi√™n ƒëƒÉng nh·∫≠p‚Ä¶" />
    }

    // ƒê√£ ki·ªÉm tra: kh√¥ng c√≥ token ho·∫∑c kh√¥ng l·∫•y ƒë∆∞·ª£c user ‚Üí redirect (effect ƒë√£ x·ª≠ l√Ω)
    if (!hasToken || !user) {
      return <Loading text="ƒêang x√°c th·ª±c phi√™n ƒëƒÉng nh·∫≠p‚Ä¶" />
    }

    // OK
    return <Component {...props} />
  }
}



=== D:\Downloads\cado4fun\client\src\components\ServerCountdown.jsx ===

// client/src/components/ServerCountdown.jsx
'use client';
import { useEffect, useMemo, useState } from 'react';

/**
 * ƒê·∫øm ng∆∞·ª£c theo m·ªëc th·ªùi gian t·ª´ server:
 *  - serverNow: timestamp (ms) l√∫c payload ƒë∆∞·ª£c g·ª≠i
 *  - target:    timestamp (ms) m·ªëc c·∫ßn ƒë·∫øm t·ªõi (t·ª´ server)
 * Component t·ª± hi·ªáu ch·ªânh l·ªách ƒë·ªìng h·ªì client/server.
 */
export default function ServerCountdown({ serverNow, target, className = '' }) {
  const [now, setNow] = useState(Date.now());

  // l·ªách gi·ªØa ƒë·ªìng h·ªì client v√† server t·∫°i th·ªùi ƒëi·ªÉm render
  const skew = useMemo(() => {
    if (!serverNow) return 0;
    return Date.now() - Number(serverNow);
  }, [serverNow]);

  useEffect(() => {
    const id = setInterval(() => setNow(Date.now()), 250);
    return () => clearInterval(id);
  }, []);

  const remainMs = Math.max(0, Number(target || 0) - (now - skew));
  const remainS = Math.ceil(remainMs / 1000);

  return <span className={className}>{remainS}s</span>;
}




=== D:\Downloads\cado4fun\client\src\components\Skeleton.jsx ===

// client/src/components/Skeleton.jsx
export default function Skeleton({ className = '' }) {
  return <div className={`animate-pulse bg-black/10 dark:bg-white/10 rounded ${className}`} />;
}




=== D:\Downloads\cado4fun\client\src\components\TurnTimer.jsx ===

// client/src/components/TurnTimer.jsx
'use client';
import { useEffect, useState } from 'react';

export default function TurnTimer({ deadline, onExpire, className = '' }) {
  const [seconds, setSeconds] = useState(0);

  useEffect(() => {
    const tick = () => {
      const t = typeof deadline === 'string' ? new Date(deadline).getTime() : +deadline;
      const now = Date.now();
      const s = Math.max(0, Math.ceil((t - now) / 1000));
      setSeconds(s);
      if (s <= 0 && onExpire) onExpire();
    };
    tick();
    const id = setInterval(tick, 1000);
    return () => clearInterval(id);
  }, [deadline, onExpire]);

  return <span className={className}>{seconds}s</span>;
}




=== D:\Downloads\cado4fun\client\src\components\VerifyFairnessModal.jsx ===

// client/src/components/VerifyFairnessModal.jsx
'use client';
import { useEffect, useRef, useState, useCallback } from 'react';
import useApi from '@/hooks/useApi';

export default function VerifyFairnessModal({ roomId, open, onClose, onOpenChange }) {
  const { get } = useApi();

  // Gi·ªØ ref ·ªïn ƒë·ªãnh cho get() ƒë·ªÉ tr√°nh loop useEffect
  const getRef = useRef(get);
  useEffect(() => { getRef.current = get; }, [get]);

  const [loading, setLoading] = useState(false);
  const [data, setData] = useState(null);
  const [error, setError] = useState('');
  const backdropRef = useRef(null);

  useEffect(() => { onOpenChange?.(!!open); }, [open, onOpenChange]);

  // Kho√° scroll n·ªÅn
  useEffect(() => {
    if (!open) return;
    const prev = document.body.style.overflow;
    document.body.style.overflow = 'hidden';
    return () => { document.body.style.overflow = prev; };
  }, [open]);

  // Load d·ªØ li·ªáu khi m·ªü
  useEffect(() => {
    if (!open) return;
    let cancelled = false;

    (async () => {
      try {
        setLoading(true);
        setError('');
        const res = await getRef.current(`/pvp/${roomId}/verify`);
        if (!cancelled) setData(res || null);
      } catch (e) {
        if (!cancelled) {
          setError(e?.message || 'Fetch verify data failed');
          setData(null);
        }
      } finally {
        if (!cancelled) setLoading(false);
      }
    })();

    return () => { cancelled = true; };
  }, [open, roomId]);

  // Trap focus + Esc
  const onKeyDown = useCallback((e) => {
    if (!open) return;
    if (e.key === 'Escape') {
      onClose?.();
      onOpenChange?.(false);
    }
    if (e.key === 'Tab') {
      const list = backdropRef.current?.querySelectorAll(
        'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'
      );
      if (!list || !list.length) return;
      const first = list[0];
      const last = list[list.length - 1];
      if (e.shiftKey && document.activeElement === first) { e.preventDefault(); last.focus(); }
      else if (!e.shiftKey && document.activeElement === last) { e.preventDefault(); first.focus(); }
    }
  }, [open, onClose, onOpenChange]);

  async function copyJsonInline(payload) {
    try {
      const text = typeof payload === 'string' ? payload : JSON.stringify(payload ?? {}, null, 2);
      await navigator.clipboard.writeText(text);
      const el = document.getElementById('copy-json-inline-btn');
      if (el) {
        const old = el.innerText;
        el.innerText = 'Copied!';
        setTimeout(() => { el.innerText = old; }, 1200);
      }
    } catch {}
  }

  if (!open) return null;

  return (
    <div className="fixed inset-0 z-50" role="dialog" aria-modal="true" aria-label="Verify Fairness">
      <div
        ref={backdropRef}
        className="absolute inset-0 bg-black/50"
        onMouseDown={(e) => { if (e.target === e.currentTarget) { onClose?.(); onOpenChange?.(false); } }}
        onKeyDown={onKeyDown}
        tabIndex={-1}
      >
        <div
          className="absolute inset-0 flex items-center justify-center p-3"
          onMouseDown={(e) => e.stopPropagation()}
        >
          <div className="bg-white dark:bg-gray-900 dark:text-white rounded-2xl w-full max-w-2xl p-4 shadow-lg outline-none">
            {/* Header */}
            <div className="flex items-center justify-between">
              <h2 className="text-lg font-semibold">Verify Fairness</h2>
              <button className="px-2 py-1 rounded border" onClick={() => { onClose?.(); onOpenChange?.(false); }}>
                Close
              </button>
            </div>

            {loading && <div className="mt-4 text-sm">Loading‚Ä¶</div>}
            {error && <div className="mt-4 text-sm text-red-600">{error}</div>}

            {!loading && !error && data && (
              <div className="mt-4 space-y-3 text-sm">
                <div>Game: <b>{data.game}</b></div>

                <div className="break-all">
                  Server Seed Hash (commit): <code className="bg-gray-100 dark:bg-white/10 px-1 rounded">{data.serverSeedHash}</code>
                </div>
                {data.serverSeedReveal && (
                  <div className="break-all">
                    Server Seed (reveal): <code className="bg-gray-100 dark:bg-white/10 px-1 rounded">{data.serverSeedReveal}</code>
                  </div>
                )}
                <div className="break-all">
                  Client Seed: <code className="bg-gray-100 dark:bg-white/10 px-1 rounded">{data.clientSeed}</code>
                </div>
                {typeof data.nonceStart === 'number' && (
                  <div>Nonce start: <code className="bg-gray-100 dark:bg-white/10 px-1 rounded">{data.nonceStart}</code></div>
                )}

                {/* Raw JSON + single Copy button */}
                <div className="mt-3 border rounded p-2">
                  <div className="flex items-center justify-between mb-2">
                    <div className="font-semibold">Verification payload (raw)</div>
                    <button
                      id="copy-json-inline-btn"
                      onClick={() => copyJsonInline(data)}
                      className="px-2 py-1 text-xs rounded border shadow"
                      title="Copy JSON to clipboard"
                    >
                      Copy JSON
                    </button>
                  </div>
                  <pre className="text-xs bg-black/5 dark:bg-white/10 rounded p-3 overflow-auto">
{JSON.stringify(data, null, 2)}
                  </pre>
                </div>
              </div>
            )}

          </div>
        </div>
      </div>
    </div>
  );
}




=== D:\Downloads\cado4fun\client\src\constants\socketEvents.js ===

// Centralized socket event names ‚Äî import and reuse everywhere
export const SOCKET_EVENTS = {
  REGISTER: 'register',
  NOTIFICATION: 'notification',

  PVP: {
    ROOM_UPDATED: 'pvp:roomUpdated',
    ROOM_STARTED: 'pvp:roomStarted',
    ROOM_FINISHED: 'pvp:roomFinished',
    ROOM_DELETED: 'pvp:roomDeleted',

    JOIN_CHANNEL: 'pvp:joinRoomChannel',
    LEAVE_CHANNEL: 'pvp:leaveRoomChannel',
    LIST: 'pvp:list',
  },
};




=== D:\Downloads\cado4fun\client\src\context\UserContext.jsx ===

// client/src/context/UserContext.jsx
'use client'

import { createContext, useContext, useEffect, useState } from 'react'
import useApi from '../hooks/useApi'
import { useRouter } from 'next/navigation'

const UserContext = createContext()

export function UserProvider({ children }) {
  const [user, setUser]       = useState(null)
  const [balance, setBalance] = useState(0)
  const [bank, setBank]       = useState(0)
  const { get }               = useApi()
  const router                = useRouter()

  const fetchUser = async () => {
    try {
      const u = await get('/user/me')
      setUser({
        id: u._id,
        username: u.username,
        email: u.email,
        avatar: u.avatar || '',
        dateOfBirth: u.dateOfBirth || null,
        role: u.role || 'user', // ‚¨ÖÔ∏è th√™m role ƒë·ªÉ ph√¢n quy·ªÅn hi·ªÉn th·ªã Admin Health
      })
      setBalance(u.balance)
      setBank(u.bank)
    } catch {
      setUser(null)
      setBalance(0)
      setBank(0)
    }
  }

  useEffect(() => {
    fetchUser()
  }, [])

  const logout = () => {
    if (typeof window !== 'undefined') {
      localStorage.removeItem('token')
      setUser(null)
      setBalance(0)
      setBank(0)
      router.push('/login')
    }
  }

  const updateBalance = (newBalance) => setBalance(newBalance)
  const updateBank    = (newBank)     => setBank(newBank)

  return (
    <UserContext.Provider value={{
      user, balance, bank,
      fetchUser, logout,
      updateBalance, updateBank
    }}>
      {children}
    </UserContext.Provider>
  )
}

export function useUser() {
  return useContext(UserContext)
}




=== D:\Downloads\cado4fun\client\src\data\games.js ===

// client/src/data/games.js
// status: 'live' | 'coming_soon'
export const GAMES = [
  {
    id: "coinflip",
    name: "Coinflip",
    minBet: 1,
    supports: ["solo", "battle"],
    icon: "ü™ô",
    status: "live",
    description: "Double-or-nothing coin toss with provably-fair reveals.",
  },
  {
    id: "dice",
    name: "Dice",
    minBet: 1,
    supports: ["solo", "battle"],
    icon: "üé≤",
    status: "live",
    description: "Roll to target ‚Äî simple odds, quick rounds, high adrenaline.",
  },
  {
    id: "blackjackdice",
    name: "Blackjack Dice",
    minBet: 5,
    supports: ["solo"],
    icon: "üÉè",
    status: "live",
    description: "Reach 21 with dice ‚Äî blackjack rules, dice thrills.",
  },
  {
    id: "roulette",
    name: "Roulette",
    minBet: 5,
    supports: ["solo"],
    icon: "üé°",
    status: "live",
    description: "Classic roulette board ‚Äî red/black, dozens, and more.",
  },
  {
    id: "higherlower",
    name: "Higher/Lower",
    minBet: 1,
    supports: ["solo"],
    icon: "‚¨ÜÔ∏è‚¨áÔ∏è",
    status: "live",
    description: "Predict the next number ‚Äî simple and satisfying.",
  },
  {
    id: "slots",
    name: "Slots",
    minBet: 1,
    supports: ["solo"],
    icon: "üé∞",
    status: "live",
    description: "Spin to win ‚Äî vibrant reels and juicy bonuses.",
  },
]



=== D:\Downloads\cado4fun\client\src\hooks\useApi.js ===

// client/src/hooks/useApi.js
'use client'

import { toast } from 'react-hot-toast'
import { mapError } from '@/utils/errorMap'

const REDIRECT_FLAG = 'auth:redirected'

export default function useApi() {
  const baseUrl = '/api'
  const getToken = () =>
    typeof window !== 'undefined' ? localStorage.getItem('token') : null

  const defaultHeaders = () => {
    const token = getToken()
    return {
      'Content-Type': 'application/json',
      'x-client-now': String(Date.now()),
      ...(token ? { Authorization: `Bearer ${token}` } : {}),
    }
  }

  function safeRedirectToLoginOnce() {
    if (typeof window === 'undefined') return
    const { pathname, search } = window.location
    const isOnLogin = pathname.startsWith('/login')
    if (isOnLogin) return

    const flagged = sessionStorage.getItem(REDIRECT_FLAG)
    if (flagged) return

    try { sessionStorage.setItem(REDIRECT_FLAG, '1') } catch {}
    try { localStorage.removeItem('token') } catch {}

    const next = encodeURIComponent(pathname + search)
    // replace ƒë·ªÉ kh√¥ng ƒë·ªÉ user quay l·∫°i trang l·ªói
    window.location.replace(`/login?next=${next}`)
  }

  function notifyError(payloadLike) {
    const mapped = mapError({ __payload: payloadLike })
    if (mapped?.message) toast.error(mapped.message)
  }

  async function request(path, { method = 'GET', body } = {}) {
    let res
    try {
      res = await fetch(baseUrl + path, {
        method,
        headers: defaultHeaders(),
        body: body ? JSON.stringify(body) : undefined,
        cache: 'no-store',
      })
    } catch {
      const payload = { code: 'INTERNAL_ERROR', message: 'Network error' }
      notifyError(payload)
      const err = new Error('Network error')
      err.__payload = payload
      throw err
    }

    // c·ªë g·∫Øng parse JSON (k·ªÉ c·∫£ khi !res.ok)
    let data = null
    try { data = await res.json() } catch {}

    // üîí Auth h·∫øt h·∫°n / kh√¥ng h·ª£p l·ªá ‚Üí logout + redirect 1 l·∫ßn (tr√°nh l·∫∑p)
    if (res.status === 401 || res.status === 403) {
      const payload =
        data && (data.code || data.message)
          ? data
          : { code: 'AUTH_EXPIRED', message: 'Session expired. Please log in again.' }

      // dedup toast
      toast.dismiss('auth-expired')
      toast.error(payload.message, { id: 'auth-expired' })

      safeRedirectToLoginOnce()

      const err = new Error(payload.message)
      err.__payload = payload
      throw err
    }

    if (!res.ok) {
      const payload =
        data && (data.code || data.message)
          ? data
          : { code: 'INTERNAL_ERROR', message: res.statusText }

      notifyError(payload)

      const err = new Error(payload?.message || 'Request failed')
      err.__payload = payload
      throw err
    }

    return data
  }

  return {
    get: (path) => request(path, { method: 'GET' }),
    post: (path, body) => request(path, { method: 'POST', body }),
    patch: (path, body) => request(path, { method: 'PATCH', body }),
    del: (path) => request(path, { method: 'DELETE' }),
  }
}




=== D:\Downloads\cado4fun\client\src\hooks\useSocket.js ===

'use client'

import { useEffect, useMemo, useRef } from 'react'
import { io } from 'socket.io-client'
import { SOCKET_EVENTS as EVENTS } from '@/constants/socketEvents'

let socketSingleton = null
let activeUserId = null
let subscriberCount = 0

function getToken() {
  if (typeof window === 'undefined') return null
  try { return localStorage.getItem('token') } catch { return null }
}

function ensureSocket(userId) {
  const baseUrl = process.env.NEXT_PUBLIC_SOCKET_URL || 'http://localhost:3001'
  const token = getToken()

  if (socketSingleton && activeUserId && String(activeUserId) === String(userId)) {
    return socketSingleton
  }

  if (socketSingleton) {
    try { socketSingleton.removeAllListeners() } catch {}
    try { socketSingleton.disconnect() } catch {}
    socketSingleton = null
  }

  socketSingleton = io(baseUrl, {
    autoConnect: !!userId,
    transports: ['websocket'],
    auth: token ? { token } : {},
  })
  activeUserId = userId || null

  if (userId) {
    socketSingleton.on('connect', () => {
      socketSingleton.emit(EVENTS.REGISTER, String(userId))
    })
  }

  return socketSingleton
}

/**
 * useSocket(userId, handlersOrCb)
 * - Back-compat: (notif) => void
 * - New:
 *    { onConnect, onDisconnect, onError, onNotification, events: { [evt]: fn } }
 */
export default function useSocket(userId, handlersOrCb) {
  const handlersRef = useRef(handlersOrCb)
  handlersRef.current = handlersOrCb

  const isBackCompatCb = typeof handlersOrCb === 'function'
  const handlers = useMemo(() => {
    if (isBackCompatCb) return { onNotification: handlersOrCb }
    return handlersOrCb || {}
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [isBackCompatCb])

  const socket = useMemo(() => {
    if (!userId) return null
    return ensureSocket(userId)
  }, [userId])

  useEffect(() => {
    if (!socket || !userId) return

    subscriberCount += 1

    const { onConnect, onDisconnect, onError, onNotification, events } = handlers
    const offFns = []

    if (onConnect) {
      const h = () => onConnect(socket)
      socket.on('connect', h)
      offFns.push(() => socket.off('connect', h))
    }

    if (onDisconnect) {
      const h = (reason) => onDisconnect(reason)
      socket.on('disconnect', h)
      offFns.push(() => socket.off('disconnect', h))
    }

    if (onError) {
      const h = (err) => onError(err)
      socket.on('error', h)
      socket.on('connect_error', h)
      offFns.push(() => socket.off('error', h))
      offFns.push(() => socket.off('connect_error', h))
    }

    if (onNotification) {
      const h = (notif) => onNotification(notif)
      socket.on(EVENTS.NOTIFICATION, h)
      offFns.push(() => socket.off(EVENTS.NOTIFICATION, h))
    }

    if (events && typeof events === 'object') {
      Object.entries(events).forEach(([evt, fn]) => {
        if (typeof fn === 'function') {
          socket.on(evt, fn)
          offFns.push(() => socket.off(evt, fn))
        }
      })
    }

    return () => {
      offFns.forEach(off => { try { off() } catch {} })
      subscriberCount = Math.max(0, subscriberCount - 1)
      if (subscriberCount === 0 && socketSingleton) {
        try { socketSingleton.removeAllListeners() } catch {}
        try { socketSingleton.disconnect() } catch {}
        socketSingleton = null
        activeUserId = null
      }
    }
  }, [socket, userId, handlers])

  return useMemo(() => {
    if (!socket) return null

    const joinPvpRoom = (roomId) => { if (roomId) socket.emit(EVENTS.PVP.JOIN_CHANNEL, String(roomId)) }
    const leavePvpRoom = (roomId) => { if (roomId) socket.emit(EVENTS.PVP.LEAVE_CHANNEL, String(roomId)) }
    const $$emit = (event, payload) => socket.emit(event, payload)

    if (!socket.joinPvpRoom) Object.defineProperty(socket, 'joinPvpRoom', { value: joinPvpRoom, enumerable: false })
    if (!socket.leavePvpRoom) Object.defineProperty(socket, 'leavePvpRoom', { value: leavePvpRoom, enumerable: false })
    if (!socket.$$emit) Object.defineProperty(socket, '$$emit', { value: $$emit, enumerable: false })

    return socket
  }, [socket])
}




=== D:\Downloads\cado4fun\client\src\hooks\useUser.js ===

// client/src/hooks/useUser.js

'use client'

import { useState, useEffect } from 'react'
import useApi from './useApi'
import { usePathname, useRouter } from 'next/navigation'

export function useUser() {
  const [user, setUser]       = useState(null)
  const [balance, setBalance] = useState(0)
  const { get }               = useApi()
  const router                = useRouter()
  const pathname              = usePathname()

  // m·ªói khi mount ho·∫∑c chuy·ªÉn trang, fetch l·∫°i /auth/me
  useEffect(() => {
    ;(async () => {
      try {
        const { username, email, balance } = await get('/auth/me')
        setUser({ username, email })
        setBalance(balance)
      } catch {
        setUser(null)
        setBalance(0)
      }
    })()
  }, [pathname, get])

  const logout = () => {
    if (typeof window !== 'undefined') {
      localStorage.removeItem('token')
      setUser(null)
      setBalance(0)
      router.push('/login')
    }
  }

  // cho ph√©p c·∫≠p nh·∫≠t balance t·ª´ b√™n ngo√†i
  const updateBalance = (newBalance) => {
    setBalance(newBalance)
  }

  return { user, balance, updateBalance, logout }
}




=== D:\Downloads\cado4fun\client\src\utils\errorMap.js ===

// client/src/utils/errorMap.js
const MAP = {
  // PvP
  PVP_ROOM_NOT_FOUND: 'Ph√≤ng kh√¥ng t·ªìn t·∫°i ho·∫∑c ƒë√£ b·ªã xo√°.',
  PVP_ROOM_NOT_JOINABLE: 'Ph√≤ng kh√¥ng th·ªÉ tham gia l√∫c n√†y.',
  PVP_ROOM_NOT_READYABLE: 'Ph√≤ng kh√¥ng ·ªü tr·∫°ng th√°i c√≥ th·ªÉ s·∫µn s√†ng.',
  PVP_ROOM_NOT_ACTIVE: 'Ph√≤ng ch∆∞a active.',
  PVP_ROOM_ALREADY_ACTIVE: 'Ph√≤ng ƒë√£ active.',
  PVP_ROOM_NOT_WAITING: 'Ph√≤ng kh√¥ng c√≤n ·ªü tr·∫°ng th√°i ch·ªù.',
  PVP_ROOM_FULL: 'Ph√≤ng ƒë√£ ƒë·ªß ng∆∞·ªùi.',
  PVP_NOT_MEMBER: 'B·∫°n kh√¥ng n·∫±m trong ph√≤ng n√†y.',
  PVP_ONLY_OWNER: 'Ch·ªâ ch·ªß ph√≤ng m·ªõi ƒë∆∞·ª£c ph√©p.',
  PVP_NEED_AT_LEAST_2_PLAYERS: 'C·∫ßn t·ªëi thi·ªÉu 2 ng∆∞·ªùi ch∆°i.',
  PVP_ALL_PARTICIPANTS_MUST_READY: 'T·∫•t c·∫£ ng∆∞·ªùi ch∆°i ph·∫£i Ready.',
  PVP_NOT_YOUR_TURN: 'Ch∆∞a t·ªõi l∆∞·ª£t b·∫°n.',
  PVP_TURN_ORDER_NOT_INITIALIZED: 'Th·ª© t·ª± l∆∞·ª£t ch∆∞a kh·ªüi t·∫°o.',
  PVP_ROLL_PENDING: 'ƒêang x·ª≠ l√Ω l∆∞·ª£t tr∆∞·ªõc, vui l√≤ng ƒë·ª£i.',
  PVP_NOT_DICE_ROOM: 'Kh√¥ng ph·∫£i ph√≤ng x√∫c x·∫Øc.',
  PVP_NOT_COINFLIP_ROOM: 'Kh√¥ng ph·∫£i ph√≤ng coinflip.',
  PVP_ROOM_NOT_FINISHED: 'V√°n ch∆°i ch∆∞a k·∫øt th√∫c.',
  // Wallet
  USER_NOT_FOUND: 'Kh√¥ng t√¨m th·∫•y ng∆∞·ªùi d√πng.',
  INVALID_AMOUNT: 'S·ªë ti·ªÅn kh√¥ng h·ª£p l·ªá.',
  INSUFFICIENT_BALANCE: 'S·ªë d∆∞ kh√¥ng ƒë·ªß.',
  INSUFFICIENT_BANK_BALANCE: 'S·ªë d∆∞ ng√¢n h√†ng kh√¥ng ƒë·ªß.',
  INVALID_TRANSFER_DATA: 'D·ªØ li·ªáu chuy·ªÉn ti·ªÅn kh√¥ng h·ª£p l·ªá.',
  // General
  INTERNAL_ERROR: 'C√≥ l·ªói x·∫£y ra, vui l√≤ng th·ª≠ l·∫°i sau.',
};

export function mapErrorFromPayload(payload) {
  const code = payload?.code || 'INTERNAL_ERROR';
  let msg = payload?.message || MAP[code] || 'L·ªói kh√¥ng x√°c ƒë·ªãnh.';

  // N·∫øu l√† thi·∫øu s·ªë d∆∞ m√† BE c√≥ k√®m meta.required/have ‚Üí ch√®n v√†o message n·∫øu ch∆∞a c√≥
  if (code === 'INSUFFICIENT_BALANCE' && payload?.meta) {
    const need = payload.meta.required ?? payload.meta.need ?? payload.meta.amount;
    const have = payload.meta.have ?? payload.meta.balance;
    const hasDetail = /\bS·ªë d∆∞ c·∫ßn\b|\brequired\b|\bhave\b/i.test(msg);
    if ((need != null || have != null) && !hasDetail) {
      const lines = ['S·ªë d∆∞ kh√¥ng ƒë·ªß.'];
      if (need != null) lines.push(`S·ªë d∆∞ c·∫ßn ƒë·ªÉ th·ª±c hi·ªán: ${need}`);
      if (have != null) lines.push(`S·ªë d∆∞ hi·ªán c√≥: ${have}`);
      msg = lines.join('\n');
    }
  }

  return { code, message: msg, requestId: payload?.requestId };
}

export function mapError(e) {
  const payload = e?.__payload || e?.response?.data || e?.data || null;
  if (payload && (payload.code || payload.message)) {
    return mapErrorFromPayload(payload);
  }
  return { code: 'INTERNAL_ERROR', message: MAP.INTERNAL_ERROR, requestId: undefined };
}




=== D:\Downloads\cado4fun\client\next.config.js ===

// client/next.config.js
/** @type {import('next').NextConfig} */
module.exports = {
  async rewrites() {
    return [
      {
        source: '/api/:path*',
        destination: 'http://localhost:3001/api/:path*',
      },
    ]
  },
}



=== D:\Downloads\cado4fun\client\tailwind.config.js ===

/** @type {import('tailwindcss').Config} */
module.exports = {
  darkMode: 'class', // b·∫≠t class-based dark mode
  content: [
    './src/app/**/*.{js,ts,jsx,tsx}',
    './src/components/**/*.{js,ts,jsx,tsx}',
    './src/hooks/**/*.{js,ts,jsx,tsx}',
  ],
  theme: {
    extend: {},
  },
  plugins: [],
}




=== D:\Downloads\cado4fun\server\controllers\minigames\blackjackDiceController.js ===

// server/controllers/minigames/blackjackDiceController.js
const User = require('../../models/User')
const { randomInt } = require('../../utils/random')
const { recordGameHistory } = require('../../utils/history')

// L∆∞u state cho m·ªói user; production n√™n d√πng Redis ho·∫∑c DB
const blackjackGames = new Map()

/**
 * POST /api/game/blackjackdice/start
 * Body: { betAmount: number }
 */
exports.startBlackjackDice = async (req, res) => {
  const userId = req.user.id
  const { betAmount } = req.body

  // Kh√¥ng cho start khi v√°n ƒëang ch·∫°y
  if (blackjackGames.has(userId)) {
    return res.status(400).json({ error: 'A Blackjack Dice game is already in progress' })
  }

  // Validate betAmount
  if (typeof betAmount !== 'number' || betAmount <= 0) {
    return res.status(400).json({ error: 'Invalid betAmount' })
  }

  // Load user & check balance
  const user = await User.findById(userId)
  if (!user) return res.status(404).json({ error: 'User not found' })
  if (user.balance < betAmount) {
    return res.status(400).json({ error: 'Insufficient balance' })
  }

  // Tr·ª´ stake
  user.balance -= betAmount
  await user.save()

  // Roll 2 dice cho player v√† dealer
  const playerDice = [randomInt(1, 6), randomInt(1, 6)]
  const dealerDice = [randomInt(1, 6), randomInt(1, 6)]
  const state = {
    betAmount,
    playerDice,
    dealerDice,
    playerSum: playerDice.reduce((a, b) => a + b, 0),
    dealerSum: dealerDice.reduce((a, b) => a + b, 0),
    isActive: true
  }
  blackjackGames.set(userId, state)

  return res.json({
    playerDice,
    playerSum: state.playerSum,
    dealerVisible: [dealerDice[0], null],
    balance: user.balance
  })
}

/**
 * POST /api/game/blackjackdice/hit
 */
exports.hitBlackjackDice = async (req, res) => {
  const userId = req.user.id
  const state = blackjackGames.get(userId)
  if (!state || !state.isActive) {
    return res.status(400).json({ error: 'No active game. Call /blackjackdice/start first.' })
  }

  const newDie = randomInt(1, 6)
  state.playerDice.push(newDie)
  state.playerSum += newDie

  // Check bust (k·∫øt th√∫c v√°n -> th√™m win/amount ƒë·ªÉ b·∫Øn notification)
  if (state.playerSum > 21) {
    blackjackGames.delete(userId)
    const user = await User.findById(userId)

    await recordGameHistory({
      userId,
      game: 'blackjackdice',
      betAmount: state.betAmount,
      outcome: 'lose',
      payout: 0
    })

    return res.json({
      playerDice: state.playerDice,
      playerSum: state.playerSum,
      dealerDice: state.dealerDice,
      dealerSum: state.dealerSum,
      outcome: 'lose',
      payout: 0,
      win: false,              // ch·ªâ set khi k·∫øt th√∫c v√°n
      amount: state.betAmount, // s·ªë ti·ªÅn ng∆∞·ªùi ch∆°i ƒë√£ thua
      balance: user.balance
    })
  }

  const user = await User.findById(userId)
  return res.json({
    playerDice: state.playerDice,
    playerSum: state.playerSum,
    dealerVisible: [state.dealerDice[0], null],
    balance: user.balance
  })
}

/**
 * POST /api/game/blackjackdice/stand
 */
exports.standBlackjackDice = async (req, res) => {
  const userId = req.user.id
  const state = blackjackGames.get(userId)
  if (!state || !state.isActive) {
    return res.status(400).json({ error: 'No active game. Call /blackjackdice/start first.' })
  }

  const user = await User.findById(userId)

  let dealerSum = state.dealerSum
  while (dealerSum < state.playerSum && dealerSum <= 21) {
    const d = randomInt(1, 6)
    state.dealerDice.push(d)
    dealerSum += d
  }

  let outcome, payout
  if (dealerSum > 21) {
    outcome = 'win'
    payout  = state.betAmount * 2
    user.balance += payout
  } else if (dealerSum > state.playerSum) {
    outcome = 'lose'
    payout  = 0
  } else {
    outcome = 'tie'
    payout  = state.betAmount
    user.balance += payout
  }

  await user.save()
  blackjackGames.delete(userId)

  await recordGameHistory({
    userId,
    game: 'blackjackdice',
    betAmount: state.betAmount,
    outcome,
    payout
  })

  // Ch·ªâ th√™m win/amount khi KH√îNG ph·∫£i tie (tr√°nh b·∫Øn "loss" nh·∫ßm)
  const response = {
    playerDice: state.playerDice,
    playerSum: state.playerSum,
    dealerDice: state.dealerDice,
    dealerSum,
    outcome,
    payout,
    balance: user.balance
  }

  if (outcome === 'win') {
    response.win = true
    response.amount = payout          // s·ªë ti·ªÅn th·∫Øng th·ª±c t·∫ø
  } else if (outcome === 'lose') {
    response.win = false
    response.amount = state.betAmount // s·ªë ti·ªÅn ƒë√£ thua
  }
  // outcome === 'tie' -> KH√îNG set win/amount ƒë·ªÉ wrapper b·ªè qua

  return res.json(response)
}

/**
 * POST /api/game/blackjackdice/check
 */
exports.checkBlackjackDice = async (req, res) => {
  const userId = req.user.id
  const state = blackjackGames.get(userId)
  if (!state || !state.isActive) {
    return res.json({ active: false })
  }
  return res.json({
    active: true,
    state: {
      playerDice: state.playerDice,
      playerSum: state.playerSum,
      dealerVisible: [state.dealerDice[0], null],
      balance: (await User.findById(userId)).balance
    }
  })
}

/**
 * POST /api/game/blackjackdice/abandon
 */
exports.abandonBlackjackDice = async (req, res) => {
  const userId = req.user.id
  const state = blackjackGames.get(userId)

  if (!state || !state.isActive) {
    return res.status(400).json({ error: 'No active game to abandon' })
  }

  blackjackGames.delete(userId)
  return res.json({ message: 'Game abandoned successfully' })
}

/**
 * POST /api/game/blackjackdice/resume
 */
exports.resumeBlackjackDice = async (req, res) => {
  const userId = req.user.id
  const state = blackjackGames.get(userId)

  if (!state || !state.isActive) {
    return res.status(400).json({ error: 'No active game to resume' })
  }

  return res.json({
    playerDice: state.playerDice,
    playerSum: state.playerSum,
    dealerVisible: [state.dealerDice[0], null],
    balance: (await User.findById(userId)).balance
  })
}




=== D:\Downloads\cado4fun\server\controllers\minigames\coinflipController.js ===

// server/controllers/minigames/coinflipController.js
const User = require('../../models/User');
const { recordGameHistory } = require('../../utils/history');
const fair = require('../../utils/fair');

/**
 * POST /api/game/coinflip
 * Body: { betAmount: number, side: 'heads' | 'tails', clientSeed?: string }
 * Solo d√πng Provably Fair:
 *   - commit: seedHash = sha256(serverSeed hi·ªán t·∫°i)
 *   - rng:    HMAC_SHA256(serverSeed, `${clientSeed}:${nonce}`)
 *   - reveal: tr·∫£ serverSeed + clientSeed + nonce ƒë·ªÉ user verify
 */
exports.coinflip = async (req, res) => {
  try {
    const userId = req.user.id;
    const { betAmount, side, clientSeed: rawClientSeed } = req.body || {};

    // Validate inputs
    if (typeof betAmount !== 'number' || betAmount <= 0) {
      return res.status(400).json({ error: 'Invalid bet amount' });
    }
    if (!['heads', 'tails'].includes(side)) {
      return res.status(400).json({ error: 'Side must be "heads" or "tails"' });
    }

    // Load user & balance check
    const user = await User.findById(userId);
    if (!user) return res.status(404).json({ error: 'User not found' });
    if (user.balance < betAmount) {
      return res.status(400).json({ error: 'Insufficient balance' });
    }

    // === Provably Fair commit‚Äìreveal (solo) ===
    const serverSeed = fair.getActiveServerSeed(); // commit seed (ƒëang d√πng)
    const seedHash   = fair.getSeedHash();         // sha256(serverSeed), show cho user
    const nonce      = Date.now().toString();      // m·ªói v√°n 1 nonce (b·∫°n c√≥ th·ªÉ d√πng counter, UUID,...)
    const clientSeed = String(rawClientSeed || userId);

    // RNG
    const flip = fair.coinflip({ serverSeed, clientSeed, nonce });
    const win  = flip === side;

    // Balance update
    const payout = win ? betAmount : 0;
    const delta  = win ? betAmount : -betAmount;
    user.balance += delta;
    await user.save();

    // History
    await recordGameHistory({
      userId,
      game: 'coinflip',
      betAmount,
      outcome: win ? 'win' : 'lose',
      payout,
    });

    // Response (amount = abs(delta) ƒë·ªÉ withNotification wrapper d√πng)
    return res.json({
      message: win
        ? `You won! The coin showed ${flip}.`
        : `You lost. The coin showed ${flip}.`,
      result: flip,
      win,
      payout,
      amount: Math.abs(delta),
      balance: user.balance,
      // verify data
      seedHash,    // commit
      serverSeed,  // reveal (solo tr·∫£ lu√¥n)
      clientSeed,
      nonce,
    });
  } catch (err) {
    console.error(err);
    return res.status(500).json({ error: 'Server error' });
  }
};




=== D:\Downloads\cado4fun\server\controllers\minigames\diceController.js ===

// server/controllers/minigames/diceController.js
const User = require('../../models/User');
const { recordGameHistory } = require('../../utils/history');
const fair = require('../../utils/fair');

// Supported dice sides and multipliers
const ALLOWED_SIDES = [4, 6, 8, 10, 12, 20];
const MULTIPLIERS   = { 4: 2, 6: 3, 8: 4, 10: 5, 12: 6, 20: 10 };

/**
 * POST /api/game/dice
 * Body: { betAmount: number, sides?: number (default 6), guess: number, clientSeed?: string }
 * Provably Fair:
 *   result = floor(hmacFloat(serverSeed, `${clientSeed}:${nonce}`) * sides) + 1
 *   server tr·∫£ seedHash + serverSeed + clientSeed + nonce ƒë·ªÉ verify (UI kh√¥ng c·∫ßn hi·ªÉn th·ªã).
 */
exports.dice = async (req, res) => {
  try {
    const userId = req.user.id;
    const { betAmount, sides = 6, guess, clientSeed: rawClientSeed } = req.body || {};

    // Validate betAmount
    if (typeof betAmount !== 'number' || betAmount <= 0) {
      return res.status(400).json({ error: 'Invalid betAmount' });
    }
    // Validate sides
    if (typeof sides !== 'number' || !ALLOWED_SIDES.includes(sides)) {
      return res.status(400).json({ error: `sides must be one of ${ALLOWED_SIDES.join(', ')}` });
    }
    // Validate guess
    if (typeof guess !== 'number' || guess < 1 || guess > sides) {
      return res.status(400).json({ error: `guess must be between 1 and ${sides}` });
    }

    // Load user and check balance
    const user = await User.findById(userId);
    if (!user) return res.status(404).json({ error: 'User not found' });
    if (user.balance < betAmount) {
      return res.status(400).json({ error: 'Insufficient balance' });
    }

    // === Provably Fair commit‚Äìreveal ===
    const serverSeed = fair.getActiveServerSeed(); // commit seed hi·ªán h√†nh
    const seedHash   = fair.getSeedHash();         // sha256(serverSeed) ƒë·ªÉ verify
    const nonce      = Date.now().toString();      // m·ªói v√°n 1 nonce
    const clientSeed = String(rawClientSeed || userId);

    // PF roll: 1..sides
    const rollFloat = fair.hmacFloat({ serverSeed, clientSeed, nonce });
    const result    = Math.floor(rollFloat * sides) + 1;

    const win        = result === guess;
    const multiplier = MULTIPLIERS[sides];
    const payout     = win ? betAmount * multiplier : 0;

    // Update balance (delta = payout - bet)
    const delta = win ? (payout - betAmount) : -betAmount;
    user.balance += delta;
    await user.save();

    // History
    await recordGameHistory({
      userId, game: 'dice', betAmount,
      outcome: win ? 'win' : 'lose', payout
    });

    // Respond (UI kh√¥ng c·∫ßn show verify; nh∆∞ng tr·∫£ ra ƒë·ªÉ c√≥ th·ªÉ ki·ªÉm tra)
    return res.json({
      message: win
        ? `You won! You rolled ${result} on a d${sides}, payout ${payout}.`
        : `You lost. You rolled ${result} on a d${sides}.`,
      result, sides, win, multiplier, payout,
      amount: win ? (payout - betAmount) : betAmount, // for notifications
      balance: user.balance,
      // verify data (·∫©n tr√™n UI)
      seedHash, serverSeed, clientSeed, nonce,
    });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: 'Server error' });
  }
};




=== D:\Downloads\cado4fun\server\controllers\minigames\dicePokerController.js ===

// server/controllers/minigames/dicePokerController.js
const User                 = require('../../models/User')
const { randomInt }        = require('../../utils/random')
const { recordGameHistory } = require('../../utils/history')

// Multiplier table by poker hand
const HAND_MULTIPLIERS = {
  'Five of a Kind': 20,
  'Four of a Kind': 10,
  'Full House':      8,
  'Straight':        5,
  'Three of a Kind': 3,
  'Two Pair':        2,
  'One Pair':        1,
  'High Card':       0
}

/**
 * Determine poker hand from an array of 5 dice.
 * @param {number[]} dice
 * @returns {string}
 */
function evaluateHand(dice) {
  const counts = {}
  dice.forEach(d => counts[d] = (counts[d] || 0) + 1)
  const freqs = Object.values(counts).sort((a, b) => b - a)

  if (freqs[0] === 5) return 'Five of a Kind'
  if (freqs[0] === 4) return 'Four of a Kind'
  if (freqs[0] === 3 && freqs[1] === 2) return 'Full House'

  const sorted = Array.from(new Set(dice)).sort((a, b) => a - b)
  const straight1 = [1,2,3,4,5]
  const straight2 = [2,3,4,5,6]
  if (sorted.length === 5 &&
      (straight1.every((v,i) => sorted[i] === v) ||
       straight2.every((v,i) => sorted[i] === v))) {
    return 'Straight'
  }

  if (freqs[0] === 3) return 'Three of a Kind'
  if (freqs[0] === 2 && freqs[1] === 2) return 'Two Pair'
  if (freqs[0] === 2) return 'One Pair'

  return 'High Card'
}

/**
 * POST /api/game/dicepoker
 * Body: { betAmount: number }
 */
exports.dicePoker = async (req, res) => {
  try {
    const userId     = req.user.id
    const { betAmount } = req.body

    // Validate bet amount
    if (typeof betAmount !== 'number' || betAmount <= 0) {
      return res.status(400).json({ error: 'Invalid betAmount' })
    }

    // Load user and check balance
    const user = await User.findById(userId)
    if (!user)    return res.status(404).json({ error: 'User not found' })
    if (user.balance < betAmount) {
      return res.status(400).json({ error: 'Insufficient balance' })
    }

    // Roll 5 dice
    const dice = Array.from({ length: 5 }, () => randomInt(1, 6))

    // Evaluate hand and get multiplier
    const hand       = evaluateHand(dice)
    const multiplier = HAND_MULTIPLIERS[hand] || 0

    // Calculate payout and update balance
    const payout = betAmount * multiplier
    user.balance = user.balance - betAmount + payout
    await user.save()

    // Determine outcome
    const outcome = multiplier > 0 ? 'win' : 'lose'

    // Record to game history
    await recordGameHistory({ userId, game: 'dicepoker', betAmount, outcome, payout })

    // Send response
    return res.json({
      hand,
      dice,
      multiplier,
      payout,
      win: amount => outcome === 'win',
      amount: outcome === 'win' ? payout : betAmount,
      balance: user.balance
    })
  } catch (err) {
    console.error(err)
    return res.status(500).json({ error: 'Server error' })
  }
}




=== D:\Downloads\cado4fun\server\controllers\minigames\higherLowerController.js ===

// server/controllers/minigames/higherLowerController.js
const User                  = require('../../models/User')
const { randomInt }         = require('../../utils/random')
const { recordGameHistory } = require('../../utils/history')

const MIN_NUMBER      = 1
const MAX_NUMBER      = 20
const MULTIPLIER_STEP = 0.5
const DEFAULT_INITIAL = 10

/**
 * POST /api/game/higherlower
 * Body: { betAmount: number, guess: 'higher'|'lower' }
 */
exports.higherLower = async (req, res) => {
  try {
    const userId = req.user.id
    const { betAmount, guess } = req.body

    // Validate inputs
    if (typeof betAmount !== 'number' || betAmount <= 0) {
      return res.status(400).json({ error: 'Invalid betAmount' })
    }
    if (!['higher','lower'].includes(guess)) {
      return res.status(400).json({ error: 'guess must be "higher" or "lower"' })
    }

    // Load user and check balance
    const user = await User.findById(userId)
    if (!user) return res.status(404).json({ error: 'User not found' })
    if (user.balance < betAmount) {
      return res.status(400).json({ error: 'Insufficient balance' })
    }

    // Determine initial number
    const initial = typeof user.higherLowerLastNumber === 'number'
      ? user.higherLowerLastNumber
      : DEFAULT_INITIAL

    // Roll next number
    const next = randomInt(MIN_NUMBER, MAX_NUMBER)

    // Check outcome
    let win = false, tie = false
    if (next === initial) {
      tie = true
    } else if ((guess === 'higher' && next > initial) || (guess === 'lower' && next < initial)) {
      win = true
    }

    // Compute payout and update streak/balance
    let payout = 0
    if (tie) {
      user.higherLowerStreak = 0
    } else if (win) {
      user.higherLowerStreak = (user.higherLowerStreak || 0) + 1
      const multiplier = user.higherLowerStreak * MULTIPLIER_STEP
      payout = betAmount * multiplier
      user.balance += payout
    } else {
      // lose
      user.higherLowerStreak = 0
      user.balance -= betAmount
    }

    // Save last number for next round
    user.higherLowerLastNumber = next
    await user.save()

    // Determine outcome label
    const outcome = tie ? 'tie' : win ? 'win' : 'lose'

    // Record to game history
    await recordGameHistory({ userId, game: 'higherlower', betAmount, outcome, payout })

    // T√≠nh amount cho notification: n·∫øu th·∫Øng l·∫•y payout, kh√¥ng th·∫Øng l·∫•y betAmount
    const amount = win ? payout : betAmount

    // Send response
    return res.json({
      message: tie
        ? `Tie! Both were ${initial}.`
        : win
          ? `You won! ${initial} ‚Üí ${next}, streak ${user.higherLowerStreak}, payout ${payout}.`
          : `You lost. ${initial} ‚Üí ${next}.`,
      initial,
      result: next,
      guess,
      tie,
      win,
      streak: user.higherLowerStreak,
      payout,
      amount,              // ‚Üê th√™m tr∆∞·ªùng amount
      balance: user.balance
    })
  } catch (err) {
    console.error(err)
    return res.status(500).json({ error: 'Server error' })
  }
}




=== D:\Downloads\cado4fun\server\controllers\minigames\luckyFiveController.js ===

// server/controllers/minigames/luckyFiveController.js
const User                  = require('../../models/User');
const { randomInt }         = require('../../utils/random');
const { recordGameHistory } = require('../../utils/history');

const NUMBER_MIN     = 1;
const NUMBER_MAX     = 100;
const DRAW_COUNT     = 5;
const ALLOWED_COLORS = ['red','orange','yellow','green','blue'];

// Payout multipliers for number matches
const numberMultipliers = { 1:1, 2:2, 3:4, 4:8, 5:16 };
// Payout multipliers for color matches
const colorMultipliers  = { 0:0, 1:0.5, 2:1, 3:2, 4:4, 5:8 };

/**
 * POST /api/game/luckyfive
 * Body: { betAmount: number, numbers: number[5], colors: string[5] }
 */
exports.luckyFive = async (req, res) => {
  try {
    const userId = req.user.id;
    const { betAmount, numbers, colors } = req.body;

    // Validate betAmount
    if (typeof betAmount !== 'number' || betAmount <= 0) {
      return res.status(400).json({ error: 'Invalid betAmount' });
    }
    // Validate numbers array
    if (!Array.isArray(numbers) || numbers.length !== DRAW_COUNT ||
        !numbers.every(n => Number.isInteger(n) && n >= NUMBER_MIN && n <= NUMBER_MAX)) {
      return res.status(400).json({
        error: `numbers must be ${DRAW_COUNT} integers between ${NUMBER_MIN} and ${NUMBER_MAX}`
      });
    }
    // Validate colors array
    if (!Array.isArray(colors) || colors.length !== DRAW_COUNT ||
        !colors.every(c => ALLOWED_COLORS.includes(c))) {
      return res.status(400).json({
        error: `colors must be ${DRAW_COUNT} strings from [${ALLOWED_COLORS.join(',')}]`
      });
    }

    // Load user and check balance
    const user = await User.findById(userId);
    if (!user)    return res.status(404).json({ error: 'User not found' });
    if (user.balance < betAmount) {
      return res.status(400).json({ error: 'Insufficient balance' });
    }

    // Draw unique numbers
    const drawnNumbers = [];
    while (drawnNumbers.length < DRAW_COUNT) {
      const n = randomInt(NUMBER_MIN, NUMBER_MAX);
      if (!drawnNumbers.includes(n)) drawnNumbers.push(n);
    }
    // Draw colors
    const drawnColors = Array.from({ length: DRAW_COUNT }, () =>
      ALLOWED_COLORS[randomInt(0, ALLOWED_COLORS.length - 1)]
    );

    // Count matches
    const numberMatches = numbers.filter(n => drawnNumbers.includes(n)).length;
    let colorMatches = 0;
    colors.forEach((c,i) => { if (c === drawnColors[i]) colorMatches++; });

    // Calculate payouts
    const payoutNumber = betAmount * (numberMultipliers[numberMatches] || 0);
    const payoutColor  = betAmount * (colorMultipliers[colorMatches] || 0);
    const totalPayout  = payoutNumber + payoutColor;

    // Update balance
    user.balance = user.balance - betAmount + totalPayout;
    await user.save();

    // Determine outcome
    const win = totalPayout > 0;
    const outcome = win ? 'win' : 'lose';

    // Record history
    await recordGameHistory({
      userId,
      game: 'luckyfive',
      betAmount,
      outcome,
      payout: totalPayout
    });

    // Send response (th√™m win + amount cho notification wrapper)
    return res.json({
      message: win
        ? `You won! Numbers matched: ${numberMatches} (+${payoutNumber}), Colors matched: ${colorMatches} (+${payoutColor}), total ${totalPayout}.`
        : `You lost. Numbers matched: ${numberMatches}, Colors matched: ${colorMatches}.`,
      result: { numbers: drawnNumbers, colors: drawnColors },
      matches: { numberMatches, colorMatches },
      payouts: { payoutNumber, payoutColor, totalPayout },
      win,                                   // ‚Üê th√™m
      amount: win ? totalPayout : betAmount, // ‚Üê th√™m
      balance: user.balance
    });
  } catch (err) {
    console.error(err);
    return res.status(500).json({ error: 'Server error' });
  }
};




=== D:\Downloads\cado4fun\server\controllers\minigames\minesController.js ===

// server/controllers/minigames/minesController.js
const User                  = require('../../models/User');
const { randomInt }         = require('../../utils/random');
const { recordGameHistory } = require('../../utils/history');

const ROWS        = 15;
const COLS        = 15;
const TOTAL_CELLS = ROWS * COLS;  // 225 cells
const MINE_COUNT  = 40;
const MAX_PICKS   = 10;

// Multipliers by how many safe picks
const MULTIPLIERS = {
   0:  0, 1:  0.5, 2:  0.75, 3:  1, 4: 1.5,
   5:  2, 6:  3,    7:  4,    8:  5, 9:   8,
  10: 10
};

// In-memory game state (for production use Redis/DB)
const games = new Map();

/**
 * POST /api/game/mines/start
 * Body: { betAmount: number }
 */
exports.startMines = async (req, res) => {
  const userId    = req.user.id;
  const { betAmount } = req.body;

  if (games.has(userId)) {
    return res.status(400).json({ error: 'A game is already in progress' });
  }
  if (typeof betAmount !== 'number' || betAmount <= 0) {
    return res.status(400).json({ error: 'Invalid betAmount' });
  }

  const user = await User.findById(userId);
  if (!user)    return res.status(404).json({ error: 'User not found' });
  if (user.balance < betAmount) {
    return res.status(400).json({ error: 'Insufficient balance' });
  }

  // Hold stake
  user.balance -= betAmount;
  await user.save();

  // Place mines
  const mines = new Set();
  while (mines.size < MINE_COUNT) {
    mines.add(randomInt(0, TOTAL_CELLS - 1));
  }

  games.set(userId, { betAmount, mines, picks: new Set() });

  return res.json({ message: 'Game started', maxPicks: MAX_PICKS, balance: user.balance });
};

/**
 * POST /api/game/mines/pick
 * Body: { index: number }
 */
exports.pickMines = async (req, res) => {
  const userId = req.user.id;
  const { index } = req.body;
  const state = games.get(userId);
  if (!state) {
    return res.status(400).json({ error: 'No active game. Call /mines/start first.' });
  }

  if (!Number.isInteger(index) || index < 0 || index >= TOTAL_CELLS) {
    return res.status(400).json({ error: `index must be 0..${TOTAL_CELLS - 1}` });
  }
  if (state.picks.has(index)) {
    return res.status(400).json({ error: 'Cell already picked' });
  }

  state.picks.add(index);
  const user = await User.findById(userId);

  // Hit a mine -> k·∫øt th√∫c (thua)
  if (state.mines.has(index)) {
    games.delete(userId);
    const payout = 0;
    // Record history
    await recordGameHistory({
      userId, game: 'mines', betAmount: state.betAmount, outcome: 'lose', payout
    });
    return res.json({
      message: `Boom! You hit a mine on pick #${state.picks.size}.`,
      mined: true,
      pickCount: state.picks.size,
      payout,
      win: false,                 // ‚Üê th√™m cho notification wrapper
      amount: state.betAmount,    // ‚Üê s·ªë ti·ªÅn b·ªã m·∫•t
      balance: user.balance
    });
  }

  const pickCount = state.picks.size;
  // Cleared all picks -> k·∫øt th√∫c (th·∫Øng)
  if (pickCount >= MAX_PICKS) {
    const multiplier = MULTIPLIERS[pickCount] || 0;
    const payout     = state.betAmount * multiplier;
    user.balance    += payout;
    await user.save();
    games.delete(userId);
    // Record history
    await recordGameHistory({
      userId, game: 'mines', betAmount: state.betAmount, outcome: 'win', payout
    });
    return res.json({
      message: `You cleared all ${MAX_PICKS} picks!`,
      mined: false,
      pickCount,
      multiplier,
      payout,
      win: true,          // ‚Üê th√™m cho notification wrapper
      amount: payout,     // ‚Üê s·ªë ti·ªÅn th·∫Øng
      balance: user.balance
    });
  }

  // Continue game (ƒë·ª´ng th√™m win/amount ƒë·ªÉ tr√°nh b·∫Øn notify)
  return res.json({
    message: `Safe! You have picked ${pickCount}/${MAX_PICKS}.`,
    mined: false,
    pickCount,
    balance: user.balance
  });
};




=== D:\Downloads\cado4fun\server\controllers\minigames\rouletteController.js ===

// server/controllers/minigames/rouletteController.js
const User                  = require('../../models/User');
const { randomInt }         = require('../../utils/random');
const { recordGameHistory } = require('../../utils/history');

// Payout multipliers
const MULTIPLIER_ZERO  = 16;  // for 0 (green)
const MULTIPLIER_RANGE = 4;   // for ranges 1‚Äì9, 10‚Äì18, 19‚Äì27, 28‚Äì36
const MULTIPLIER_COLOR = 2;   // for red/black

/**
 * POST /api/game/roulette
 * Body: {
 *   betAmount: number,
 *   betType: 'zero'|'range'|'color',
 *   betValue: number|string  // if 'range': '1-9'|'10-18'|'19-27'|'28-36'; if 'color': 'red'|'black'; if 'zero': ignored
 * }
 */
exports.roulette = async (req, res) => {
  try {
    const userId       = req.user.id;
    const { betAmount, betType, betValue } = req.body;

    // 1. Validate betAmount
    if (typeof betAmount !== 'number' || betAmount <= 0) {
      return res.status(400).json({ error: 'Invalid bet amount' });
    }

    // 2. Validate betType and betValue
    if (betType === 'range') {
      const validRanges = ['1-9','10-18','19-27','28-36'];
      if (typeof betValue !== 'string' || !validRanges.includes(betValue)) {
        return res.status(400).json({ error: 'betValue must be one of ' + validRanges.join(', ') });
      }
    } else if (betType === 'color') {
      if (!['red', 'black'].includes(betValue)) {
        return res.status(400).json({ error: 'betValue must be "red" or "black"' });
      }
    } else if (betType !== 'zero') {
      return res.status(400).json({ error: 'betType must be "zero", "range" or "color"' });
    }

    // 3. Load user and check balance
    const user = await User.findById(userId);
    if (!user) {
      return res.status(404).json({ error: 'User not found' });
    }
    if (user.balance < betAmount) {
      return res.status(400).json({ error: 'Insufficient balance' });
    }

    // 4. Spin wheel
    const spinResult = randomInt(0, 36);
    let spinColor;
    if (spinResult === 0) {
      spinColor = 'green';
    } else if (spinResult % 2 === 0) {
      spinColor = 'black';
    } else {
      spinColor = 'red';
    }

    // 5. Check win and calculate payout
    let win    = false;
    let payout = 0;

    if (betType === 'zero' && spinResult === 0) {
      win    = true;
      payout = betAmount * MULTIPLIER_ZERO;
    } else if (betType === 'range') {
      const [min, max] = betValue.split('-').map(Number);
      if (spinResult >= min && spinResult <= max) {
        win    = true;
        payout = betAmount * MULTIPLIER_RANGE;
      }
    } else if (betType === 'color' && spinColor === betValue) {
      win    = true;
      payout = betAmount * MULTIPLIER_COLOR;
    }

    // 6. Update balance
    if (win) {
      user.balance += payout;
    } else {
      user.balance -= betAmount;
    }
    await user.save();

    // 7. Record to game history
    await recordGameHistory({
      userId,
      game: 'roulette',
      betAmount,
      outcome: win ? 'win' : 'lose',
      payout:  win ? payout : 0
    });

    // 8. Respond (add `amount` for notification wrapper)
    return res.json({
      message: win
        ? `You won! The wheel landed on ${spinResult} (${spinColor}), payout ${payout}.`
        : `You lost. The wheel landed on ${spinResult} (${spinColor}).`,
      result: { number: spinResult, color: spinColor },
      win,
      payout,
      amount: win ? payout : betAmount, // ‚Üê added: used by withNotification()
      balance: user.balance
    });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: 'Server error' });
  }
};




=== D:\Downloads\cado4fun\server\controllers\minigames\slotsController.js ===

// server/controllers/minigames/slotsController.js
const User                  = require('../../models/User');
const { randomInt }         = require('../../utils/random');
const { recordGameHistory } = require('../../utils/history');

// Danh s√°ch 9 symbol v√† multiplier (2√ó) cho 3-of-a-kind
const SYMBOLS = [
  { name: 'cherry',     emoji: 'üçí', multiplier: 1.25 },
  { name: 'lemon',      emoji: 'üçã', multiplier: 1.5  },
  { name: 'watermelon', emoji: 'üçâ', multiplier: 2    },
  { name: 'heart',      emoji: '‚ù§Ô∏è', multiplier: 3    },
  { name: 'bell',       emoji: 'üîî', multiplier: 4    },
  { name: 'diamond',    emoji: 'üíé', multiplier: 5    },
  { name: 'seven',      emoji: '7Ô∏è‚É£', multiplier: 8    },
  { name: 'horseshoe',  emoji: 'üê¥', multiplier: 10   },
  { name: 'money',      emoji: 'üí∞', multiplier: 20   }
];

// T·∫•t c·∫£ ƒë∆∞·ªùng c·∫ßn ki·ªÉm tra 3-of-a-kind
const LINES = [
  [[0,0],[0,1],[0,2]],
  [[1,0],[1,1],[1,2]],
  [[2,0],[2,1],[2,2]],
  [[0,0],[1,0],[2,0]],
  [[0,1],[1,1],[2,1]],
  [[0,2],[1,2],[2,2]],
  [[0,0],[1,1],[2,2]],
  [[0,2],[1,1],[2,0]]
];

/**
 * POST /api/game/slots
 * Body: { betAmount: number }
 */
exports.slots = async (req, res) => {
  try {
    const userId       = req.user.id;
    const { betAmount } = req.body;

    // 1. Validate betAmount
    if (typeof betAmount !== 'number' || betAmount <= 0) {
      return res.status(400).json({ error: 'Invalid betAmount' });
    }

    // 2. Load user & check balance
    const user = await User.findById(userId);
    if (!user)    return res.status(404).json({ error: 'User not found' });
    if (user.balance < betAmount) {
      return res.status(400).json({ error: 'Insufficient balance' });
    }

    // 3. Tr·ª´ stake ngay
    user.balance -= betAmount;

    // 4. T·∫°o ma tr·∫≠n 3x3
    const grid = [[], [], []];
    for (let r = 0; r < 3; r++) {
      for (let c = 0; c < 3; c++) {
        grid[r][c] = SYMBOLS[randomInt(0, SYMBOLS.length - 1)];
      }
    }

    // 5. Ki·ªÉm tra t·∫•t c·∫£ ƒë∆∞·ªùng LINES v√† c·ªông multiplier
    let totalMultiplier = 0;
    const winningLines  = [];

    LINES.forEach(line => {
      const [a,b,c] = line;
      const symA = grid[a[0]][a[1]].name;
      const symB = grid[b[0]][b[1]].name;
      const symC = grid[c[0]][c[1]].name;
      if (symA === symB && symA === symC) {
        totalMultiplier += grid[a[0]][a[1]].multiplier;
        winningLines.push(line);
      }
    });

    // 6. T√≠nh payout v√† c·∫≠p nh·∫≠t balance
    const payout = betAmount * totalMultiplier;
    user.balance += payout;
    await user.save();

    // 7. Record to game history
    await recordGameHistory({
      userId,
      game: 'slots',
      betAmount,
      outcome: totalMultiplier > 0 ? 'win' : 'lose',
      payout
    });

    // 8. Chu·∫©n b·ªã response (th√™m `amount` cho withNotification)
    const emojiGrid = grid.map(row => row.map(cell => cell.emoji));
    const win = totalMultiplier > 0;

    return res.json({
      grid: emojiGrid,
      win,
      totalMultiplier,
      payout,
      amount: win ? payout : betAmount, // ‚Üê th√™m ƒë·ªÉ wrapper ƒë·ªçc
      balance: user.balance,
      winningLines
    });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: 'Server error' });
  }
};




=== D:\Downloads\cado4fun\server\controllers\minigames\towerController.js ===

// server/controllers/minigames/towerController.js
const User                  = require('../../models/User');
const { recordGameHistory } = require('../../utils/history');

const SUCCESS_PROB      = 0.5;  // 50% chance to ascend
const MAX_LEVEL         = 15;
const LEVEL_MULTIPLIERS = {
   1:1,   2:1.25, 3:1.5,  4:2,   5:3,
   6:4,   7:5,    8:6,    9:7,  10:8,
  11:9,  12:10,  13:15,  14:20, 15:50
};

// In-memory state (production n√™n d√πng Redis/DB)
const towerGames = new Map();

/**
 * POST /api/game/tower/start
 * Body: { betAmount: number }
 */
exports.startTower = async (req, res) => {
  const userId    = req.user.id;
  const { betAmount } = req.body;

  // Already playing?
  if (towerGames.has(userId)) {
    return res.status(400).json({ error: 'A tower game is already in progress' });
  }
  // Validate bet
  if (typeof betAmount !== 'number' || betAmount <= 0) {
    return res.status(400).json({ error: 'Invalid betAmount' });
  }

  // Load user & check balance
  const user = await User.findById(userId);
  if (!user)    return res.status(404).json({ error: 'User not found' });
  if (user.balance < betAmount) {
    return res.status(400).json({ error: 'Insufficient balance' });
  }

  // Hold stake
  user.balance -= betAmount;
  await user.save();

  // Init game
  towerGames.set(userId, { betAmount, currentLevel: 0 });

  return res.json({
    message: 'Tower game started',
    currentLevel: 0,
    balance: user.balance
  });
};

/**
 * POST /api/game/tower/ascend
 * Body: {}
 */
exports.ascendTower = async (req, res) => {
  const userId = req.user.id;
  const state  = towerGames.get(userId);
  if (!state) {
    return res.status(400).json({ error: 'No active tower game. Call /tower/start first.' });
  }

  const user = await User.findById(userId);
  if (!user) return res.status(404).json({ error: 'User not found' });

  const success = Math.random() < SUCCESS_PROB;
  // Bust: lose everything (k·∫øt th√∫c v√°n -> th√™m win & amount)
  if (!success) {
    towerGames.delete(userId);
    // Record loss
    await recordGameHistory({
      userId,
      game: 'tower',
      betAmount: state.betAmount,
      outcome: 'lose',
      payout: 0
    });
    return res.json({
      message: `You busted at level ${state.currentLevel + 1}.`,
      bustedLevel: state.currentLevel + 1,
      payout: 0,
      balance: user.balance,
      win: false,
      amount: state.betAmount // ƒë·ªÉ wrapper b·∫Øn "game_loss"
    });
  }

  // Ascend
  state.currentLevel++;
  // Auto-cashout at max (k·∫øt th√∫c v√°n -> th√™m win & amount)
  if (state.currentLevel >= MAX_LEVEL) {
    const multiplier = LEVEL_MULTIPLIERS[MAX_LEVEL];
    const payout     = state.betAmount * multiplier;
    user.balance += payout;
    await user.save();
    towerGames.delete(userId);
    // Record win
    await recordGameHistory({
      userId,
      game: 'tower',
      betAmount: state.betAmount,
      outcome: 'win',
      payout
    });
    return res.json({
      message: `Congratulations! You reached level ${MAX_LEVEL}.`,
      level: MAX_LEVEL,
      multiplier,
      payout,
      balance: user.balance,
      win: true,
      amount: payout // ƒë·ªÉ wrapper b·∫Øn "game_win"
    });
  }

  // Continue playing (ch∆∞a k·∫øt th√∫c -> KH√îNG th√™m win/amount)
  return res.json({
    message: `Success! You are now at level ${state.currentLevel}.`,
    currentLevel: state.currentLevel,
    balance: user.balance
  });
};

/**
 * POST /api/game/tower/cashout
 * Body: {}
 */
exports.cashoutTower = async (req, res) => {
  const userId = req.user.id;
  const state  = towerGames.get(userId);
  if (!state) {
    return res.status(400).json({ error: 'No active tower game. Call /tower/start first.' });
  }

  const user = await User.findById(userId);
  if (!user) return res.status(404).json({ error: 'User not found' });

  const level      = state.currentLevel;
  const multiplier = LEVEL_MULTIPLIERS[level] || 0;
  const payout     = state.betAmount * multiplier;

  // Payout & end game
  user.balance += payout;
  await user.save();
  towerGames.delete(userId);

  // Record win
  await recordGameHistory({
    userId,
    game: 'tower',
    betAmount: state.betAmount,
    outcome: 'win',
    payout
  });

  return res.json({
    message: `You cashed out at level ${level}.`,
    level,
    multiplier,
    payout,
    balance: user.balance,
    win: true,
    amount: payout // ƒë·ªÉ wrapper b·∫Øn "game_win"
  });
};




=== D:\Downloads\cado4fun\server\controllers\pvp\coinflip.js ===

// server/controllers/pvp/coinflip.js
const User = require('../../models/User');
const { makeServerSeed, sha256, coinflip } = require('../../utils/fair');
const { recordGameHistory } = require('../../utils/history');

const OPP = { heads: 'tails', tails: 'heads' };

function normalizeSide(s) {
  const v = String(s || '').toLowerCase();
  if (v !== 'heads' && v !== 'tails') throw new Error('Invalid coin side');
  return v;
}

// Khi t·∫°o ph√≤ng: √©p 2 ng∆∞·ªùi, l∆∞u side ch·ªß ph√≤ng + commit fair seed
exports.prepareCreate = ({ ownerId, body }) => {
  const side = normalizeSide(body.coinflipSide || body.side || 'heads');
  const serverSeed = makeServerSeed();
  const seedHash = sha256(serverSeed);

  return {
    maxPlayers: 2,
    metadata: {
      coinflip: {
        sides: { [String(ownerId)]: side }, // map userId -> side
        fair: { serverSeed, seedHash, nonce: 0 }, // serverSeed ·∫©n cho t·ªõi khi k·∫øt th√∫c
        result: null,
      },
    },
  };
};

// Khi ng∆∞·ªùi kh√°c join: auto nh·∫≠n m·∫∑t c√≤n l·∫°i
exports.onJoin = ({ room, joinerId }) => {
  if (room.game !== 'coinflip') return;
  const cf = room.metadata?.coinflip || {};
  const hostId = String(room.createdBy);
  const hostSide = cf.sides?.[hostId];
  if (!hostSide) return;

  cf.sides = cf.sides || {};
  const joinerKey = String(joinerId);
  if (!cf.sides[joinerKey]) {
    cf.sides[joinerKey] = OPP[hostSide];
  }
  room.metadata = { ...(room.metadata || {}), coinflip: cf };
};

// ƒêi·ªÅu ki·ªán ri√™ng ƒë·ªÉ start
exports.canStart = (room) => {
  if (room.players?.length !== 2) return false;
  const cf = room.metadata?.coinflip;
  if (!cf?.sides) return false;
  const [p1, p2] = room.players.map(p => String(p.userId));
  const s1 = cf.sides[p1], s2 = cf.sides[p2];
  return (s1 && s2 && s1 !== s2);
};

// Settle: flip ‚Üí chuy·ªÉn ti·ªÅn ‚Üí ghi l·ªãch s·ª≠ ‚Üí ƒë√≥ng ph√≤ng
exports.settle = async (room) => {
  const cf = room.metadata.coinflip;
  const [p1, p2] = room.players.map(p => String(p.userId));
  const bet = Number(room.betAmount) || 0;

  // Ki·ªÉm tra s·ªë d∆∞ ƒë·ªß ƒë·∫∑t c·ªçc
  const [u1, u2] = await Promise.all([User.findById(p1), User.findById(p2)]);
  if (!u1 || !u2) throw new Error('User not found');
  if (u1.balance < bet || u2.balance < bet) {
    throw new Error('One of players has insufficient balance');
  }

  // Flip b·∫±ng commit‚Äìreveal (clientSeed = roomId, nonce tƒÉng d·∫ßn)
  const serverSeed = cf.fair.serverSeed;
  const clientSeed = room.roomId;
  const nonce = Number(cf.fair.nonce) || 0;

  const result = coinflip({ serverSeed, clientSeed, nonce });
  cf.fair.nonce = nonce + 1;
  cf.result = result;

  // X√°c ƒë·ªãnh winner (side n√†o kh·ªõp result)
  const pick = (uid) => cf.sides[String(uid)];
  const winnerId = pick(p1) === result ? p1 : p2;
  const loserId  = winnerId === p1 ? p2 : p1;

  // Net transfer: winner +bet, loser -bet
  const [uw, ul] = winnerId === p1 ? [u1, u2] : [u2, u1];
  uw.balance += bet;
  ul.balance -= bet;
  await Promise.all([uw.save(), ul.save()]);

  // C·∫≠p nh·∫≠t room & reveal seed
  cf.fair.serverSeedReveal = serverSeed;
  room.metadata.coinflip = cf;
  room.status = 'finished';
  room.winnerUserId = winnerId;
  await room.save();

  // L·ªãch s·ª≠
  await Promise.all([
    recordGameHistory({ userId: winnerId, game: 'coinflip_battle', betAmount: bet, outcome: 'win',  payout: bet }),
    recordGameHistory({ userId: loserId,  game: 'coinflip_battle', betAmount: bet, outcome: 'lose', payout: 0   }),
  ]);

  return { result, winnerId, bet, seedHash: cf.fair.seedHash, serverSeed };
};




=== D:\Downloads\cado4fun\server\controllers\historyController.js ===

// server/controllers/historyController.js
const GameHistory = require('../models/GameHistory');
const mongoose = require('mongoose');

exports.getHistory = async (req, res) => {
  try {
    const { id } = req.params;
    const { page = 1, limit = 10 } = req.query;

    if (req.user.id !== id && req.user.role !== 'admin') {
      return res.status(403).json({ error: 'Forbidden' });
    }

    const skip = (parseInt(page) - 1) * parseInt(limit);

    const [history, total] = await Promise.all([
      GameHistory.find({ user: new mongoose.Types.ObjectId(id) })
        .sort({ createdAt: -1 })
        .skip(skip)
        .limit(parseInt(limit))
        .select('game betAmount outcome payout createdAt'),
      GameHistory.countDocuments({ user: new mongoose.Types.ObjectId(id) })
    ]);

    res.json({ history, total });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: 'Server error' });
  }
};




=== D:\Downloads\cado4fun\server\controllers\rewardController.js ===

// server/controllers/rewardController.js
const User = require('../models/User');

const REWARD_AMOUNTS = {
  hourly: 10,
  daily:  100,
  weekly: 1000
};

const COOLDOWNS_MS = {
  hourly: 60 * 60 * 1000,
  daily:  24 * 60 * 60 * 1000,
  weekly: 7 * 24 * 60 * 60 * 1000
};

// GET /api/rewards
exports.getRewardsStatus = async (req, res) => {
  try {
    const user = await User.findById(req.user.id);
    res.json({
      hourly: user.hourlyCollectedAt,
      daily:  user.dailyCollectedAt,
      weekly: user.weeklyCollectedAt
    });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: 'Server error' });
  }
};

// POST /api/rewards/:type
exports.collectReward = async (req, res) => {
  try {
    const { type } = req.params; // 'hourly', 'daily', 'weekly'
    if (!['hourly', 'daily', 'weekly'].includes(type)) {
      return res.status(400).json({ error: 'Invalid reward type' });
    }
    const user = await User.findById(req.user.id);
    const last = user[`${type}CollectedAt`];
    const now  = Date.now();
    if (last && now - last.getTime() < COOLDOWNS_MS[type]) {
      const next = new Date(last.getTime() + COOLDOWNS_MS[type]);
      return res.status(400).json({ error: 'Cooldown active', nextAvailable: next });
    }
    // Grant reward
    const amount = REWARD_AMOUNTS[type];
    user.balance += amount;
    user[`${type}CollectedAt`] = new Date();
    await user.save();
    res.json({ message: `Collected ${type} reward`, amount, balance: user.balance });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: 'Server error' });
  }
};




=== D:\Downloads\cado4fun\server\controllers\transactionController.js ===

// server/controllers/transactionController.js
const Transaction = require('../models/Transaction')

exports.getTransactions = async (req, res) => {
  try {
    const { userId } = req.params
    const txs = await Transaction
      .find({ userId })
      .sort({ createdAt: -1 })
      .lean()
    return res.json({ transactions: txs })
  } catch (err) {
    return res.status(500).json({ error: err.message })
  }
}




=== D:\Downloads\cado4fun\server\cron\cleanupRooms.js ===

// server/cron/cleanupRooms.js
const mongoose = require('mongoose');
const PvpRoom = require('../models/PvpRoom');
const User = require('../models/User');
const { logBalanceChange } = require('../utils/balanceLog');
const { hmacHex } = require('../utils/fair');
const fs = require('fs');
const path = require('path');

/** ===================== Config (override qua ENV) ===================== */
const MAX_WAITING_AGE_MS = Number(process.env.PVP_MAX_WAITING_AGE_MS || 45 * 60 * 1000); // 45m
const SWEEP_INTERVAL_MS  = Number(process.env.PVP_SWEEP_INTERVAL_MS  || 60 * 1000);      // 60s
const COINFLIP_GRACE_MS  = Number(process.env.PVP_COINFLIP_GRACE_MS  || 10 * 1000);     // 10s (sau revealAt)
const DICE_GRACE_MS      = Number(process.env.PVP_DICE_GRACE_MS      || 2 * 1000);      // 2s (sau advanceAt)
const DICE_IDLE_MS       = Number(process.env.PVP_DICE_IDLE_MS       || 60 * 1000);     // 60s (kh√¥ng pending, ƒëang ch·ªù l∆∞·ª£t k·∫ø nh∆∞ng kh√¥ng ai roll)
const DICE_UNSTARTED_REFUND_MS = Number(process.env.PVP_DICE_UNSTARTED_REFUND_MS || 15 * 60 * 1000); // 15m (ƒë√£ start nh∆∞ng ch∆∞a c√≥ roll n√†o)

/** ===================== Logger level cho CRON =====================
 * ƒêi·ªÅu khi·ªÉn log ra console b·∫±ng PVP_CRON_LOG_LEVEL:
 *  - 'silent' | 'error' | 'info' | 'debug' (m·∫∑c ƒë·ªãnh: 'error')
 */
const CRON_LOG_LEVEL = (process.env.PVP_CRON_LOG_LEVEL || 'error').toLowerCase();
const LEVELS = { silent: 0, error: 1, info: 2, debug: 3 };
function ok(level) { return (LEVELS[CRON_LOG_LEVEL] || 1) >= (LEVELS[level] || 1); }

/** ===================== File log ri√™ng cho CRON (tu·ª≥ ch·ªçn) =====================
 * B·∫≠t/t·∫Øt qua ENV:
 *  - PVP_CRON_FILE_LOG=1           (m·∫∑c ƒë·ªãnh 0: t·∫Øt)
 *  - PVP_CRON_LOG_DIR=./logs       (th∆∞ m·ª•c ch·ª©a file log)
 *  - PVP_CRON_LOG_MAX_MB=10        (dung l∆∞·ª£ng t·ªëi ƒëa m·ªói file, t·ª± xoay segment)
 * M·ªói l·∫ßn kh·ªüi ƒë·ªông app s·∫Ω t·∫°o b·ªô file m·ªõi theo timestamp.
 */
const FILE_LOG_ENABLED = process.env.PVP_CRON_FILE_LOG === '1';
const FILE_LOG_DIR = process.env.PVP_CRON_LOG_DIR || path.resolve(process.cwd(), 'logs');
const FILE_LOG_MAX = Math.max(1, Number(process.env.PVP_CRON_LOG_MAX_MB || 10)) * 1024 * 1024;

let fileLogBase = null;   // pvp-cron-YYYYMMDD-HHmmss
let fileLogIndex = 0;     // -0, -1, -2...
let fileLogStream = null;
let fileLogSize = 0;

function initFileLoggerOnce() {
  if (!FILE_LOG_ENABLED || fileLogStream) return;
  fs.mkdirSync(FILE_LOG_DIR, { recursive: true });
  const ts = new Date().toISOString()
    .replace(/[:.]/g, '-')   // an to√†n cho filename
    .replace('T', '-')
    .replace('Z', '');
  fileLogBase = `pvp-cron-${ts}`;
  openNewLogSegment();
}

function openNewLogSegment() {
  if (!FILE_LOG_ENABLED) return;
  if (fileLogStream) {
    try { fileLogStream.end(); } catch (_) {}
  }
  const filename = path.join(FILE_LOG_DIR, `${fileLogBase}-${fileLogIndex}.log`);
  fileLogStream = fs.createWriteStream(filename, { flags: 'a' });
  fileLogSize = 0;
  fileLogIndex += 1;
}

function writeFileLog(obj) {
  if (!FILE_LOG_ENABLED) return;
  try {
    if (!fileLogStream) initFileLoggerOnce();
    const line = JSON.stringify(obj) + '\n';
    fileLogStream.write(line);
    fileLogSize += Buffer.byteLength(line);
    if (fileLogSize >= FILE_LOG_MAX) {
      openNewLogSegment();
    }
  } catch (_) { /* nu·ªët l·ªói ƒë·ªÉ kh√¥ng crash */ }
}

const log = {
  info: (...args) => {
    if (ok('info')) console.log('[PVP CRON]', ...args);
    writeFileLog({ ts: new Date().toISOString(), level: 'info', tag: 'PVP_CRON', msg: args.join(' ') });
  },
  debug: (...args) => {
    if (ok('debug')) console.log('[PVP CRON]', ...args);
    writeFileLog({ ts: new Date().toISOString(), level: 'debug', tag: 'PVP_CRON', msg: args.join(' ') });
  },
  error: (...args) => {
    if (ok('error')) console.error('[PVP CRON]', ...args);
    writeFileLog({ ts: new Date().toISOString(), level: 'error', tag: 'PVP_CRON', msg: args.join(' ') });
  },
};

/** ===================== State for health ===================== */
let LAST_SWEEP_AT = null;
let SWEEP_TIMER = null;
function getLastSweepAt() { return LAST_SWEEP_AT; }
function touchLastSweep() { LAST_SWEEP_AT = Date.now(); }

/** ===================== Helpers ===================== */
function getIO(app) { return app?.get('io'); }
function hexToFloat01(hex) { const n = parseInt(hex.slice(0, 8), 16); return n / 0x100000000; }

async function incBalanceAndLog({ userId, delta, roomId, reason }, session) {
  try {
    const upd = await User.findOneAndUpdate(
      { _id: userId },
      { $inc: { balance: delta } },
      { new: true, session }
    ).select('balance');
    await logBalanceChange({ userId, roomId, delta, reason, balanceAfter: upd?.balance });
  } catch (e) {
    log.error('incBalance error:', e.message);
  }
}

function sanitizeRoomWithNow(doc) {
  if (!doc) return doc;
  const room = JSON.parse(JSON.stringify(doc));
  if (room?.metadata && room.status !== 'finished') delete room.metadata.serverSeed;
  const md = room.metadata || {};
  if (md?.pendingCoin?.revealAt && !md._revealAt) md._revealAt = md.pendingCoin.revealAt;
  if (md?.pending?.revealAt && !md._revealAt) md._revealAt = md.pending.revealAt;
  if (md?.pending?.advanceAt && !md.turnLockedUntil) md.turnLockedUntil = md.pending.advanceAt;
  room.serverNow = Date.now();
  return room;
}

/** ===================== 1) Xo√° ph√≤ng WAITING qu√° h·∫°n ===================== */
async function cleanupWaitingRooms(app) {
  const beforeTs = Date.now() - MAX_WAITING_AGE_MS;
  const docs = await PvpRoom.find({
    status: 'waiting',
    $or: [{ updatedAt: { $lt: beforeTs } }, { createdAt: { $lt: beforeTs } }]
  }).lean();

  if (!docs.length) return;
  const io = getIO(app);

  for (const r of docs) {
    try {
      // B·∫£o hi·ªÉm: n·∫øu l·ª° escrowed (r·∫•t hi·∫øm) th√¨ refund
      const bet = Number(r.betAmount || 0);
      if (bet > 0 && r?.metadata?.escrowed === true) {
        const ids = (r.players || []).map(p => String(p.userId));
        for (const uid of ids) {
          await incBalanceAndLog({ userId: uid, delta: bet, roomId: r.roomId, reason: 'refund_waiting_cleanup' });
        }
      }
      await PvpRoom.deleteOne({ _id: r._id });
      io?.emit('pvp:roomDeleted', { roomId: r.roomId, serverNow: Date.now() });
      log.info('deleted waiting room', r.roomId);
      touchLastSweep();
    } catch (e) {
      log.error('cleanup waiting failed:', r.roomId, e.message);
      touchLastSweep();
    }
  }
}

/** ===================== 2) Ho√†n t·∫•t COINFLIP k·∫πt reveal ===================== */
async function finalizeStaleCoinflip(app) {
  const now = Date.now();
  const docs = await PvpRoom.find({
    status: 'active',
    game: 'coinflip',
    'metadata.pendingCoin.revealAt': { $lt: now - COINFLIP_GRACE_MS }
  });

  const io = getIO(app);
  for (const room of docs) {
    try {
      const md = room.metadata || {};
      const pend = md.pendingCoin;
      if (!pend) continue;

      const bet = Number(room.betAmount || 0);
      const pot = bet * 2;

      if (pend.winnerUserId) {
        await incBalanceAndLog({ userId: pend.winnerUserId, delta: pot, roomId: room.roomId, reason: 'payout_coinflip_cron' });
        room.winnerUserId = pend.winnerUserId;
      } else {
        // Ho√† ‚Äì refund
        const ids = room.players.map(p => String(p.userId));
        for (const uid of ids) {
          await incBalanceAndLog({ userId: uid, delta: bet, roomId: room.roomId, reason: 'refund_draw_coinflip_cron' });
        }
        room.winnerUserId = null;
      }

      // finalize
      md.flipResult = pend.result;
      md.serverSeedReveal = md.serverSeed;
      delete md.pendingCoin;

      room.status = 'finished';
      room.metadata = md;
      room.markModified('metadata');
      await room.save();

      io?.to(`pvp:${room.roomId}`).emit('pvp:roomFinished', {
        room: sanitizeRoomWithNow(room),
        serverNow: Date.now(),
      });

      log.info('finalized coinflip', room.roomId);
      touchLastSweep();
    } catch (e) {
      log.error('finalize coinflip failed:', room.roomId, e.message);
      touchLastSweep();
    }
  }
}

/** ===================== 3a) S·ª≠a DICE k·∫πt pending (qu√° grace) ===================== */
async function repairStaleDice(app) {
  const now = Date.now();
  const docs = await PvpRoom.find({
    status: 'active',
    game: 'dice',
    'metadata.pending.advanceAt': { $lt: now - DICE_GRACE_MS }
  });

  const io = getIO(app);
  for (const room of docs) {
    try {
      const md = room.metadata || {};
      const pend = md.pending;
      if (!pend) continue;

      // Step 1: ensure ƒë√£ reveal (push roll) n·∫øu tr·ªÖ
      if (pend.revealAt && now > pend.revealAt && md?.dice) {
        const already = (md.dice.rolls || []).some(x => String(x.userId) === String(pend.userId));
        if (!already) {
          md.dice.rolls = md.dice.rolls || [];
          md.dice.rolls.push({ userId: pend.userId, value: pend.value });
        }
      }

      // Step 2: advance ho·∫∑c finish
      const order = Array.isArray(md.turnOrder) && md.turnOrder.length
        ? md.turnOrder.map(String)
        : (room.players || []).map(p => String(p.userId));
      const allRolled = (md?.dice?.rolls?.length || 0) >= order.length;

      if (allRolled) {
        const max = Math.max(...md.dice.rolls.map(x => x.value));
        const winners = md.dice.rolls.filter(x => x.value === max).map(x => String(x.userId));
        const bet = Number(room.betAmount || 0);
        const pot = bet * order.length;
        const share = pot / winners.length;

        // payout trong tx
        const session = await mongoose.startSession();
        try {
          await session.withTransaction(async () => {
            for (const wid of winners) {
              await incBalanceAndLog({ userId: wid, delta: share, roomId: room.roomId, reason: 'payout_dice_cron' }, session);
            }
            room.status = 'finished';
            room.winnerUserId = null;
            md.serverSeedReveal = md.serverSeed;
            md.dice.result = { max, winners, pot };
            delete md.pending;

            room.metadata = md;
            room.markModified('metadata');
            await room.save({ session });
          });
        } finally {
          await session.endSession();
        }

        io?.to(`pvp:${room.roomId}`).emit('pvp:roomFinished', {
          room: sanitizeRoomWithNow(room),
          serverNow: Date.now(),
        });
        log.info('finished dice', room.roomId);
        touchLastSweep();
      } else {
        // Next turn
        const idx = typeof md.currentTurnIndex === 'number' ? md.currentTurnIndex : 0;
        md.currentTurnIndex = (idx + 1) % order.length;
        delete md.pending;

        room.metadata = md;
        room.markModified('metadata');
        await room.save();

        io?.to(`pvp:${room.roomId}`).emit('pvp:roomUpdated', {
          room: sanitizeRoomWithNow(room),
          serverNow: Date.now(),
        });
        log.info('advanced dice turn', room.roomId);
        touchLastSweep();
      }
    } catch (e) {
      log.error('repair dice failed:', room.roomId, e.message);
      touchLastSweep();
    }
  }
}

/** ===================== 3b) Auto-roll DICE khi ‚Äúƒë·ª©ng y√™n‚Äù (kh√¥ng pending) ===================== */
async function autoRollIdleDice(app) {
  const threshold = new Date(Date.now() - DICE_IDLE_MS);

  // active dice, kh√¥ng pending, updatedAt qu√° c≈©, v√† ch∆∞a ƒë·ªß l∆∞·ª£t
  const rooms = await PvpRoom.find({
    status: 'active',
    game: 'dice',
    $or: [{ 'metadata.pending': { $exists: false } }, { 'metadata.pending': null }],
    updatedAt: { $lt: threshold },
  });

  const io = getIO(app);

  for (const room of rooms) {
    try {
      const md = room.metadata || {};
      const order = Array.isArray(md.turnOrder) && md.turnOrder.length
        ? md.turnOrder.map(String)
        : (room.players || []).map(p => String(p.userId));

      if (!order.length) continue;

      const rolls = (md?.dice?.rolls || []);
      if (rolls.length >= order.length) continue; // ƒë·ªß l∆∞·ª£t r·ªìi

      const idx = typeof md.currentTurnIndex === 'number' ? md.currentTurnIndex : 0;
      const curUserId = String(order[idx]);

      // T·∫°o roll deterministically gi·ªëng /roll
      const sides = Number(md?.dice?.sides || 6);
      const serverSeed = md.serverSeed;
      if (!serverSeed) continue; // ch∆∞a init seed => b·ªè qua

      const clientSeed = (md.clientSeed || room.roomId) + `|${curUserId}`;
      const nonce = typeof md.nonce === 'number' ? md.nonce : 0;

      const hex = hmacHex({ serverSeed, clientSeed, nonce });
      const r = hexToFloat01(hex);
      const value = Math.floor(r * sides) + 1;
      md.nonce = nonce + 1;

      // Push roll ngay (kh√¥ng ‚Äúpending‚Äù v√¨ cron ƒëang auto)
      md.dice = md.dice || { sides, rolls: [], result: null };
      md.dice.rolls = md.dice.rolls || [];
      if (!md.dice.rolls.some(x => String(x.userId) === curUserId)) {
        md.dice.rolls.push({ userId: curUserId, value });
      }

      // Advance ho·∫∑c Finish
      const allRolled = md.dice.rolls.length >= order.length;
      if (allRolled) {
        const max = Math.max(...md.dice.rolls.map(x => x.value));
        const winners = md.dice.rolls.filter(x => x.value === max).map(x => String(x.userId));
        const bet = Number(room.betAmount || 0);
        const pot = bet * order.length;
        const share = winners.length ? pot / winners.length : 0;

        // payout trong tx
        const session = await mongoose.startSession();
        try {
          await session.withTransaction(async () => {
            if (share > 0) {
              for (const wid of winners) {
                await incBalanceAndLog({ userId: wid, delta: share, roomId: room.roomId, reason: 'payout_dice_idle_cron' }, session);
              }
            }
            room.status = 'finished';
            room.winnerUserId = null;
            md.serverSeedReveal = md.serverSeed;
            md.dice.result = { max, winners, pot };

            room.metadata = md;
            room.markModified('metadata');
            await room.save({ session });
          });
        } finally {
          await session.endSession();
        }

        io?.to(`pvp:${room.roomId}`).emit('pvp:roomFinished', {
          room: sanitizeRoomWithNow(room),
          serverNow: Date.now(),
        });
        log.info('auto-finished idle dice', room.roomId);
        touchLastSweep();
      } else {
        // sang l∆∞·ª£t k·∫ø
        md.currentTurnIndex = (idx + 1) % order.length;

        room.metadata = md;
        room.markModified('metadata');
        await room.save();

        io?.to(`pvp:${room.roomId}`).emit('pvp:roomUpdated', {
          room: sanitizeRoomWithNow(room),
          serverNow: Date.now(),
        });
        log.info('auto-rolled idle dice turn for', room.roomId, '‚Üí next turn');
        touchLastSweep();
      }
    } catch (e) {
      log.error('autoRollIdleDice failed:', room.roomId, e.message);
      touchLastSweep();
    }
  }
}

/** ===================== 3c) CANCEL + REFUND dice ƒë√£ start nh∆∞ng CH∆ØA c√≥ roll n√†o ===================== */
async function cancelAndRefundUnstartedDice(app) {
  const threshold = new Date(Date.now() - DICE_UNSTARTED_REFUND_MS);

  const rooms = await PvpRoom.find({
    status: 'active',
    game: 'dice',
    $or: [{ 'metadata.pending': { $exists: false } }, { 'metadata.pending': null }],
    updatedAt: { $lt: threshold },
    'metadata.dice.rolls': { $size: 0 },
  });

  const io = getIO(app);

  for (const room of rooms) {
    try {
      const md = room.metadata || {};
      const bet = Number(room.betAmount || 0);
      const playerIds = (room.players || []).map(p => String(p.userId));
      if (!playerIds.length) {
        await PvpRoom.deleteOne({ _id: room._id });
        io?.emit('pvp:roomDeleted', { roomId: room.roomId, serverNow: Date.now() });
        log.info('deleted dice room with no players', room.roomId);
        touchLastSweep();
        continue;
      }

      const session = await mongoose.startSession();
      try {
        await session.withTransaction(async () => {
          if (bet > 0 && md.escrowed === true) {
            for (const uid of playerIds) {
              await incBalanceAndLog({ userId: uid, delta: bet, roomId: room.roomId, reason: 'refund_dice_unstarted_idle' }, session);
            }
          }
          room.status = 'cancelled';
          room.metadata = md;
          room.markModified('metadata');
          await room.save({ session });
        });
      } finally {
        await session.endSession();
      }

      io?.to(`pvp:${room.roomId}`).emit('pvp:roomUpdated', {
        room: sanitizeRoomWithNow(room),
        serverNow: Date.now(),
      });
      log.info('cancelled & refunded unstarted dice', room.roomId);
      touchLastSweep();
    } catch (e) {
      log.error('cancel unstarted dice failed:', room.roomId, e.message);
      touchLastSweep();
    }
  }
}

/** ===================== Scheduler ===================== */
function schedulePvpCleanup(app) {
  // clear timer c≈© n·∫øu c√≥
  if (SWEEP_TIMER) {
    clearInterval(SWEEP_TIMER);
    SWEEP_TIMER = null;
  }

  initFileLoggerOnce();   // kh·ªüi t·∫°o file logger n·∫øu b·∫≠t

  // C·∫≠p nh·∫≠t ngay ƒë·ªÉ trang /health kh√¥ng hi·ªÉn th·ªã '-'
  touchLastSweep();

  SWEEP_TIMER = setInterval(async () => {
    try {
      await cleanupWaitingRooms(app);   touchLastSweep();
      await finalizeStaleCoinflip(app); touchLastSweep();
      await repairStaleDice(app);       touchLastSweep();
      await autoRollIdleDice(app);      touchLastSweep();
      await cancelAndRefundUnstartedDice(app); touchLastSweep();
    } catch (e) {
      log.error('sweep error:', e.message);
    } finally {
      // d·∫•u tick cho l·∫ßn qu√©t
      touchLastSweep();
    }
  }, SWEEP_INTERVAL_MS);

  log.debug('scheduled sweep every', SWEEP_INTERVAL_MS, 'ms');
}

function stopPvpCleanup() {
  if (SWEEP_TIMER) {
    clearInterval(SWEEP_TIMER);
    SWEEP_TIMER = null;
    log.debug('sweep stopped');
  }
}

module.exports = { schedulePvpCleanup, stopPvpCleanup, getLastSweepAt };




=== D:\Downloads\cado4fun\server\middleware\admin.js ===

// server/middleware/admin.js

module.exports = function(req, res, next) {
  if (req.user.role !== 'admin')
    return res.status(403).json({ error: 'Ch·ªâ admin m·ªõi th·ª±c hi·ªán ƒë∆∞·ª£c' });
  next();
};




=== D:\Downloads\cado4fun\server\middleware\auth.js ===

// server/middleware/auth.js
const jwt = require('jsonwebtoken');
const mongoose = require('mongoose');

module.exports = function(req, res, next) {
  const authHeader = req.header('Authorization');
  if (!authHeader) {
    return res.status(401).json({ 
      error: 'Kh√¥ng t√¨m th·∫•y token',
      code: 'AUTH_TOKEN_MISSING'
    });
  }

  const token = authHeader.split(' ')[1];
  if (!token) {
    return res.status(401).json({ 
      error: 'Token kh√¥ng h·ª£p l·ªá',
      code: 'AUTH_TOKEN_INVALID'
    });
  }

  try {
    const decoded = jwt.verify(token, process.env.JWT_SECRET);
    
    // üîê SECURITY: Validate ObjectId format
    if (decoded.id && !mongoose.isValidObjectId(decoded.id)) {
      return res.status(401).json({ 
        error: 'Token kh√¥ng h·ª£p l·ªá',
        code: 'AUTH_TOKEN_INVALID_USER_ID'
      });
    }
    
    req.user = decoded; // { id, role, iat, exp }
    next();
  } catch (err) {
    if (err.name === 'TokenExpiredError') {
      return res.status(401).json({ 
        error: 'Token h·∫øt h·∫°n',
        code: 'AUTH_TOKEN_EXPIRED'
      });
    }
    return res.status(401).json({ 
      error: 'Token h·∫øt h·∫°n ho·∫∑c kh√¥ng h·ª£p l·ªá',
      code: 'AUTH_TOKEN_INVALID'
    });
  }
};



=== D:\Downloads\cado4fun\server\middleware\errorHandler.js ===

// server/middleware/errorHandler.js
const { AppError } = require('../utils/AppError');

module.exports = function errorHandler(err, req, res, _next) {
  const requestId = req.requestId; // n·∫øu c√≥ middleware requestId th√¨ s·∫Ω set
  const isAppError = err instanceof AppError;

  if (!isAppError) {
    // Kh√¥ng l·ªô stack ra ngo√†i client
    console.error(
      '[UNHANDLED]',
      requestId ? `(req:${requestId})` : '',
      err?.message,
      err?.stack
    );
  }

  const httpStatus = isAppError ? (err.httpStatus || 500) : 500;
  const code = isAppError ? (err.code || 'INTERNAL_ERROR') : 'INTERNAL_ERROR';

  // Th√¥ng ƒëi·ªáp ch√≠nh (gi·ªØ xu·ªëng d√≤ng \n n·∫øu c√≥)
  const message = err?.message || 'Internal server error';

  // Gi·ªØ t∆∞∆°ng th√≠ch v·ªõi FE: tr·∫£ c·∫£ message v√† error
  const payload = {
    ok: false,
    code,
    message,
    error: message, // FE (useApi) c√≥ th·ªÉ ƒë·ªçc data.error
  };

  if (requestId) payload.requestId = requestId;

  // === META EXPOSURE POLICY ===
  // - Production: ch·ªâ whitelists m·ªôt s·ªë m√£ an to√†n (vd: thi·∫øu s·ªë d∆∞) v√† ch·ªâ c√°c field c·∫ßn thi·∫øt
  // - Non-prod: tr·∫£ full meta ƒë·ªÉ debug
  if (isAppError && err.meta) {
    const isProd = process.env.NODE_ENV === 'production';
    if (!isProd) {
      payload.meta = err.meta;
    } else {
      const SAFE_META_CODES = new Set(['INSUFFICIENT_BALANCE']);
      if (SAFE_META_CODES.has(code)) {
        const src = err.meta || {};
        const safe = {};
        // Chu·∫©n ho√° 'required'
        if (src.required != null) safe.required = src.required;
        else if (src.need != null) safe.required = src.need;
        else if (src.amount != null) safe.required = src.amount;
        // Chu·∫©n ho√° 'have'
        if (src.have != null) safe.have = src.have;
        else if (src.balance != null) safe.have = src.balance;

        if (Object.keys(safe).length > 0) {
          payload.meta = safe;
        }
      }
    }
  }

  res.status(httpStatus).json(payload);
};




=== D:\Downloads\cado4fun\server\middleware\idempotency.js ===

// server/middleware/idempotency.js
const STORE = new Map();

/**
 * Idempotency guard for POST actions that must execute once (start/roll/finish)
 * - Accepts key from body.requestId or header x-idempotency-key
 * - TTL default 60s
 */
module.exports = function idempotency(options = {}) {
  const { ttlMs = 60_000, namespace = 'pvp' } = options;

  return async function (req, res, next) {
    const keyRaw = (req.body && (req.body.requestId || req.body.idempotencyKey)) ||
                   req.headers['x-idempotency-key'];
    if (!keyRaw) return next(); // if no key, we don't block (still rate-limited outside)
    const userId = req.user?.id ? String(req.user.id) : '-';
    const key = `${namespace}:${userId}:${keyRaw}`;
    const now = Date.now();

    // Cleanup old entries occasionally
    if (STORE.size > 2000 && Math.random() < 0.01) {
      const entries = Array.from(STORE.entries());
      for (const [k, v] of entries) {
        if (now > v.expireAt) STORE.delete(k);
      }
    }

    const existed = STORE.get(key);
    if (existed && now < existed.expireAt) {
      // Already processed ‚Äî return cached response if any
      if (existed.response) {
        return res.status(existed.response.status).json(existed.response.body);
      }
      // Or reject to prevent re-execution
      return res.status(409).json({ error: 'Duplicate request' });
    }

    // Wrap res.json to cache one response
    const origJson = res.json.bind(res);
    const origStatus = res.status.bind(res);

    let statusCode = 200;
    res.status = (code) => { statusCode = code; return origStatus(code); };
    res.json = (body) => {
      STORE.set(key, { expireAt: now + ttlMs, response: { status: statusCode, body } });
      return origJson(body);
    };

    return next();
  };
};




=== D:\Downloads\cado4fun\server\middleware\jadmin.js ===

// server/middleware/jadmin.js

module.exports = function(req, res, next) {
  const role = req.user.role;
  if (role === 'admin' || role === 'jadmin') return next();
  return res.status(403).json({ error: 'Ch·ªâ admin ho·∫∑c junior admin m·ªõi th·ª±c hi·ªán ƒë∆∞·ª£c' });
};




=== D:\Downloads\cado4fun\server\middleware\logRequest.js ===

// server/middleware/logRequest.js
const logger = require("../utils/logger");
const { randomUUID } = require("crypto");

/**
 * ENV h·ªó tr·ª£:
 *  - HTTP_LOG_LEVEL=info | off
 *      + info (m·∫∑c ƒë·ªãnh): b·∫≠t log http_request
 *      + off: t·∫Øt to√†n b·ªô log HTTP
 *  - HTTP_LOG_IGNORE_PATHS=/api/admin/pvp/health,/api/metrics
 */
const HTTP_LOG_LEVEL = (process.env.HTTP_LOG_LEVEL || "info").toLowerCase();
const IGNORE_PATHS = (process.env.HTTP_LOG_IGNORE_PATHS || "")
  .split(",")
  .map((s) => s.trim())
  .filter(Boolean);

module.exports = function logRequest(req, res, next) {
  // T·∫Øt to√†n b·ªô n·∫øu c·∫•u h√¨nh off
  if (HTTP_LOG_LEVEL === "off") return next();

  // G·∫Øn requestId (nh·∫≠n t·ª´ FE ho·∫∑c t·ª± sinh), v√† tr·∫£ l·∫°i header ƒë·ªÉ trace end-to-end
  const hdr = req.headers["x-request-id"];
  req.requestId = typeof hdr === "string" && hdr.trim() ? hdr.trim() : randomUUID();
  res.setHeader("x-request-id", req.requestId);

  const start = Date.now(); // th·ªùi ƒëi·ªÉm BE nh·∫≠n request
  const clientNowHeader = req.headers["x-client-now"];
  const clientNow = clientNowHeader ? Number(clientNowHeader) : null;

  // B·ªè qua c√°c path c·∫•u h√¨nh ignore
  const path = req.path || req.originalUrl || req.url || "";
  if (IGNORE_PATHS.length && IGNORE_PATHS.includes(path)) {
    return next();
  }

  res.on("finish", () => {
    try {
      const latency = Date.now() - start;

      // L·ªách ƒë·ªìng h·ªì t·∫°i th·ªùi ƒëi·ªÉm request t·ªõi server (√≠t bias h∆°n finish)
      const skew =
        clientNow && !Number.isNaN(clientNow) ? clientNow - start : undefined;

      // L·∫•y userId SAU khi c√°c middleware (auth) ƒë√£ ch·∫°y
      const userId = req.user?.id ? String(req.user.id) : undefined;

      // IP ∆∞u ti√™n X-Forwarded-For, sau ƒë√≥ socket.remoteAddress
      const forwarded = req.headers["x-forwarded-for"];
      const ip =
        (typeof forwarded === "string" && forwarded.split(",")[0].trim()) ||
        req.socket?.remoteAddress ||
        req.connection?.remoteAddress ||
        "";

      // Ghi log theo schema http_request quen thu·ªôc
      logger.info("http_request", {
        requestId: req.requestId,
        method: req.method,
        url: req.originalUrl || req.url,
        status: res.statusCode,
        userId,
        latencyMs: latency,
        skewMs: skew,
        ip,
      });
    } catch (_) {
      // nu·ªët l·ªói ƒë·ªÉ kh√¥ng ·∫£nh h∆∞·ªüng response
    }
  });

  next();
};




=== D:\Downloads\cado4fun\server\middleware\mongoSanitize.js ===

// server/middleware/mongoSanitize.js

/**
 * Custom MongoDB sanitization middleware
 * Prevents NoSQL injection by removing $ and . from user input
 * 
 * This replaces express-mongo-sanitize to avoid req.query conflict
 * in certain Express versions.
 */
module.exports = function mongoSanitizeCustom() {
  return function(req, res, next) {
    try {
      // Sanitize req.body
      if (req.body && typeof req.body === 'object') {
        req.body = sanitizeObject(req.body)
      }

      // Sanitize req.params
      if (req.params && typeof req.params === 'object') {
        req.params = sanitizeObject(req.params)
      }

      // ‚ö†Ô∏è SKIP req.query (read-only in some Express versions)
      // Query params are usually strings so less risky

      next()
    } catch (err) {
      next(err)
    }
  }
}

/**
 * Recursively sanitize an object by removing dangerous keys
 * @param {*} obj - Object to sanitize
 * @returns {*} Sanitized object
 */
function sanitizeObject(obj) {
  if (!obj || typeof obj !== 'object') return obj

  const sanitized = Array.isArray(obj) ? [] : {}

  for (const key in obj) {
    if (obj.hasOwnProperty(key)) {
      // Remove keys starting with $ or containing .
      if (key.startsWith('$') || key.includes('.')) {
        console.warn(`[SECURITY] Blocked malicious key: "${key}"`)
        continue
      }

      const value = obj[key]

      // Recursively sanitize nested objects
      if (value && typeof value === 'object') {
        sanitized[key] = sanitizeObject(value)
      } else {
        sanitized[key] = value
      }
    }
  }

  return sanitized
}



=== D:\Downloads\cado4fun\server\middleware\rateLimit.js ===

// server/middleware/rateLimit.js
const BUCKET = new Map();

/**
 * Simple sliding window rate limit
 * key = `${ip}:${userId||'-'}:${route}`
 */
module.exports = function rateLimit(options = {}) {
  const {
    windowMs = 10_000, // 10s window
    max = 20,          // max 20 req/window/key
    getKey = (req) => {
      const ip = (req.headers['x-forwarded-for'] || req.connection.remoteAddress || '').split(',')[0].trim() || 'ip';
      const uid = (req.user && req.user.id) ? String(req.user.id) : '-';
      // route key: method + baseUrl + path pattern (removing params values)
      const route = (req.baseUrl || '') + (req.route ? req.route.path : req.path || '');
      return `${ip}:${uid}:${req.method}:${route}`;
    },
  } = options;

  return (req, res, next) => {
    try {
      const key = getKey(req);
      const now = Date.now();
      let bucket = BUCKET.get(key);
      if (!bucket) {
        bucket = { count: 1, resetAt: now + windowMs };
        BUCKET.set(key, bucket);
        return next();
      }
      if (now > bucket.resetAt) {
        bucket.count = 1;
        bucket.resetAt = now + windowMs;
        return next();
      }
      bucket.count++;
      if (bucket.count > max) {
        return res.status(429).json({ error: 'Too many requests, please slow down.', retryAfterMs: bucket.resetAt - now });
      }
      return next();
    } catch (e) {
      // fail-open
      return next();
    }
  };
};




=== D:\Downloads\cado4fun\server\middleware\rateLimitStrict.js ===

// server/middleware/rateLimitStrict.js
const rateLimit = require('express-rate-limit');

/**
 * Strict rate limiters for sensitive endpoints
 */

// Auth endpoints: Login/Register
// 5 attempts per 15 minutes per IP
const authLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 5,
  message: {
    error: 'Too many authentication attempts, please try again later',
    code: 'RATE_LIMIT_AUTH',
    retryAfter: '15 minutes'
  },
  standardHeaders: true,
  legacyHeaders: false,
  // Skip successful requests from counting
  skipSuccessfulRequests: true,
  // Custom key generator (IP + endpoint)
  keyGenerator: (req) => {
    return `${req.ip}:${req.path}`;
  }
});

// Wallet transfer endpoint
// 10 transfers per 5 minutes per user
const transferLimiter = rateLimit({
  windowMs: 5 * 60 * 1000, // 5 minutes
  max: 10,
  message: {
    error: 'Too many transfer attempts, please slow down',
    code: 'RATE_LIMIT_TRANSFER',
    retryAfter: '5 minutes'
  },
  standardHeaders: true,
  legacyHeaders: false,
  // Key by user ID if authenticated
  keyGenerator: (req) => {
    return req.user?.id ? String(req.user.id) : req.ip;
  }
});

// PvP action endpoints (start/roll/finish)
// 20 actions per 1 minute per user
const pvpActionLimiter = rateLimit({
  windowMs: 60 * 1000, // 1 minute
  max: 20,
  message: {
    error: 'Too many PvP actions, please slow down',
    code: 'RATE_LIMIT_PVP',
    retryAfter: '1 minute'
  },
  standardHeaders: true,
  legacyHeaders: false,
  keyGenerator: (req) => {
    return req.user?.id ? String(req.user.id) : req.ip;
  }
});

// Room creation: 5 rooms per 10 minutes per user
const createRoomLimiter = rateLimit({
  windowMs: 10 * 60 * 1000, // 10 minutes
  max: 5,
  message: {
    error: 'Too many rooms created, please wait before creating more',
    code: 'RATE_LIMIT_CREATE_ROOM',
    retryAfter: '10 minutes'
  },
  standardHeaders: true,
  legacyHeaders: false,
  keyGenerator: (req) => {
    return req.user?.id ? String(req.user.id) : req.ip;
  }
});

module.exports = {
  authLimiter,
  transferLimiter,
  pvpActionLimiter,
  createRoomLimiter
};



=== D:\Downloads\cado4fun\server\middleware\requestId.js ===

// server/middleware/requestId.js
const { randomUUID } = require('crypto');

/**
 * Middleware g·∫Øn requestId cho m·ªçi request, lu√¥n ch·∫°y
 * k·ªÉ c·∫£ khi HTTP logger ƒëang t·∫Øt, ƒë·ªÉ FE c√≥ th·ªÉ trace.
 * - Nh·∫≠n t·ª´ header 'x-request-id' n·∫øu c√≥; n·∫øu kh√¥ng th√¨ t·ª± sinh.
 * - Tr·∫£ l·∫°i 'x-request-id' trong response header.
 */
module.exports = function requestId(req, res, next) {
  const hdr = req.headers['x-request-id'];
  req.requestId = typeof hdr === 'string' && hdr.trim() ? hdr.trim() : randomUUID();
  res.setHeader('x-request-id', req.requestId);
  next();
};




=== D:\Downloads\cado4fun\server\middleware\validateObjectId.js ===

// server/middleware/validateObjectId.js
const mongoose = require('mongoose');

/**
 * Middleware ƒë·ªÉ validate MongoDB ObjectId t·ª´ route params
 * 
 * Usage:
 *   router.get('/user/:id', validateObjectId('id'), (req, res) => {...})
 *   router.get('/room/:roomId', validateObjectId('roomId'), (req, res) => {...})
 * 
 * @param {string} paramName - T√™n param c·∫ßn validate (default: 'id')
 * @returns {Function} Express middleware
 */
module.exports = function validateObjectId(paramName = 'id') {
  return (req, res, next) => {
    const id = req.params[paramName];
    
    if (!id) {
      return res.status(400).json({ 
        error: `Missing ${paramName} parameter`,
        code: 'MISSING_PARAMETER'
      });
    }
    
    if (!mongoose.isValidObjectId(id)) {
      return res.status(400).json({ 
        error: `Invalid ${paramName} format`,
        code: 'INVALID_OBJECT_ID',
        meta: { paramName, value: id }
      });
    }
    
    next();
  };
};



=== D:\Downloads\cado4fun\server\models\BalanceLog.js ===

const mongoose = require('mongoose');

const BalanceLogSchema = new mongoose.Schema({
  userId: { type: mongoose.Schema.Types.ObjectId, ref: 'User', index: true },
  roomId: { type: String, index: true },
  delta: { type: Number, required: true },          // + or -
  reason: { type: String, required: true },         // 'escrow' | 'payout_*' | 'refund_*' | ...
  balanceAfter: { type: Number, required: true },
  meta: { type: Object, default: {} },
}, { timestamps: true });

// üîΩ Index ph·ª•c v·ª• b√°o c√°o / truy v·∫•n
BalanceLogSchema.index({ userId: 1, createdAt: -1 })
BalanceLogSchema.index({ roomId: 1, createdAt: -1 })

module.exports = mongoose.models.BalanceLog || mongoose.model('BalanceLog', BalanceLogSchema);




=== D:\Downloads\cado4fun\server\models\GameHistory.js ===

// server/models/GameHistory.js
const mongoose = require('mongoose');

const gameHistorySchema = new mongoose.Schema({
  user:      { type: mongoose.Schema.Types.ObjectId, ref: 'User', required: true, index: true },
  game:      { type: String, required: true },
  betAmount: { type: Number, required: true },
  outcome:   { type: String, required: true },
  payout:    { type: Number, required: true },
  createdAt: { type: Date, default: Date.now }
});

// ‚úÖ Compound index for efficient user history queries
gameHistorySchema.index({ user: 1, createdAt: -1 });

module.exports = mongoose.model('GameHistory', gameHistorySchema);



=== D:\Downloads\cado4fun\server\models\Notification.js ===

// server/models/Notification.js
const mongoose = require('mongoose');
const { Schema } = mongoose;

const notificationSchema = new Schema({
  userId:    { type: Schema.Types.ObjectId, ref: 'User', required: true },
  type:      { type: String, required: true },   // e.g. 'pvp_invite'
  message:   { type: String, required: true },   // human-readable message
  read:      { type: Boolean, default: false },
  // Optional: deep link + structured data for client actions
  link:      { type: String },                   // e.g. '/game/battle/room/xxxx'
  metadata:  { type: Schema.Types.Mixed },       // e.g. { roomId, path, game, betAmount, fromUserId, fromUserName }
  createdAt: { type: Date, default: Date.now }
});

// Sort timeline by newest first
notificationSchema.index({ userId: 1, createdAt: -1 });

module.exports = mongoose.model('Notification', notificationSchema);




=== D:\Downloads\cado4fun\server\models\PvpRoom.js ===

// server/models/PvpRoom.js
const mongoose = require('mongoose')

const PvpBetSchema = new mongoose.Schema(
  {
    userId:    { type: mongoose.Schema.Types.ObjectId, ref: 'User', required: true },
    amount:    { type: Number, min: 0, default: 0 },
    choice:    { type: String }, // game-specific
    createdAt: { type: Date, default: Date.now },
  },
  { _id: false }
)

const PvpPlayerSchema = new mongoose.Schema(
  {
    userId:   { type: mongoose.Schema.Types.ObjectId, ref: 'User', required: true },
    joinedAt: { type: Date, default: Date.now },
    ready:    { type: Boolean, default: false },
    // side cho c√°c mode c·∫ßn pre-pick (coinflip, v.v.)
    side:     { type: String, default: null }, // 'heads' | 'tails' | null
  },
  { _id: false }
)

// ‚úÖ FIX: Remove duplicate index declaration
const PvpRoomSchema = new mongoose.Schema(
  {
    roomId:       { type: String, required: true, unique: true }, // ‚úÖ Removed index: true
    game:         { type: String, required: true, default: 'coinflip' },
    betAmount:    { type: Number, min: 0, default: 0 },
    maxPlayers:   { type: Number, default: 2, min: 2, max: 6 },
    players:      { type: [PvpPlayerSchema], default: [] },
    bets:         { type: [PvpBetSchema], default: [] },
    status:       { type: String, enum: ['waiting','active','finished','cancelled'], default: 'waiting', index: true },
    createdBy:    { type: mongoose.Schema.Types.ObjectId, ref: 'User', required: true },
    winnerUserId: { type: mongoose.Schema.Types.ObjectId, ref: 'User' },
    metadata:     { type: mongoose.Schema.Types.Mixed }, // seedHash, serverSeed (·∫©n), clientSeed, flipResult, ...
  },
  { timestamps: true }
)

// üîΩ Index quan tr·ªçng cho list/cron
PvpRoomSchema.index({ status: 1, game: 1, createdAt: -1 })
PvpRoomSchema.index({ 'metadata.pendingCoin.revealAt': 1 }, { sparse: true })
PvpRoomSchema.index({ 'metadata.pending.advanceAt': 1 }, { sparse: true })
PvpRoomSchema.index({ updatedAt: -1 })
PvpRoomSchema.index({ roomId: 1 }, { unique: true }) // ‚úÖ Only one roomId index

module.exports = mongoose.models.PvpRoom || mongoose.model('PvpRoom', PvpRoomSchema)



=== D:\Downloads\cado4fun\server\models\Transaction.js ===

// server/models/Transaction.js
const mongoose = require('mongoose');
const { Schema } = mongoose;

const transactionSchema = new Schema({
  userId:      { type: Schema.Types.ObjectId, ref: 'User', required: true, index: true },
  type:        { type: String, enum: ['deposit','withdraw','transfer'], required: true },
  amount:      { type: Number, required: true },
  fromUserId:  { type: Schema.Types.ObjectId, ref: 'User' },
  toUserId:    { type: Schema.Types.ObjectId, ref: 'User' },
  createdAt:   { type: Date, default: Date.now }
});

// ‚úÖ Compound index for efficient transaction history queries
transactionSchema.index({ userId: 1, createdAt: -1 });

module.exports = mongoose.model('Transaction', transactionSchema);



=== D:\Downloads\cado4fun\server\models\User.js ===

// server/models/User.js
const mongoose = require('mongoose');

const userSchema = new mongoose.Schema({
  username:              { type: String, required: true, unique: true },
  email:                 { type: String, required: true, unique: true },
  password:              { type: String, required: true },
  role:                  { type: String, enum: ['user', 'jadmin', 'admin'], default: 'user' },
  balance:               { type: Number, default: 1000 },
  higherLowerLastNumber: { type: Number, default: 10 },
  higherLowerStreak:     { type: Number, default: 0 },
  bank:                  { type: Number, default: 0 },
  avatar:                { type: String, default: '' }, // URL ·∫£nh profile
  dateOfBirth:           { type: Date, default: null }, // Ng√†y sinh
  // Reward cooldowns
  hourlyCollectedAt:     { type: Date, default: null },
  dailyCollectedAt:      { type: Date, default: null },
  weeklyCollectedAt:     { type: Date, default: null },
  createdAt:             { type: Date, default: Date.now }
});

module.exports = mongoose.model('User', userSchema);




=== D:\Downloads\cado4fun\server\routes\adminPvpRoutes.js ===

// server/routes/adminPvpRoutes.js
const express = require("express");
const PvpRoom = require("../models/PvpRoom");
const auth = require("../middleware/auth");
const admin = require("../middleware/admin");
const { getLastSweepAt } = require("../cron/cleanupRooms");

const router = express.Router();

// GET /admin/pvp/health
router.get("/health", auth, admin, async (req, res) => {
  try {
    const countsAgg = await PvpRoom.aggregate([
      { $group: { _id: "$status", n: { $sum: 1 } } },
    ]);
    const byStatus = {};
    countsAgg.forEach((c) => (byStatus[c._id] = c.n));

    const now = Date.now();
    const sweepIntervalMs = Number(process.env.PVP_SWEEP_INTERVAL_MS) || 60000;
    const lastSweepAt = getLastSweepAt();
    const nextSweepAt = lastSweepAt ? lastSweepAt + sweepIntervalMs : null;

    const staleCoinflips = await PvpRoom.countDocuments({
      status: "active",
      game: "coinflip",
      "metadata.pendingCoin.revealAt": { $lt: now },
    });
    const staleDice = await PvpRoom.countDocuments({
      status: "active",
      game: "dice",
      "metadata.pending.advanceAt": { $lt: now },
    });

    res.json({
      ok: true,
      serverNow: now,
      serverNowIso: new Date(now).toISOString(),
      counts: byStatus,
      stale: { coinflip: staleCoinflips, dice: staleDice },
      cron: {
        sweepIntervalMs,
        lastSweepAt,
        lastSweepIso: lastSweepAt ? new Date(lastSweepAt).toISOString() : null,
        nextSweepAt,
        nextSweepIso: nextSweepAt ? new Date(nextSweepAt).toISOString() : null,
      },
      uptimeSec: Math.floor(process.uptime()),
    });
  } catch (e) {
    res.status(500).json({ ok: false, error: e.message });
  }
});

module.exports = { router };




=== D:\Downloads\cado4fun\server\routes\authRoutes.js ===

// server/routes/authRoutes.js
const express  = require('express');
const router   = express.Router();
const bcrypt   = require('bcryptjs');
const jwt      = require('jsonwebtoken');
const Joi      = require('joi');
const User     = require('../models/User');
const auth     = require('../middleware/auth');

// Schema validation
const registerSchema = Joi.object({
  username: Joi.string().min(3).max(30).required(),
  email:    Joi.string().email().required(),
  password: Joi.string().min(6).required(),
});

const loginSchema = Joi.object({
  usernameOrEmail: Joi.string().required(),
  password:        Joi.string().required(),
});

// ƒêƒÉng k√Ω: POST /api/auth/register
router.post('/register', async (req, res) => {
  const { error } = registerSchema.validate(req.body);
  if (error) return res.status(400).json({ error: error.details[0].message });

  try {
    const { username, email, password } = req.body;

    // Ki·ªÉm tra tr√πng username ho·∫∑c email
    const existing = await User.findOne({ $or: [{ username }, { email }] });
    if (existing) {
      if (existing.username === username) {
        return res.status(400).json({ error: 'Username ƒë√£ t·ªìn t·∫°i' });
      }
      if (existing.email === email) {
        return res.status(400).json({ error: 'Email ƒë√£ t·ªìn t·∫°i' });
      }
    }

    const salt     = await bcrypt.genSalt(10);
    const hashPass = await bcrypt.hash(password, salt);

    const user = new User({ username, email, password: hashPass });
    await user.save();

    const token = jwt.sign(
      { id: user._id, role: user.role },
      process.env.JWT_SECRET,
      { expiresIn: '1d' }
    );
    res.status(201).json({ token });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: 'L·ªói server' });
  }
});

// ƒêƒÉng nh·∫≠p: POST /api/auth/login
router.post('/login', async (req, res) => {
  const { error } = loginSchema.validate(req.body);
  if (error) return res.status(400).json({ error: error.details[0].message });

  try {
    const { usernameOrEmail, password } = req.body;
    const user = await User.findOne({
      $or: [{ username: usernameOrEmail }, { email: usernameOrEmail }]
    });
    if (!user) return res.status(400).json({ error: 'T√†i kho·∫£n kh√¥ng t·ªìn t·∫°i' });

    const isMatch = await bcrypt.compare(password, user.password);
    if (!isMatch) return res.status(400).json({ error: 'M·∫≠t kh·∫©u kh√¥ng ƒë√∫ng' });

    const token = jwt.sign(
      { id: user._id, role: user.role },
      process.env.JWT_SECRET,
      { expiresIn: '1d' }
    );
    res.json({ token });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: 'L·ªói server' });
  }
});

// GET /api/auth/me
router.get('/me', auth, async (req, res) => {
  try {
    const user = await User.findById(req.user.id).select('username email balance');
    if (!user) return res.status(404).json({ error: 'User not found' });

    res.json({
      id:       user._id,
      username: user.username,
      email:    user.email,
      balance:  user.balance
    });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: 'T√™n ho·∫∑c email ƒë√£ t·ªìn t·∫°i' });
  }
});

// PATCH /api/auth/me
router.patch('/me', auth, async (req, res) => {
  try {
    const { username, email } = req.body;
    const user = await User.findById(req.user.id);
    if (!user) return res.status(404).json({ error: 'User not found' });

    if (username) user.username = username;
    if (email)    user.email    = email;
    await user.save();

    res.json({
      id:       user._id,
      username: user.username,
      email:    user.email,
      balance:  user.balance
    });
  } catch (err) {
    console.error(err);
    // B·∫Øt l·ªói duplicate key (username/email)
    if (err.code === 11000) {
      if (err.keyPattern && err.keyPattern.username) {
        return res.status(400).json({ error: 'Username ƒë√£ t·ªìn t·∫°i' });
      }
      if (err.keyPattern && err.keyPattern.email) {
        return res.status(400).json({ error: 'Email ƒë√£ t·ªìn t·∫°i' });
      }
    }
    res.status(500).json({ error: 'T√™n ho·∫∑c email ƒë√£ t·ªìn t·∫°i' });
  }
});

module.exports = router;




=== D:\Downloads\cado4fun\server\routes\gameRoutes.js ===

// server/routes/gameRoutes.js
const express            = require('express');
const router             = express.Router();
const Joi                = require('joi');
const auth               = require('../middleware/auth');
const withNotification   = require('../utils/withNotification');
const { AppError }       = require('../utils/AppError');

const { coinflip }       = require('../controllers/minigames/coinflipController');
const { slots }          = require('../controllers/minigames/slotsController');
const { roulette }       = require('../controllers/minigames/rouletteController');
const { luckyFive }      = require('../controllers/minigames/luckyFiveController');
const { dice }           = require('../controllers/minigames/diceController');
const { dicePoker }      = require('../controllers/minigames/dicePokerController');
const { higherLower }    = require('../controllers/minigames/higherLowerController');
const { startMines, pickMines } = require('../controllers/minigames/minesController');
const { startTower, ascendTower, cashoutTower } = require('../controllers/minigames/towerController');
const {
  startBlackjackDice,
  hitBlackjackDice,
  standBlackjackDice,
  checkBlackjackDice,
  abandonBlackjackDice,
  resumeBlackjackDice
} = require('../controllers/minigames/blackjackDiceController');

// Validation schemas
const coinflipSchema = Joi.object({
  betAmount: Joi.number().min(1).required(),
  side: Joi.string().valid('heads', 'tails').required(),
  clientSeed: Joi.string().optional()
});

const diceSchema = Joi.object({
  betAmount: Joi.number().min(1).required(),
  sides: Joi.number().valid(4, 6, 8, 10, 12, 20).default(6),
  guess: Joi.number().min(1).required(),
  clientSeed: Joi.string().optional()
});

const rouletteSchema = Joi.object({
  betAmount: Joi.number().min(5).required(),
  betType: Joi.string().valid('zero', 'range', 'color', 'number').required(),
  betValue: Joi.alternatives().try(
    Joi.string().valid('1-9', '10-18', '19-27', '28-36', 'red', 'black'),
    Joi.number().min(0).max(36)
  ).required()
});

const higherLowerSchema = Joi.object({
  betAmount: Joi.number().min(1).required(),
  guess: Joi.string().valid('higher', 'lower').required()
});

const slotsSchema = Joi.object({
  betAmount: Joi.number().min(1).required()
});

// Validation middleware
const validate = (schema) => {
  return (req, res, next) => {
    const { error } = schema.validate(req.body);
    if (error) {
      return next(new AppError('INVALID_INPUT', 400, error.details[0].message));
    }
    next();
  };
};

// Game routes with validation
router.post('/coinflip', auth, validate(coinflipSchema), withNotification(coinflip, 'Coinflip'));
router.post('/roulette', auth, validate(rouletteSchema), withNotification(roulette, 'Roulette'));
router.post('/dice', auth, validate(diceSchema), withNotification(dice, 'Dice'));
router.post('/higherlower', auth, validate(higherLowerSchema), withNotification(higherLower, 'Higher Lower'));
router.post('/slots', auth, validate(slotsSchema), withNotification(slots, 'Slots'));

// Other game endpoints
router.post('/luckyfive', auth, withNotification(luckyFive, 'Lucky Five'));
router.post('/dicepoker', auth, withNotification(dicePoker, 'Dice Poker'));

router.post('/mines/start', auth, startMines);
router.post('/mines/pick', auth, pickMines);

router.post('/tower/start', auth, startTower);
router.post('/tower/ascend', auth, ascendTower);
router.post('/tower/cashout', auth, cashoutTower);

router.post('/blackjackdice/start', auth, startBlackjackDice);
router.post('/blackjackdice/hit', auth, withNotification(hitBlackjackDice, 'Blackjack Dice'));
router.post('/blackjackdice/stand', auth, withNotification(standBlackjackDice, 'Blackjack Dice'));
router.post('/blackjackdice/check', auth, checkBlackjackDice);
router.post('/blackjackdice/abandon', auth, abandonBlackjackDice);
router.post('/blackjackdice/resume', auth, resumeBlackjackDice);

module.exports = router;



=== D:\Downloads\cado4fun\server\routes\historyRoutes.js ===

// server/routes/historyRoutes.js
const express = require('express');
const router  = express.Router();
const auth    = require('../middleware/auth');
const validateObjectId = require('../middleware/validateObjectId');
const { getHistory } = require('../controllers/historyController');

// GET /api/user/:id/history
router.get('/:id/history', auth, validateObjectId('id'), getHistory);

module.exports = router;



=== D:\Downloads\cado4fun\server\routes\notificationRoutes.js ===

// server/routes/notificationRoutes.js
const express      = require('express');
const router       = express.Router();
const auth         = require('../middleware/auth');
const validateObjectId = require('../middleware/validateObjectId');
const Notification = require('../models/Notification');

// GET /api/notification?limit=10
router.get('/', auth, async (req, res, next) => {
  try {
    const limit = Math.min(parseInt(req.query.limit) || 20, 100);
    const notifs = await Notification
      .find({ userId: req.user.id })
      .sort({ createdAt: -1 })
      .limit(limit)
      .lean();
    res.json({ notifications: notifs });
  } catch (err) {
    next(err);
  }
});

// PATCH /api/notification/:id/read
router.patch('/:id/read', auth, validateObjectId('id'), async (req, res, next) => {
  try {
    const notif = await Notification.findOneAndUpdate(
      { _id: req.params.id, userId: req.user.id },
      { read: true },
      { new: true }
    );
    if (!notif) {
      return res.status(404).json({ error: 'Notification not found', code: 'NOT_FOUND' });
    }
    res.json({ success: true });
  } catch (err) {
    next(err);
  }
});

module.exports = router;



=== D:\Downloads\cado4fun\server\routes\pvpRoutes.js ===

// server/routes/pvpRoutes.js
const express  = require('express');
const rateLimitAll = require('express-rate-limit');
const mongoose = require('mongoose');
const PvpRoom  = require('../models/PvpRoom');
const Notification = require('../models/Notification');
const User     = require('../models/User');
const auth     = require('../middleware/auth');
const { AppError } = require('../utils/AppError');

const { makeServerSeed, sha256, coinflip, hmacHex } = require('../utils/fair');
const { logBalanceChange } = require('../utils/balanceLog');
const rl      = require('../middleware/rateLimit');
const idem    = require('../middleware/idempotency');

const router = express.Router();
const getIO = (req) => req.app.get('io');
const getOnline = (req) => req.app.get('onlineUsers') || {};

// ===== Constants =====
const ROLL_REVEAL_MS = 3000;
const HOLD_AFTER_REVEAL_MS = 3000;

// ===== Rate Limit to√†n router =====
router.use(
  rateLimitAll({
    windowMs: 10 * 1000,
    max: 60,
    standardHeaders: true,
    legacyHeaders: false,
  })
);

// ===== Helpers =====
const ALPHANUM = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
function generateShortId(len = 5) {
  let out = '';
  for (let i = 0; i < len; i++) out += ALPHANUM.charAt(Math.floor(Math.random() * ALPHANUM.length));
  return out;
}
async function generateUniqueRoomId() {
  let id;
  for (let i = 0; i < 200; i++) {
    id = generateShortId(5);
    const exists = await PvpRoom.exists({ roomId: id, status: { $in: ['waiting', 'active'] } });
    if (!exists) return id;
  }
  return id || generateShortId(5);
}
const otherSide = (s) => (s === 'heads' ? 'tails' : 'heads');

// map sha256 hex -> float [0,1)
function hexToFloat01(hex) {
  const n = parseInt(hex.slice(0, 8), 16);
  return n / 0x100000000;
}

// Emit helper
function emitRoomEvent(io, roomId, event, payload) {
  io?.to(`pvp:${roomId}`).emit(event, payload);
}

// sanitize + mirror countdown timestamps
function sanitizeRoomWithNow(doc) {
  if (!doc) return doc;
  const room = JSON.parse(JSON.stringify(doc));
  if (room?.metadata && room.status !== 'finished') {
    delete room.metadata.serverSeed;
  }
  const md = room.metadata || {};
  if (md?.pendingCoin?.revealAt && !md._revealAt) md._revealAt = md.pendingCoin.revealAt;
  if (md?.pending?.revealAt && !md._revealAt) md._revealAt = md.pending.revealAt;
  if (md?.pending?.advanceAt && !md.turnLockedUntil) md.turnLockedUntil = md.pending.advanceAt;

  room.serverNow = Date.now();
  return room;
}

// Idempotency helpers (legacy in metadata)
function ensureIdem(md) {
  md.idempotency = md.idempotency || { start: [], roll: [], finish: [] };
  return md.idempotency;
}
function seenIdem(md, type, id) {
  if (!id) return false;
  const idem = ensureIdem(md);
  return idem[type]?.includes(id);
}
function markIdem(md, type, id, cap = 100) {
  if (!id) return;
  const idem = ensureIdem(md);
  idem[type] = Array.isArray(idem[type]) ? idem[type] : [];
  if (!idem[type].includes(id)) {
    idem[type].push(id);
    if (idem[type].length > cap) idem[type].shift();
  }
}

// ---------- CONSTANTS ----------
router.get('/constants', (req, res) => {
  return res.json({
    REVEAL_MS: ROLL_REVEAL_MS,
    NEXT_TURN_DELAY: HOLD_AFTER_REVEAL_MS,
    serverNow: Date.now(),
  });
});

// ---------- LIST / DETAIL ----------
router.get('/rooms', async (req, res, next) => {
  try {
    const q = { status: { $in: ['waiting', 'active'] } };
    if (req.query.game) q.game = String(req.query.game);
    const rooms = await PvpRoom.find(q).sort({ createdAt: -1 }).limit(200).lean();
    const out = rooms.map((r) => sanitizeRoomWithNow(r));
    res.json(out);
  } catch (e) {
    next(e);
  }
});

router.get('/:roomId', async (req, res, next) => {
  try {
    const doc = await PvpRoom.findOne({ roomId: req.params.roomId })
      .populate('players.userId', 'username name avatar avatarUrl')
      .lean();
    if (!doc) throw new AppError('PVP_ROOM_NOT_FOUND', 404, 'Room not found', { roomId: req.params.roomId });

    const players = (doc.players || []).map((p) => {
      const u = p.userId && typeof p.userId === 'object' ? p.userId : null;
      return {
        userId: u?._id || p.userId,
        ready: p.ready,
        side: p.side || null,
        joinedAt: p.joinedAt,
        user: u
          ? {
              id: String(u._id),
              username: u.username || u.name || 'Unknown',
              avatar: u.avatar || u.avatarUrl || null,
            }
          : null,
      };
    });

    res.json(sanitizeRoomWithNow({ ...doc, players }));
  } catch (e) {
    next(e);
  }
});

// ---------- CREATE / JOIN / READY ----------
router.post('/create', auth, async (req, res, next) => {
  try {
    const { game = 'coinflip' } = req.body || {};
    let   { maxPlayers = 2, betAmount = 0, hostSide, diceSides } = req.body || {};
    maxPlayers = Math.max(2, Math.min(6, Number(maxPlayers) || 2));
    betAmount  = Math.max(0, Number(betAmount) || 0);
    if (game === 'coinflip') maxPlayers = 2;
    if (hostSide && !['heads','tails'].includes(hostSide)) hostSide = null;

    // ki·ªÉm tra s·ªë d∆∞ ngay khi t·∫°o ph√≤ng (kh√¥ng escrow)
    if (betAmount > 0) {
      const creator = await User.findById(req.user.id).select('balance');
      if (!creator) throw new AppError('USER_NOT_FOUND', 404, 'User not found', { userId: req.user.id });
      if (creator.balance < betAmount) {
        throw new AppError(
          'INSUFFICIENT_BALANCE',
          402,
          `S·ªë d∆∞ kh√¥ng ƒë·ªß\nS·ªë d∆∞ c·∫ßn ƒë·ªÉ th·ª±c hi·ªán: ${betAmount}`,
          { required: betAmount, have: creator.balance }
        );
      }
    }

    const roomId = await generateUniqueRoomId();
    const serverSeed = makeServerSeed();
    const serverSeedHash = sha256(serverSeed);

    const baseMeta = {
      serverSeedHash,
      serverSeed,
      clientSeed: roomId,
      nonce: 0,
      escrowed: false,
    };

    if (game === 'dice') {
      const sides = Number(diceSides) || 6;
      baseMeta.dice = { sides, rolls: [], result: null };
    }

    const room = await PvpRoom.create({
      roomId,
      game,
      betAmount,
      maxPlayers,
      players: [{ userId: req.user.id, ready: false, side: game === 'coinflip' ? (hostSide || null) : null }],
      createdBy: req.user.id,
      metadata: baseMeta
    });

    const io = getIO(req);
    io?.emit('pvp:roomCreated', {
      room: sanitizeRoomWithNow(room),
      serverNow: Date.now(),
    });

    res.json(sanitizeRoomWithNow(room));
  } catch (e) {
    next(e);
  }
});

async function joinRoomHandler(req, res, next) {
  try {
    const room = await PvpRoom.findOne({ roomId: req.params.roomId });
    if (!room) throw new AppError('PVP_ROOM_NOT_FOUND', 404, 'Room not found', { roomId: req.params.roomId });
    if (room.status !== 'waiting') throw new AppError('PVP_ROOM_NOT_JOINABLE', 409, 'Room is not joinable');

    const uid = String(req.user.id);
    let player = room.players.find(p => String(p.userId) === uid);

    if (!player) {
      if (room.players.length >= room.maxPlayers) throw new AppError('PVP_ROOM_FULL', 409, 'Room is full');

      // ki·ªÉm tra s·ªë d∆∞ khi join (kh√¥ng escrow, ch·ªâ validate)
      const bet = Number(room.betAmount || 0);
      if (bet > 0) {
        const u = await User.findById(uid).select('balance');
        if (!u) throw new AppError('USER_NOT_FOUND', 404, 'User not found', { userId: uid });
        if (u.balance < bet) {
          throw new AppError(
            'INSUFFICIENT_BALANCE',
            402,
            `S·ªë d∆∞ kh√¥ng ƒë·ªß\nS·ªë d∆∞ c·∫ßn ƒë·ªÉ th·ª±c hi·ªán: ${bet}`,
            { required: bet, have: u.balance }
          );
        }
      }

      // Auto pick side (coinflip) n·∫øu c·∫ßn
      let side = null;
      if (room.game === 'coinflip') {
        const existingSides = room.players.map(p => p.side).filter(Boolean);
        if (existingSides.includes('heads') && !existingSides.includes('tails')) side = 'tails';
        else if (existingSides.includes('tails') && !existingSides.includes('heads')) side = 'heads';
      }

      player = { userId: req.user.id, ready: false, side };
      room.players.push(player);
      await room.save();
    }

    const io = getIO(req);
    emitRoomEvent(io, room.roomId, 'pvp:roomUpdated', {
      room: sanitizeRoomWithNow(room),
      serverNow: Date.now(),
    });
    res.json(sanitizeRoomWithNow(room));
  } catch (e) {
    next(e);
  }
}
router.post('/:roomId/join', auth, joinRoomHandler);
router.post('/join/:roomId', auth, joinRoomHandler);

router.post('/:roomId/ready', auth, async (req, res, next) => {
  try {
    const room = await PvpRoom.findOne({ roomId: req.params.roomId });
    if (!room) throw new AppError('PVP_ROOM_NOT_FOUND', 404, 'Room not found', { roomId: req.params.roomId });
    if (!['waiting','active'].includes(room.status)) {
      throw new AppError('PVP_ROOM_NOT_READYABLE', 409, 'Room not in a ready-able state');
    }

    const uid = String(req.user.id);
    const player = room.players.find(p => String(p.userId) === uid);
    if (!player) throw new AppError('PVP_NOT_MEMBER', 403, 'You are not in this room');

    const desired = typeof req.body?.ready === 'boolean' ? req.body.ready : true;
    player.ready = desired;

    await room.save();

    const io = getIO(req);
    emitRoomEvent(io, room.roomId, 'pvp:roomUpdated', {
      room: sanitizeRoomWithNow(room),
      serverNow: Date.now(),
    });
    res.json(sanitizeRoomWithNow(room));
  } catch (e) {
    next(e);
  }
});

// ---------- START (idempotent) ----------
router.post(
  '/:roomId/start',
  auth,
  rl({ windowMs: 5000, max: 5 }),
  idem({ ttlMs: 120_000, namespace: 'pvp:start' }),
  async (req, res, next) => {
    try {
      const { requestId } = req.body || {};
      const room = await PvpRoom.findOne({ roomId: req.params.roomId });
      if (!room) throw new AppError('PVP_ROOM_NOT_FOUND', 404, 'Room not found', { roomId: req.params.roomId });

      const md = room.metadata || {};
      if (requestId && seenIdem(md, 'start', requestId)) {
        return res.json(sanitizeRoomWithNow(room));
      }

      if (String(room.createdBy) !== String(req.user.id)) {
        throw new AppError('PVP_ONLY_OWNER', 403, 'Only owner can start');
      }
      if (room.status !== 'waiting') {
        if (requestId) { markIdem(md, 'start', requestId); room.metadata = md; room.markModified('metadata'); await room.save(); }
        return res.json(sanitizeRoomWithNow(room));
      }
      if (room.players.length < 2) {
        throw new AppError('PVP_NEED_AT_LEAST_2_PLAYERS', 409, 'Need at least 2 players');
      }
      const nonOwners = room.players.filter(p => String(p.userId) !== String(room.createdBy));
      if (nonOwners.length === 0 || !nonOwners.every(p => p.ready)) {
        throw new AppError('PVP_ALL_PARTICIPANTS_MUST_READY', 409, 'All participants must be ready');
      }

      const bet = Number(room.betAmount || 0);
      if (bet < 0) throw new AppError('INVALID_AMOUNT', 400, 'Invalid bet amount');

      const playerIds = room.players.map(p => String(p.userId));

      if (requestId) markIdem(md, 'start', requestId);

      // ESCROW
      if (md.escrowed !== true) {
        const session = await mongoose.startSession();
        try {
          await session.withTransaction(async () => {
            const users = await User.find({ _id: { $in: playerIds } }).session(session).select('balance');
            const byId = new Map(users.map(u => [String(u._id), u]));
            for (const pid of playerIds) {
              const u = byId.get(pid);
              if (!u || u.balance < bet) {
                throw new AppError(
                  'INSUFFICIENT_BALANCE',
                  402,
                  `S·ªë d∆∞ kh√¥ng ƒë·ªß\nS·ªë d∆∞ c·∫ßn ƒë·ªÉ th·ª±c hi·ªán: ${bet}`,
                  { userId: pid, required: bet, have: u?.balance ?? 0 }
                );
              }
            }

            for (const pid of playerIds) {
              const doc = await User.findOneAndUpdate(
                { _id: pid }, { $inc: { balance: -bet } }, { new: true, session }
              ).select('balance');
              await logBalanceChange(
                { userId: pid, roomId: room.roomId, delta: -bet, reason: 'escrow', balanceAfter: doc?.balance },
                session
              );
            }

            md.escrowed = true;
            room.metadata = md;
            room.markModified('metadata');
            await room.save({ session });
          });
        } finally {
          await session.endSession();
        }
      }

      // ===== COINFLIP =====
      if (room.game === 'coinflip') {
        const host  = room.players.find(p => String(p.userId) === String(room.createdBy));
        const guest = room.players.find(p => String(p.userId) !== String(room.createdBy));
        if (!host || !guest) throw new AppError('PVP_NOT_COINFLIP_ROOM', 400, 'Coinflip requires exactly 2 players');

        if (!host.side && guest.side) host.side = otherSide(guest.side);
        if (!guest.side && host.side) guest.side = otherSide(host.side);

        if (!md.serverSeed) md.serverSeed = makeServerSeed();
        md.serverSeedHash = sha256(md.serverSeed);
        if (!md.clientSeed) md.clientSeed = room.roomId;
        if (typeof md.nonce !== 'number') md.nonce = 0;

        const flip = coinflip({ serverSeed: md.serverSeed, clientSeed: md.clientSeed, nonce: md.nonce });
        md.nonce += 1;

        let winnerUserId = null;
        if (flip === host.side) winnerUserId = host.userId;
        else if (flip === guest.side) winnerUserId = guest.userId;

        const now = Date.now();
        md.pendingCoin = {
          result: flip,
          winnerUserId: String(winnerUserId || ''),
          revealAt: now + ROLL_REVEAL_MS
        };

        room.status = 'active';
        room.metadata = md;
        room.markModified('metadata');
        await room.save();

        const io = getIO(req);
        emitRoomEvent(io, room.roomId, 'pvp:roomUpdated', {
          room: sanitizeRoomWithNow(room),
          serverNow: Date.now(),
        });

        // payout/refund sau reveal
        setTimeout(async () => {
          const session = await mongoose.startSession();
          try {
            await session.withTransaction(async () => {
              const rDoc = await PvpRoom.findOne({ _id: room._id }).session(session);
              if (!rDoc) return;
              const m2 = rDoc.metadata || {};
              if (!m2.pendingCoin) return;

              const bet2 = Number(rDoc.betAmount || 0);
              const pot = bet2 * 2;

              if (m2.pendingCoin.winnerUserId) {
                const upd = await User.findOneAndUpdate(
                  { _id: m2.pendingCoin.winnerUserId }, { $inc: { balance: pot } }, { new: true, session }
                ).select('balance');
                await logBalanceChange(
                  { userId: m2.pendingCoin.winnerUserId, roomId: rDoc.roomId, delta: pot, reason: 'payout_coinflip', balanceAfter: upd?.balance },
                  session
                );
              } else {
                const ids = rDoc.players.map(p => String(p.userId));
                for (const id of ids) {
                  const upd = await User.findOneAndUpdate(
                    { _id: id }, { $inc: { balance: bet2 } }, { new: true, session }
                  ).select('balance');
                  await logBalanceChange(
                    { userId: id, roomId: rDoc.roomId, delta: bet2, reason: 'refund_draw_coinflip', balanceAfter: upd?.balance },
                    session
                  );
                }
              }

              rDoc.status = 'finished';
              rDoc.winnerUserId = m2.pendingCoin.winnerUserId || null;
              m2.flipResult = m2.pendingCoin.result;
              m2.serverSeedReveal = m2.serverSeed;
              delete m2.pendingCoin;

              rDoc.metadata = m2;
              rDoc.markModified('metadata');
              await rDoc.save({ session });
            });

            const io2 = getIO(req);
            const fresh = await PvpRoom.findOne({ _id: room._id }).lean();
            emitRoomEvent(io2, fresh.roomId, 'pvp:roomFinished', {
              room: sanitizeRoomWithNow(fresh),
              serverNow: Date.now(),
            });
          } catch (err) {
            console.error('coinflip payout tx error:', err.message);
          } finally {
            await session.endSession();
          }
        }, ROLL_REVEAL_MS);

        return res.json(sanitizeRoomWithNow(room));
      }

      // ===== DICE =====
      if (room.game === 'dice') {
        md.turnOrder = room.players.map(p => String(p.userId));
        md.currentTurnIndex = 0;
        if (!md.dice) md.dice = { sides: 6, rolls: [], result: null };
        md.dice.rolls = [];
        md.dice.result = null;
        delete md.pending;

        room.status = 'active';
        room.metadata = md;
        room.markModified('metadata');
        await room.save();

        const io = getIO(req);
        io?.emit('pvp:roomStarted', {
          room: sanitizeRoomWithNow(room),
          serverNow: Date.now(),
        });
        emitRoomEvent(io, room.roomId, 'pvp:roomUpdated', {
          room: sanitizeRoomWithNow(room),
          serverNow: Date.now(),
        });
        return res.json(sanitizeRoomWithNow(room));
      }

      res.json(sanitizeRoomWithNow(room));
    } catch (e) {
      next(e);
    }
  }
);

// ---------- DICE: ROLL (idempotent) ----------
router.post(
  '/:roomId/roll',
  auth,
  rl({ windowMs: 4000, max: 8 }),
  idem({ ttlMs: 120_000, namespace: 'pvp:roll' }),
  async (req, res, next) => {
    try {
      const { requestId } = req.body || {};
      const room = await PvpRoom.findOne({ roomId: req.params.roomId });
      if (!room) throw new AppError('PVP_ROOM_NOT_FOUND', 404, 'Room not found', { roomId: req.params.roomId });
      if (room.game !== 'dice') throw new AppError('PVP_NOT_DICE_ROOM', 400, 'Not a dice room');
      if (room.status !== 'active') throw new AppError('PVP_ROOM_NOT_ACTIVE', 409, 'Room not active');

      const md = room.metadata || {};
      if (requestId && seenIdem(md, 'roll', requestId)) {
        return res.json(sanitizeRoomWithNow(room));
      }

      const order = Array.isArray(md.turnOrder) && md.turnOrder.length
        ? md.turnOrder.map(String)
        : room.players.map(p=>String(p.userId));
      if (!order.length || typeof md.currentTurnIndex !== 'number') {
        throw new AppError('PVP_TURN_ORDER_NOT_INITIALIZED', 409, 'Turn order not initialized');
      }
      const idx = typeof md.currentTurnIndex === 'number' ? md.currentTurnIndex : 0;
      const curUserId = String(order[idx]);
      const uid = String(req.user.id);
      if (uid !== curUserId) throw new AppError('PVP_NOT_YOUR_TURN', 403, 'Not your turn');

      if (md.pending) {
        throw new AppError('PVP_ROLL_PENDING', 409, 'Please wait for current roll to resolve');
      }

      md.dice = md.dice || { sides: 6, rolls: [], result: null };
      md.dice.rolls = md.dice.rolls || [];
      const alreadyRolled = md.dice.rolls.some(r => String(r.userId) === uid);
      if (alreadyRolled) {
        if (requestId) { markIdem(md, 'roll', requestId); room.metadata = md; room.markModified('metadata'); await room.save(); }
        return res.json(sanitizeRoomWithNow(room));
      }

      const sides = Number(md.dice.sides || 6);

      // Provably fair HMAC
      const serverSeed = md.serverSeed;
      const clientSeed = (md.clientSeed || room.roomId) + `|${uid}`;
      const nonce = typeof md.nonce === 'number' ? md.nonce : 0;
      const hex = hmacHex({ serverSeed, clientSeed, nonce });
      const r = hexToFloat01(hex);
      const value = Math.floor(r * sides) + 1;
      md.nonce = nonce + 1;

      if (requestId) markIdem(md, 'roll', requestId);

      const now = Date.now();
      const revealAt = now + ROLL_REVEAL_MS;
      const advanceAt = revealAt + HOLD_AFTER_REVEAL_MS;
      md.pending = { userId: uid, value, revealAt, advanceAt };

      room.metadata = md;
      room.markModified('metadata');
      await room.save();

      const io = getIO(req);
      emitRoomEvent(io, room.roomId, 'pvp:roomUpdated', {
        room: sanitizeRoomWithNow(room),
        serverNow: Date.now(),
      });

      // Reveal
      setTimeout(async () => {
        try {
          const rDoc = await PvpRoom.findOne({ _id: room._id });
          if (!rDoc || rDoc.status !== 'active') return;
          const m2 = rDoc.metadata || {};
          if (!m2.pending || String(m2.pending.userId) !== uid || m2.pending.value !== value) return;

          m2.dice = m2.dice || { sides: 6, rolls: [], result: null };
          m2.dice.rolls = m2.dice.rolls || [];
          if (!m2.dice.rolls.some(x => String(x.userId) === uid)) {
            m2.dice.rolls.push({ userId: uid, value });
          }

          rDoc.metadata = m2;
          rDoc.markModified('metadata');
          await rDoc.save();
          emitRoomEvent(getIO(req), rDoc.roomId, 'pvp:roomUpdated', {
            room: sanitizeRoomWithNow(rDoc),
            serverNow: Date.now(),
          });
        } catch {}
      }, ROLL_REVEAL_MS);

      // Next turn / finish
      setTimeout(async () => {
        try {
          const rDoc = await PvpRoom.findOne({ _id: room._id });
          if (!rDoc) return;
          const m2 = rDoc.metadata || {};
          if (!m2.pending || String(m2.pending.userId) !== uid || m2.pending.value !== value) return;

          const order2 = Array.isArray(m2.turnOrder) && m2.turnOrder.length
            ? m2.turnOrder.map(String)
            : rDoc.players.map(p=>String(p.userId));
          const idx2 = typeof m2.currentTurnIndex === 'number' ? m2.currentTurnIndex : 0;

          const allRolled = (m2.dice?.rolls?.length || 0) >= order2.length;

          if (allRolled) {
            const max = Math.max(...m2.dice.rolls.map(x => x.value));
            const winners = m2.dice.rolls.filter(x => x.value === max).map(x => String(x.userId));

            const bet2 = Number(rDoc.betAmount || 0);
            const pot = bet2 * order2.length;
            const share = pot / winners.length;

            const session = await mongoose.startSession();
            try {
              await session.withTransaction(async () => {
                for (const wid of winners) {
                  const upd = await User.findOneAndUpdate(
                    { _id: wid }, { $inc: { balance: share } }, { new: true, session }
                  ).select('balance');
                  await logBalanceChange(
                    { userId: wid, roomId: rDoc.roomId, delta: share, reason: 'payout_dice', balanceAfter: upd?.balance },
                    session
                  );
                }

                rDoc.status = 'finished';
                rDoc.winnerUserId = null;
                m2.serverSeedReveal = m2.serverSeed;
                m2.dice.result = { max, winners, pot };
                delete m2.pending;

                rDoc.metadata = m2;
                rDoc.markModified('metadata');
                await rDoc.save({ session });
              });
            } finally {
              await session.endSession();
            }

            const io2 = getIO(req);
            const fresh = await PvpRoom.findOne({ _id: room._id }).lean();
            emitRoomEvent(io2, fresh.roomId, 'pvp:roomFinished', {
              room: sanitizeRoomWithNow(fresh),
              serverNow: Date.now(),
            });
            return;
          }

          const nextIdx = (idx2 + 1) % order2.length;
          m2.currentTurnIndex = nextIdx;
          delete m2.pending;

          rDoc.metadata = m2;
          rDoc.markModified('metadata');
          await rDoc.save();
          emitRoomEvent(getIO(req), rDoc.roomId, 'pvp:roomUpdated', {
            room: sanitizeRoomWithNow(rDoc),
            serverNow: Date.now(),
          });
        } catch {}
      }, ROLL_REVEAL_MS + HOLD_AFTER_REVEAL_MS);

      return res.json(sanitizeRoomWithNow(room));
    } catch (e) {
      next(e);
    }
  }
);

// ---------- FINISH (idempotent / legacy hook) ----------
router.post(
  '/:roomId/finish',
  auth,
  rl({ windowMs: 5000, max: 5 }),
  idem({ ttlMs: 120_000, namespace: 'pvp:finish' }),
  async (req, res, next) => {
    try {
      const { winnerUserId, metadata, requestId } = req.body || {};
      const room = await PvpRoom.findOne({ roomId: req.params.roomId });
      if (!room) throw new AppError('PVP_ROOM_NOT_FOUND', 404, 'Room not found', { roomId: req.params.roomId });

      const md = room.metadata || {};
      if (requestId && seenIdem(md, 'finish', requestId)) {
        return res.json(sanitizeRoomWithNow(room));
      }

      if (room.status === 'finished') {
        if (requestId) { markIdem(md, 'finish', requestId); room.metadata = md; room.markModified('metadata'); await room.save(); }
        return res.json(sanitizeRoomWithNow(room));
      }

      if (requestId) markIdem(md, 'finish', requestId);

      room.winnerUserId = winnerUserId || null;
      room.status = 'finished';
      if (metadata) room.metadata = { ...(room.metadata || {}), ...metadata };
      if (room.metadata?.pending) delete room.metadata.pending;
      if (room.metadata?.pendingCoin) delete room.metadata.pendingCoin;

      room.markModified('metadata');
      await room.save();

      const io = getIO(req);
      emitRoomEvent(io, room.roomId, 'pvp:roomFinished', {
        room: sanitizeRoomWithNow(room),
        serverNow: Date.now(),
      });

      res.json(sanitizeRoomWithNow(room));
    } catch (e) {
      next(e);
    }
  }
);

// ---------- VERIFY ----------
router.get('/:roomId/verify', auth, async (req, res, next) => {
  try {
    const doc = await PvpRoom.findOne({ roomId: req.params.roomId }).lean();
    if (!doc) throw new AppError('PVP_ROOM_NOT_FOUND', 404, 'Room not found', { roomId: req.params.roomId });
    if (doc.status !== 'finished') throw new AppError('PVP_ROOM_NOT_FINISHED', 409, 'Room not finished yet');

    const md = doc.metadata || {};
    const base = {
      game: doc.game,
      serverSeedHash: md.serverSeedHash || null,
      serverSeedReveal: md.serverSeedReveal || null,
      clientSeed: md.clientSeed || doc.roomId,
      nonceStart: typeof md.nonce === 'number' && Array.isArray(md?.dice?.rolls)
        ? md.nonce - md.dice.rolls.length
        : (typeof md.nonce === 'number' ? md.nonce : 0),
      serverNow: Date.now(),
    };

    if (doc.game === 'coinflip') {
      const nonceUsed = typeof md.nonce === 'number' ? md.nonce - 1 : null;
      return res.json({
        ...base,
        coinflip: {
          result: md.flipResult || null,
          winnerUserId: doc.winnerUserId ? String(doc.winnerUserId) : null,
          nonceUsed
        }
      });
    }

    if (doc.game === 'dice') {
      const sides = Number(md?.dice?.sides || 6);
      const rolls = Array.isArray(md?.dice?.rolls) ? md.dice.rolls : [];
      const nonceStart = base.nonceStart || 0;
      const enriched = rolls.map((r, i) => ({
        userId: String(r.userId),
        value: r.value,
        nonce: nonceStart + i
      }));
      return res.json({
        ...base,
        dice: { sides, rolls: enriched }
      });
    }

    return res.json(base);
  } catch (e) {
    next(e);
  }
});

// ---------- legacy bet/leave/delete/invite ----------
router.post('/:roomId/bet', auth, async (req, res, next) => {
  try {
    const { amount, choice } = req.body || {};
    if (!(Number(amount) > 0)) throw new AppError('INVALID_AMOUNT', 400, 'Invalid amount');

    const room = await PvpRoom.findOne({ roomId: req.params.roomId });
    if (!room) throw new AppError('PVP_ROOM_NOT_FOUND', 404, 'Room not found', { roomId: req.params.roomId });
    if (room.status !== 'active') throw new AppError('PVP_ROOM_NOT_ACTIVE', 409, 'Room is not active');

    const uid = String(req.user.id);
    const inRoom = room.players.some(p => String(p.userId) === uid);
    if (!inRoom) throw new AppError('PVP_NOT_MEMBER', 403, 'You are not in this room');

    room.bets.push({ userId: req.user.id, amount: Number(amount), choice });
    await room.save();

    const io = getIO(req);
    emitRoomEvent(io, room.roomId, 'pvp:roomUpdated', {
      room: sanitizeRoomWithNow(room),
      serverNow: Date.now(),
    });
    res.json(sanitizeRoomWithNow(room));
  } catch (e) {
    next(e);
  }
});

router.post('/:roomId/leave', auth, async (req, res, next) => {
  try {
    const room = await PvpRoom.findOne({ roomId: req.params.roomId });
    if (!room) throw new AppError('PVP_ROOM_NOT_FOUND', 404, 'Room not found', { roomId: req.params.roomId });

    if (room.status === 'active') {
      throw new AppError('PVP_ROOM_ALREADY_ACTIVE', 409, 'Cannot leave an active room');
    }

    const uid = String(req.user.id);
    if (String(room.createdBy) === uid) {
      throw new AppError('PVP_ONLY_OWNER', 409, 'Owner cannot leave. Use delete instead.');
    }

    const before = room.players.length;
    room.players = room.players.filter(p => String(p.userId) !== uid);
    if (room.players.length === before) {
      throw new AppError('PVP_NOT_MEMBER', 400, 'You are not in this room');
    }

    if (room.players.length === 0) {
      await PvpRoom.deleteOne({ _id: room._id });
      const io = getIO(req);
      io?.emit('pvp:roomDeleted', { roomId: room.roomId, serverNow: Date.now() });
      return res.json({ ok: true, deleted: true, serverNow: Date.now() });
    }

    await room.save();
    const io = getIO(req);
    emitRoomEvent(io, room.roomId, 'pvp:roomUpdated', {
      room: sanitizeRoomWithNow(room),
      serverNow: Date.now(),
    });

    res.json({ ok: true, room: sanitizeRoomWithNow(room) });
  } catch (e) {
    next(e);
  }
});

router.delete('/:roomId', auth, async (req, res, next) => {
  try {
    const room = await PvpRoom.findOne({ roomId: req.params.roomId });
    if (!room) throw new AppError('PVP_ROOM_NOT_FOUND', 404, 'Room not found', { roomId: req.params.roomId });
    if (String(room.createdBy) !== String(req.user.id)) {
      throw new AppError('PVP_ONLY_OWNER', 403, 'Only owner can delete');
    }
    if (room.status !== 'waiting') {
      throw new AppError('PVP_ROOM_NOT_WAITING', 409, 'Can delete only when waiting');
    }

    await PvpRoom.deleteOne({ _id: room._id });
    const io = getIO(req);
    io?.emit('pvp:roomDeleted', { roomId: room.roomId, serverNow: Date.now() });

    res.json({ ok: true, serverNow: Date.now() });
  } catch (e) {
    next(e);
  }
});

// ‚úÖ UPDATED: invite validates user & returns invited username
router.post('/:roomId/invite', auth, async (req, res, next) => {
  try {
    const { targetUserId } = req.body || {};
    if (!targetUserId) throw new AppError('INVALID_TRANSFER_DATA', 400, 'targetUserId required');

    if (!mongoose.isValidObjectId(targetUserId)) {
      throw new AppError('INVALID_USER_ID', 400, 'Invalid user id');
    }
    const target = await User.findById(targetUserId).select('username name').lean();
    if (!target) {
      throw new AppError('USER_NOT_FOUND', 404, 'User not found');
    }

    const room = await PvpRoom.findOne({ roomId: req.params.roomId });
    if (!room) throw new AppError('PVP_ROOM_NOT_FOUND', 404, 'Room not found', { roomId: req.params.roomId });

    const isMember = room.players.some(p => String(p.userId) === String(req.user.id)) ||
                     String(room.createdBy) === String(req.user.id);
    if (!isMember) throw new AppError('PVP_NOT_MEMBER', 403, 'Only members can invite');

    const inviter = await User.findById(req.user.id).select('username name email').lean();
    const fromUserName = inviter?.username || inviter?.name || inviter?.email || 'Unknown';

    const path = `/game/battle/room/${room.roomId}`;
    const notif = await Notification.create({
      userId: target._id,
      type: 'pvp_invite',
      message: `Invitation from ${fromUserName} to join a ${room.game} room`,
      read: false,
      link: path,
      metadata: {
        roomId: room.roomId,
        game: room.game,
        betAmount: room.betAmount,
        fromUserId: String(req.user.id),
        fromUserName,
        path,
      },
    });

    const io = getIO(req);
    const sockets = (getOnline(req)[String(target._id)] || []);
    const payload = {
      _id: String(notif._id),
      userId: String(target._id),
      type: notif.type,
      message: notif.message,
      read: false,
      createdAt: notif.createdAt,
      link: notif.link,
      metadata: notif.metadata,
      serverNow: Date.now(),
    };
    sockets.forEach((sid) => io?.to(sid).emit('notification', payload));
    io?.to(sockets).emit?.('pvp:invite', payload);

    res.json({
      ok: true,
      delivered: sockets.length,
      notificationId: String(notif._id),
      invitedUser: { id: String(target._id), username: target.username || target.name || '' },
      serverNow: Date.now()
    });
  } catch (e) {
    next(e);
  }
});

module.exports = router;




=== D:\Downloads\cado4fun\server\routes\rewardRoutes.js ===

// server/routes/rewardRoutes.js
const express = require('express');
const router  = express.Router();
const auth    = require('../middleware/auth');
const {
  getRewardsStatus,
  collectReward
} = require('../controllers/rewardController');

// L·∫•y tr·∫°ng th√°i cooldown
router.get('/', auth, getRewardsStatus);
// Collect reward (hourly|daily|weekly)
router.post('/:type', auth, collectReward);

module.exports = router;




=== D:\Downloads\cado4fun\server\routes\userRoutes.js ===

// server/routes/userRoutes.js
const express    = require('express');
const bcrypt     = require('bcryptjs');
const router     = express.Router();

const auth       = require('../middleware/auth');
const adminOnly  = require('../middleware/admin');
const validateObjectId = require('../middleware/validateObjectId');
const User       = require('../models/User');
const { AppError } = require('../utils/AppError');

// ADMIN: Get all users
router.get('/', auth, adminOnly, async (req, res, next) => {
  try {
    const users = await User.find().select('-password');
    res.json(users);
  } catch (err) {
    next(err);
  }
});

// GET current user (self)
router.get('/me', auth, async (req, res, next) => {
  try {
    const user = await User.findById(req.user.id).select('-password');
    if (!user) throw new AppError('USER_NOT_FOUND', 404, 'User not found');
    res.json(user);
  } catch (err) {
    next(err);
  }
});

// GET any user's username (for transfer confirm)
router.get('/:id', auth, validateObjectId('id'), async (req, res, next) => {
  try {
    const u = await User.findById(req.params.id).select('username');
    if (!u) throw new AppError('USER_NOT_FOUND', 404, 'User not found');
    res.json({ username: u.username });
  } catch (err) {
    next(err);
  }
});

// UPDATE profile (self)
router.patch('/me', auth, async (req, res, next) => {
  try {
    const { username, email, avatar, dateOfBirth, currentPassword } = req.body;

    if (!currentPassword) {
      throw new AppError('INVALID_INPUT', 400, 'Current password is required');
    }

    const user = await User.findById(req.user.id);
    if (!user) throw new AppError('USER_NOT_FOUND', 404, 'User not found');

    const isMatch = await bcrypt.compare(currentPassword, user.password);
    if (!isMatch) {
      throw new AppError('INVALID_PASSWORD', 400, 'Current password is incorrect');
    }

    if (username) user.username = username;
    if (email) user.email = email;
    if (avatar !== undefined) user.avatar = avatar;
    if (dateOfBirth !== undefined) user.dateOfBirth = dateOfBirth;

    await user.save();

    const { password, ...safeUser } = user.toObject();
    res.json(safeUser);
  } catch (err) {
    if (err.code === 11000) {
      if (err.keyPattern?.username) {
        return next(new AppError('DUPLICATE_USERNAME', 400, 'Username already exists'));
      }
      if (err.keyPattern?.email) {
        return next(new AppError('DUPLICATE_EMAIL', 400, 'Email already exists'));
      }
    }
    next(err);
  }
});

// CHANGE password (self)
router.post('/me/password', auth, async (req, res, next) => {
  try {
    const { oldPassword, newPassword } = req.body;
    
    if (!oldPassword || !newPassword) {
      throw new AppError('INVALID_INPUT', 400, 'Old and new passwords are required');
    }
    
    const user = await User.findById(req.user.id);
    if (!user) throw new AppError('USER_NOT_FOUND', 404, 'User not found');

    const match = await bcrypt.compare(oldPassword, user.password);
    if (!match) throw new AppError('INVALID_PASSWORD', 400, 'Old password is incorrect');

    const salt = await bcrypt.genSalt(10);
    user.password = await bcrypt.hash(newPassword, salt);
    await user.save();

    res.json({ message: 'Password changed successfully' });
  } catch (err) {
    next(err);
  }
});

module.exports = router;



=== D:\Downloads\cado4fun\server\routes\walletRoutes.js ===

// server/routes/walletRoutes.js
const express      = require('express');
const router       = express.Router();
const auth         = require('../middleware/auth');
const validateObjectId = require('../middleware/validateObjectId');
const User         = require('../models/User');
const Transaction  = require('../models/Transaction');
const Notification = require('../models/Notification');
const { AppError } = require('../utils/AppError');

// Helper: create & emit notification
async function pushNotification(req, userId, type, message) {
  const notif = await Notification.create({ userId, type, message });
  const io = req.app.get('io');
  const onlineUsers = req.app.get('onlineUsers');
  const sockets = onlineUsers[userId] || [];
  sockets.forEach(socketId => {
    io.to(socketId).emit('notification', notif);
  });
}

// POST /api/wallet/:id/bank/deposit
router.post('/:id/bank/deposit', auth, validateObjectId('id'), async (req, res, next) => {
  try {
    const { amount } = req.body;
    if (typeof amount !== 'number' || amount <= 0) {
      throw new AppError('INVALID_AMOUNT', 400, 'Invalid amount');
    }

    const user = await User.findById(req.params.id);
    if (!user) throw new AppError('USER_NOT_FOUND', 404, 'User not found');

    if (user.balance < amount) {
      throw new AppError('INSUFFICIENT_BALANCE', 402, 'Insufficient balance', {
        required: amount,
        have: user.balance
      });
    }

    user.balance -= amount;
    user.bank += amount;
    await user.save();

    await Transaction.create({
      userId:    user._id,
      type:      'deposit',
      amount,
      createdAt: new Date()
    });

    await pushNotification(
      req,
      user._id,
      'deposit',
      `You deposited ${amount} from Account to Bank`
    );

    res.json({ balance: user.balance, bank: user.bank });
  } catch (err) {
    next(err);
  }
});

// POST /api/wallet/:id/bank/withdraw
router.post('/:id/bank/withdraw', auth, validateObjectId('id'), async (req, res, next) => {
  try {
    const { amount } = req.body;
    if (typeof amount !== 'number' || amount <= 0) {
      throw new AppError('INVALID_AMOUNT', 400, 'Invalid amount');
    }

    const user = await User.findById(req.params.id);
    if (!user) throw new AppError('USER_NOT_FOUND', 404, 'User not found');

    if (user.bank < amount) {
      throw new AppError('INSUFFICIENT_BANK_BALANCE', 402, 'Insufficient bank balance', {
        required: amount,
        have: user.bank
      });
    }

    user.bank -= amount;
    user.balance += amount;
    await user.save();

    await Transaction.create({
      userId:    user._id,
      type:      'withdraw',
      amount,
      createdAt: new Date()
    });

    await pushNotification(
      req,
      user._id,
      'withdraw',
      `You withdrew ${amount} from Bank to Account`
    );

    res.json({ balance: user.balance, bank: user.bank });
  } catch (err) {
    next(err);
  }
});

// POST /api/wallet/:id/transfer
router.post('/:id/transfer', auth, validateObjectId('id'), async (req, res, next) => {
  try {
    const { toUserId, amount } = req.body;
    if (!toUserId || typeof amount !== 'number' || amount <= 0) {
      throw new AppError('INVALID_TRANSFER_DATA', 400, 'Invalid transfer data');
    }

    const fromUser = await User.findById(req.params.id);
    const toUser   = await User.findById(toUserId);
    if (!fromUser || !toUser) {
      throw new AppError('USER_NOT_FOUND', 404, 'User not found');
    }
    if (fromUser.balance < amount) {
      throw new AppError('INSUFFICIENT_BALANCE', 402, 'Insufficient balance', {
        required: amount,
        have: fromUser.balance
      });
    }

    fromUser.balance -= amount;
    toUser.balance   += amount;
    await fromUser.save();
    await toUser.save();

    await Transaction.create({
      userId:    fromUser._id,
      type:      'transfer',
      amount,
      toUserId:  toUser._id,
      createdAt: new Date()
    });
    await Transaction.create({
      userId:      toUser._id,
      type:        'transfer',
      amount,
      fromUserId:  fromUser._id,
      createdAt:   new Date()
    });

    await pushNotification(
      req,
      fromUser._id,
      'transfer_sent',
      `You transferred ${amount} to ${toUser.username}`
    );
    await pushNotification(
      req,
      toUser._id,
      'transfer_received',
      `You received ${amount} from ${fromUser.username}`
    );

    res.json({ fromBalance: fromUser.balance, toBalance: toUser.balance });
  } catch (err) {
    next(err);
  }
});

// GET /api/wallet/:id/transactions
router.get('/:id/transactions', auth, validateObjectId('id'), async (req, res, next) => {
  try {
    const userId = req.params.id;
    const txs = await Transaction.find({ userId })
      .sort({ createdAt: -1 })
      .lean();
    return res.json({ transactions: txs });
  } catch (err) {
    next(err);
  }
});

module.exports = router;



=== D:\Downloads\cado4fun\server\socket\pvp.js ===

// server/socket/pvp.js
module.exports = function registerPvpSocket(io) {
  io.on('connection', (socket) => {
    // Subscribe to a room channel to receive detailed updates
    socket.on('pvp:joinRoomChannel', (roomId) => {
      if (typeof roomId === 'string' && roomId.length) {
        socket.join(`pvp:${roomId}`)
      }
    })

    socket.on('pvp:leaveRoomChannel', (roomId) => {
      if (typeof roomId === 'string' && roomId.length) {
        socket.leave(`pvp:${roomId}`)
      }
    })

    // Optional list refresh trigger
    socket.on('pvp:list', () => {
      io.emit('pvp:rooms:refresh')
    })
  })
}




=== D:\Downloads\cado4fun\server\utils\AppError.js ===

// server/utils/AppError.js
class AppError extends Error {
  /**
   * @param {string} code         M√£ l·ªói n·ªôi b·ªô, v√≠ d·ª•: 'PVP_ROOM_NOT_FOUND'
   * @param {number} httpStatus   HTTP status, v√≠ d·ª•: 404
   * @param {string} message      Th√¥ng ƒëi·ªáp d√†nh cho client (ng·∫Øn g·ªçn)
   * @param {object} meta         Th√™m ng·ªØ c·∫£nh (kh√¥ng b·∫Øt bu·ªôc)
   */
  constructor(code, httpStatus, message, meta = {}) {
    super(message || code);
    this.name = 'AppError';
    this.code = code;
    this.httpStatus = httpStatus || 500;
    this.meta = meta;
    Error.captureStackTrace?.(this, this.constructor);
  }
}

module.exports = { AppError };




=== D:\Downloads\cado4fun\server\utils\balanceLog.js ===

// server/utils/balanceLog.js
const User = require('../models/User');
const BalanceLog = require('../models/BalanceLog');

/**
 * Ghi nh·∫≠t k√Ω bi·∫øn ƒë·ªông s·ªë d∆∞.
 * - N·∫øu kh√¥ng truy·ªÅn balanceAfter, h√†m s·∫Ω t·ª± ƒë·ªçc balance hi·ªán t·∫°i c·ªßa user
 *   (sau khi caller ƒë√£ c·∫≠p nh·∫≠t v√†o DB).
 * - C√≥ th·ªÉ truy·ªÅn session ƒë·ªÉ n·∫±m chung transaction v·ªõi c·∫≠p nh·∫≠t s·ªë d∆∞.
 */
async function logBalanceChange({ userId, roomId, delta, reason, balanceAfter, meta = {} }, session = null) {
  try {
    let finalBalance = balanceAfter;
    if (typeof finalBalance !== 'number') {
      const u = await User.findById(userId).select('balance').session(session).lean();
      finalBalance = u?.balance ?? 0;
    }
    if (session) {
      await BalanceLog.create([{ userId, roomId, delta, reason, balanceAfter: finalBalance, meta }], { session });
    } else {
      await BalanceLog.create({ userId, roomId, delta, reason, balanceAfter: finalBalance, meta });
    }
  } catch (e) {
    // kh√¥ng ch·∫∑n flow n·∫øu log l·ªói
    console.error('BalanceLog error:', e.message);
  }
}

module.exports = { logBalanceChange };




=== D:\Downloads\cado4fun\server\utils\fair.js ===

// server/utils/fair.js
const crypto = require('crypto');

/**
 * In-memory active server seed for commit‚Äìreveal.
 * B·∫°n c√≥ th·ªÉ l∆∞u/rotate seed n√†y ·ªü DB/redis theo chu k·ª≥ n·∫øu mu·ªën.
 */
let ACTIVE_SERVER_SEED = null;

/** T·∫°o serverSeed ng·∫´u nhi√™n (64 hex) */
function makeServerSeed() {
  return crypto.randomBytes(32).toString('hex');
}

/** ƒê·∫∑t/rotate serverSeed ƒëang ho·∫°t ƒë·ªông (tr·∫£ l·∫°i seed m·ªõi) */
function setActiveServerSeed(seed) {
  ACTIVE_SERVER_SEED = seed || makeServerSeed();
  return ACTIVE_SERVER_SEED;
}

/** L·∫•y serverSeed ƒëang ho·∫°t ƒë·ªông (t·ª± t·∫°o n·∫øu ch∆∞a c√≥) */
function getActiveServerSeed() {
  if (!ACTIVE_SERVER_SEED) setActiveServerSeed();
  return ACTIVE_SERVER_SEED;
}

/** SHA-256 ti·ªán d·ª•ng (d√πng l√†m commit hash) */
function sha256(input) {
  return crypto.createHash('sha256').update(String(input)).digest('hex');
}

/** Commit: hash c·ªßa serverSeed hi·ªán t·∫°i */
function getSeedHash() {
  return sha256(getActiveServerSeed());
}

/**
 * HMAC hex = HMAC_SHA256(serverSeed, `${clientSeed}:${nonce}`)
 * ƒê√¢y l√† l√µi ‚Äúprovably fair‚Äù: clientSeed + nonce khi·∫øn server kh√¥ng th·ªÉ ƒë∆°n ph∆∞∆°ng ƒëi·ªÅu khi·ªÉn k·∫øt qu·∫£.
 */
function hmacHex({ serverSeed, clientSeed, nonce }) {
  const key = String(serverSeed);
  const msg = `${String(clientSeed)}:${String(nonce)}`;
  return crypto.createHmac('sha256', key).update(msg).digest('hex');
}

/** L·∫•y s·ªë th·ª±c [0,1) t·ª´ 8 hex ƒë·∫ßu c·ªßa HMAC */
function hmacFloat({ serverSeed, clientSeed, nonce }) {
  const hex = hmacHex({ serverSeed, clientSeed, nonce });
  const int32 = parseInt(hex.slice(0, 8), 16);
  return int32 / 0xffffffff; // 0..1 (kh√¥ng bao g·ªìm 1)
}

/** Coinflip t·ª´ seed (heads/tails) */
function coinflip({ serverSeed, clientSeed, nonce }) {
  return hmacFloat({ serverSeed, clientSeed, nonce }) < 0.5 ? 'heads' : 'tails';
}

/** Verify m·ªôt k·∫øt qu·∫£ coinflip */
function verify({ serverSeed, clientSeed, nonce, result }) {
  return coinflip({ serverSeed, clientSeed, nonce }) === result;
}

module.exports = {
  // seed lifecycle
  makeServerSeed,
  setActiveServerSeed,
  getActiveServerSeed,
  getSeedHash,
  sha256,
  // rng
  hmacHex,
  hmacFloat,
  coinflip,
  verify,
};




=== D:\Downloads\cado4fun\server\utils\history.js ===

// server/utils/history.js
const GameHistory = require('../models/GameHistory');

async function recordGameHistory({ userId, game, betAmount, outcome, payout }) {
  try {
    await GameHistory.create({ user: userId, game, betAmount, outcome, payout });
  } catch (err) {
    console.error('Error recording game history:', err);
  }
}

module.exports = { recordGameHistory };



=== D:\Downloads\cado4fun\server\utils\logger.js ===

// server/utils/logger.js
const os = require("os");

function log(level, msg, extra = {}) {
  const record = {
    ts: new Date().toISOString(),
    level,
    msg,
    host: os.hostname(),
    pid: process.pid,
    ...extra,
  };
  // JSON lines: d·ªÖ ship sang ELK/Datadog/Stackdriver
  console.log(JSON.stringify(record));
}

module.exports = {
  info: (msg, extra) => log("info", msg, extra),
  warn: (msg, extra) => log("warn", msg, extra),
  error: (msg, extra) => log("error", msg, extra),
};




=== D:\Downloads\cado4fun\server\utils\notify.js ===

// server/utils/notify.js
const Notification = require('../models/Notification')

/**
 * L∆∞u notification v√†o DB v√† emit real-time qua socket.io
 * @param {Express.App} app  ‚Äì your express app instance
 * @param {String} userId    ‚Äì Mongo _id c·ªßa user
 * @param {String} type      ‚Äì notification type
 * @param {String} message   ‚Äì n·ªôi dung th√¥ng b√°o
 */
async function pushNotification(app, userId, type, message) {
  // 1. L∆∞u DB
  const notif = await Notification.create({ userId, type, message })

  // 2. Emit real-time
  const io = app.get('io')
  const onlineUsers = app.get('onlineUsers') || {}
  const sockets = onlineUsers[userId] || []
  sockets.forEach(socketId => {
    io.to(socketId).emit('notification', notif)
  })
}

module.exports = { pushNotification }




=== D:\Downloads\cado4fun\server\utils\random.js ===

// server/utils/random.js

// N·∫øu mu·ªën d√πng seedable random cho provably fair, c√†i th√™m: npm install seedrandom
const seedrandom = require('seedrandom');
let rng = seedrandom();  // kh·ªüi t·∫°o v·ªõi seed m·∫∑c ƒë·ªãnh

/**
 * Returns a random integer between min and max, inclusive.
 * @param {number} min 
 * @param {number} max 
 */
function randomInt(min, max) {
  return Math.floor(rng() * (max - min + 1)) + min;
}

/**
 * Set a new seed for the RNG.
 * @param {string|number} seed 
 */
function setSeed(seed) {
  rng = seedrandom(seed);
}

module.exports = { randomInt, setSeed };




=== D:\Downloads\cado4fun\server\utils\withNotification.js ===

// server/utils/withNotification.js
const { pushNotification } = require('./notify')

/**
 * Wrap controller ƒë·ªÉ t·ª± ƒë·ªông push notification khi payload c√≥ { win, amount }
 * Response ƒë∆∞·ª£c g·ª≠i ngay, notification emit sau 2s
 */
function withNotification(controller, gameName) {
  return async (req, res, next) => {
    // gi·ªØ l·∫°i ph∆∞∆°ng th·ª©c json g·ªëc
    const originalJson = res.json.bind(res)

    // override
    res.json = (payload) => {
      // 1) g·ª≠i response cho client ngay
      originalJson(payload)

      // 2) n·∫øu ƒë√∫ng shape, schedule notification sau 2s
      if (
        payload &&
        typeof payload.win === 'boolean' &&
        typeof payload.amount === 'number'
      ) {
        const type    = payload.win ? 'game_win' : 'game_loss'
        const message = payload.win
          ? `You won ${payload.amount} on ${gameName}`
          : `You lost ${payload.amount} on ${gameName}`

        setTimeout(() => {
          pushNotification(req.app, req.user.id, type, message)
            .catch(err => console.error('Notification error:', err))
        }, 2000)
      }
    }

    // g·ªçi controller g·ªëc
    return controller(req, res, next)
  }
}

module.exports = withNotification




=== D:\Downloads\cado4fun\server\server.js ===

// server/server.js
const express      = require('express') 
const mongoose     = require('mongoose')
const cors         = require('cors')
const helmet       = require('helmet')
// ‚úÖ D√πng custom sanitizer thay v√¨ express-mongo-sanitize
const mongoSanitizeCustom = require('./middleware/mongoSanitize')
require('dotenv').config()

const authRoutes         = require('./routes/authRoutes')
const userRoutes         = require('./routes/userRoutes')
const historyRoutes      = require('./routes/historyRoutes')
const walletRoutes       = require('./routes/walletRoutes')
const gameRoutes         = require('./routes/gameRoutes')
const rewardRoutes       = require('./routes/rewardRoutes')
const notificationRoutes = require('./routes/notificationRoutes')

// ‚¨áÔ∏è PvP
const pvpRoutes          = require('./routes/pvpRoutes')
const registerPvpSocket  = require('./socket/pvp')

// ‚¨áÔ∏è Admin PvP health
const { router: adminPvpRouter } = require('./routes/adminPvpRoutes')

// ‚¨áÔ∏è PvP cron cleanup/auto-resolve
const { schedulePvpCleanup, stopPvpCleanup } = require('./cron/cleanupRooms')

// ‚¨áÔ∏è Structured request logger
const logRequest = require('./middleware/logRequest')

// ‚¨áÔ∏è Error handler (m·ªõi)
const errorHandler = require('./middleware/errorHandler')

// ‚¨áÔ∏è PvpRoom model (ƒë·ªÉ t·∫°o indexes sau khi k·∫øt n·ªëi)
const PvpRoom = require('./models/PvpRoom')

const app    = express()
const http   = require('http').createServer(app)
const { Server } = require('socket.io')

// üîê SECURITY: CORS whitelist cho Socket.IO
const allowedOrigins = [
  'http://localhost:3000',
  'http://localhost:3001',
  process.env.CLIENT_URL,
  process.env.FRONTEND_URL
].filter(Boolean)

const io = new Server(http, {
  cors: {
    origin: (origin, callback) => {
      // Allow requests with no origin (mobile apps, Postman, etc.)
      if (!origin) return callback(null, true)
      if (allowedOrigins.includes(origin)) {
        callback(null, true)
      } else {
        callback(new Error('CORS not allowed'))
      }
    },
    methods: ['GET','POST','PATCH','DELETE','OPTIONS'],
    credentials: true
  }
})

// map userId -> [socketId,...]
const onlineUsers = {}

io.on('connection', socket => {
  socket.on('register', userId => {
    onlineUsers[userId] ||= []
    onlineUsers[userId].push(socket.id)
  })

  socket.on('disconnect', () => {
    for (const [uid, sockets] of Object.entries(onlineUsers)) {
      onlineUsers[uid] = sockets.filter(id => id !== socket.id)
      if (onlineUsers[uid].length === 0) delete onlineUsers[uid]
    }
  })
})

// ‚¨áÔ∏è register PvP socket channels
registerPvpSocket(io)

app.set('io', io)
app.set('onlineUsers', onlineUsers)

// üîê SECURITY: Helmet security headers
app.use(helmet({
  contentSecurityPolicy: {
    directives: {
      defaultSrc: ["'self'"],
      styleSrc: ["'self'", "'unsafe-inline'"],
      scriptSrc: ["'self'", "'unsafe-inline'", "'unsafe-eval'"],
      imgSrc: ["'self'", "data:", "https:"],
      connectSrc: ["'self'", "http://localhost:3000", "http://localhost:3001"],
    }
  },
  crossOriginEmbedderPolicy: false,
  crossOriginResourcePolicy: { policy: "cross-origin" }
}))

// üîê SECURITY: CORS whitelist
app.use(cors({
  origin: (origin, callback) => {
    // Allow requests with no origin (mobile apps, curl, etc.)
    if (!origin) return callback(null, true)
    if (allowedOrigins.includes(origin)) {
      callback(null, true)
    } else {
      callback(new Error('Not allowed by CORS'))
    }
  },
  methods: ['GET','POST','PATCH','DELETE','OPTIONS'],
  allowedHeaders: ['Content-Type','Authorization','x-idempotency-key','x-client-now','x-request-id'],
  credentials: true
}))

app.use(express.json())

// üîê SECURITY: Sanitize MongoDB queries (prevent NoSQL injection)
// ‚úÖ FIX: Custom sanitizer to avoid req.query conflict
app.use(mongoSanitizeCustom())

// ‚¨áÔ∏è log m·ªçi request sau khi parse body/headers
app.use(logRequest)

// ‚¨áÔ∏è mount APIs
app.use('/api/auth',   authRoutes)
app.use('/api/user',   historyRoutes)
app.use('/api/user',   userRoutes)
app.use('/api/wallet', walletRoutes)
app.use('/api/game',   gameRoutes)
app.use('/api/rewards', rewardRoutes)
app.use('/api/notification', notificationRoutes)

// ‚¨áÔ∏è PvP API
app.use('/api/pvp', pvpRoutes)

// ‚¨áÔ∏è Admin PvP health API (y√™u c·∫ßu auth + admin ·ªü trong router)
app.use('/api/admin/pvp', adminPvpRouter)

app.get('/', (req, res) => {
  res.send('Cado4fun backend running!')
})

/** ƒê·∫£m b·∫£o c√°c index c·∫ßn thi·∫øt cho cron & health (idempotent).
 *  So s√°nh theo key-spec & unique thay v√¨ name ƒë·ªÉ tr√°nh l·ªói
 *  "Index already exists with a different name".
 *  ‚úÖ FIX: Drop old duplicate index before creating new one
 */
async function ensurePvpIndexes() {
  const coll = PvpRoom.collection
  try {
    const existing = await coll.indexes()

    // ‚úÖ Drop old roomId_1 index if exists (from schema definition)
    for (const idx of existing) {
      if (idx.name === 'roomId_1' && idx.key && idx.key.roomId === 1) {
        try {
          await coll.dropIndex('roomId_1')
          console.log('‚úÖ Dropped old roomId_1 index')
        } catch (e) {
          // Ignore if already dropped
        }
        break
      }
    }

    const has = (keySpec, { unique } = {}) => {
      const keyJson = JSON.stringify(keySpec)
      return existing.some(ix => {
        if (JSON.stringify(ix.key) !== keyJson) return false
        if (unique != null && !!ix.unique !== !!unique) return false
        return true
      })
    }

    const createIfMissing = async (keySpec, options = {}) => {
      if (has(keySpec, { unique: options.unique })) return
      try {
        await coll.createIndex(keySpec, options)
      } catch (e) {
        // B·ªè qua n·∫øu tr√πng key-spec v·ªõi name kh√°c (E85/IndexOptionsConflict)
        const msg = String(e && e.message || e)
        if (msg.includes('already exists with a different name') ||
            msg.includes('IndexOptionsConflict') ||
            e?.code === 85 || e?.code === 11000) {
          return
        }
        throw e
      }
    }

    // 1) coinflip pending revealAt
    await createIfMissing(
      { status: 1, game: 1, 'metadata.pendingCoin.revealAt': 1 },
      { name: 'pvp_coinflip_pending_revealAt' }
    )

    // 2) dice pending advanceAt
    await createIfMissing(
      { status: 1, game: 1, 'metadata.pending.advanceAt': 1 },
      { name: 'pvp_dice_pending_advanceAt' }
    )

    // 3) active/updatedAt cho idle/cancel sweep nhanh
    await createIfMissing(
      { status: 1, updatedAt: 1 },
      { name: 'pvp_status_updatedAt' }
    )

    // 4) roomId unique ‚Äî t·∫°o v·ªõi t√™n m·ªõi
    await createIfMissing(
      { roomId: 1 },
      { unique: true, name: 'pvp_roomId_unique' }
    )
  } catch (e) {
    console.error('ensurePvpIndexes error:', e?.message || e)
  }
}

// ‚úÖ ADD: Request size limits to prevent DoS
app.use(express.json({ limit: '1mb' }));

// ‚úÖ FIX: Remove deprecated options (useNewUrlParser, useUnifiedTopology)
mongoose.connect(process.env.MONGO_URI)
  .then(async () => {
    console.log('MongoDB connected')
    await ensurePvpIndexes() // t·∫°o index n·∫øu ch∆∞a c√≥
  })
  .catch(err => console.error('MongoDB error:', err))

// ‚¨áÔ∏è schedule PvP cleanup/auto-resolve sweeper
// (G·ªçi sau khi app.set('io', io) ƒë√£ xong)
schedulePvpCleanup(app)

// ‚¨áÔ∏è Error handler ƒë·∫∑t CU·ªêI C√ôNG (d√πng bi·∫øn ƒë√£ import)
app.use(errorHandler)

const PORT = process.env.PORT || 3001
http.listen(PORT, () => {
  console.log(`Server running on port ${PORT}`)
})

// üîΩ GRACEFUL SHUTDOWN
async function shutdown(signal) {
  try {
    console.log(`[${signal}] Shutting down...`)
    stopPvpCleanup()                        // d·ª´ng cron
    io.close(() => console.log('Socket.IO closed'))
    await mongoose.connection.close(false)  // false = kh√¥ng force
    http.close?.(() => console.log('HTTP server closed'))
  } catch (e) {
    console.error('Error during shutdown:', e)
  } finally {
    process.exit(0)
  }
}
process.on('SIGINT',  () => shutdown('SIGINT'))
process.on('SIGTERM', () => shutdown('SIGTERM'))



